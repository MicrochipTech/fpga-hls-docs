

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-VB7E9KG0X9"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-VB7E9KG0X9');
  </script>

  <meta charset="utf-8">
  
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Header information-->
    <meta name="Language" content="en">
	<meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  
  <title>User Guide &mdash; SmartHLS 2023.1 documentation</title>
  
<!-- Header information-->
<style type="text/css">svg:not(:root).svg-inline--fa {
  overflow: visible;
}

.svg-inline--fa {
  display: inline-block;
  font-size: inherit;
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.225em;
}
.svg-inline--fa.fa-w-1 {
  width: 0.0625em;
}
.svg-inline--fa.fa-w-2 {
  width: 0.125em;
}
.svg-inline--fa.fa-w-3 {
  width: 0.1875em;
}
.svg-inline--fa.fa-w-4 {
  width: 0.25em;
}
.svg-inline--fa.fa-w-5 {
  width: 0.3125em;
}
.svg-inline--fa.fa-w-6 {
  width: 0.375em;
}
.svg-inline--fa.fa-w-7 {
  width: 0.4375em;
}
.svg-inline--fa.fa-w-8 {
  width: 0.5em;
}
.svg-inline--fa.fa-w-9 {
  width: 0.5625em;
}
.svg-inline--fa.fa-w-10 {
  width: 0.625em;
}
.svg-inline--fa.fa-w-11 {
  width: 0.6875em;
}
.svg-inline--fa.fa-w-12 {
  width: 0.75em;
}
.svg-inline--fa.fa-w-13 {
  width: 0.8125em;
}
.svg-inline--fa.fa-w-14 {
  width: 0.875em;
}
.svg-inline--fa.fa-w-15 {
  width: 0.9375em;
}
.svg-inline--fa.fa-w-16 {
  width: 1em;
}
.svg-inline--fa.fa-w-17 {
  width: 1.0625em;
}
.svg-inline--fa.fa-w-18 {
  width: 1.125em;
}
.svg-inline--fa.fa-w-19 {
  width: 1.1875em;
}
.svg-inline--fa.fa-w-20 {
  width: 1.25em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-border {
  height: 1.5em;
}
.svg-inline--fa.fa-li {
  width: 2em;
}
.svg-inline--fa.fa-fw {
  width: 1.25em;
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: #ff253a;
  border-radius: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  color: #fff;
  height: 1.5em;
  line-height: 1;
  max-width: 5em;
  min-width: 1.5em;
  overflow: hidden;
  padding: 0.25em;
  right: 0;
  text-overflow: ellipsis;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: 0;
  right: 0;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: 0;
  left: 0;
  right: auto;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  right: 0;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: 0;
  right: auto;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-lg {
  font-size: 1.3333333333em;
  line-height: 0.75em;
  vertical-align: -0.0667em;
}

.fa-xs {
  font-size: 0.75em;
}

.fa-sm {
  font-size: 0.875em;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: 2.5em;
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: -2em;
  position: absolute;
  text-align: center;
  width: 2em;
  line-height: inherit;
}

.fa-border {
  border: solid 0.08em #eee;
  border-radius: 0.1em;
  padding: 0.2em 0.25em 0.15em;
}

.fa-pull-left {
  float: left;
}

.fa-pull-right {
  float: right;
}

.fa.fa-pull-left,
.fas.fa-pull-left,
.far.fa-pull-left,
.fal.fa-pull-left,
.fab.fa-pull-left {
  margin-right: 0.3em;
}
.fa.fa-pull-right,
.fas.fa-pull-right,
.far.fa-pull-right,
.fal.fa-pull-right,
.fab.fa-pull-right {
  margin-left: 0.3em;
}

.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
          animation: fa-spin 2s infinite linear;
}

.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
          animation: fa-spin 1s infinite steps(8);
}

@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}

@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical,
:root .fa-flip-both {
  -webkit-filter: none;
          filter: none;
}

.fa-stack {
  display: inline-block;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: #fff;
}

.sr-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

.sr-only-focusable:active, .sr-only-focusable:focus {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse {
  color: #fff;
}

@media screen and (max-width: 768px)
.booktitle #booktitle{
display:none;
}
</style>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css">
	<script src="https://kit.fontawesome.com/d3dd8c60ed.js"></script>
  
  
    <link rel="shortcut icon" href="_static/favicon.ico"/>
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
<link rel="stylesheet" href="_static/css/styles.e92b8b50b164f4a2ce2c.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Optimization Guide" href="optimizationguide.html" />
    <link rel="prev" title="Technical Support" href="techsupport.html" /> 
</head>

<body class="wy-body-for-nav">

		<div class="mchp-ghp"/>
		<div class="root responsivegrid">
								<noindex>
								<header _ngcontent-hes-c23="" style="background: white;"><div _ngcontent-hes-c23="" id="container" style="background: white;
"><div _ngcontent-hes-c23="" id="mc_header_container"><div _ngcontent-hes-c23="" id="mc_header_logo" class="float-left"><a _ngcontent-hes-c23="" href="https://www.microchip.com"><img _ngcontent-hes-c23="" file="Microchip_logo.png" src="_static/css/Microchip_logo.png"></a></div><div _ngcontent-hes-c23="" class="text-center tablet-hide mobile-hide"><h1 id="booktitle" class="booktitle" style="margin-top:10px;display:block;"> 
								          
											<span style="padding-top:15px;display:block;">SmartHLS  - v2023.1  </span>

										  </h1>
								
								</div></div></div><section _ngcontent-hes-c23="" class="separator"></section></header>	
								</noindex>		

		</div>
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
		
          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
         
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User Guide Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://microchiptech.github.io/fpga-hls-docs/">Latest Release</a></li>
<li class="toctree-l1"><a class="reference internal" href="versions.html">Previous Releases</a></li>
</ul>
<p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="releasenotes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="techsupport.html">Technical Support</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with SmartHLS</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-high-level-synthesis">Introduction to High-Level Synthesis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#instruction-level-parallelism">Instruction-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loop-level-parallelism">Loop-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-level-parallelism">Thread-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-flow-streaming-parallelism">Data Flow (Streaming) Parallelism</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-overview">SmartHLS Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-soc-flow-1">SmartHLS SoC Flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-pragmas-1">SmartHLS Pragmas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-constraints-1">SmartHLS Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-the-top-level-function">Specifying the Top-level Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sw-hw-co-simulation">SW/HW Co-Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#loop-pipelining-1">Loop Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#function-pipelining-1">Function Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-flow-parallelism">Data Flow Parallelism</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#dataflow-example-canny-with-fifos">Dataflow Example: Canny with FIFOs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dataflow-example-diamond">Dataflow Example: Diamond</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#multi-threading-with-smarthls-threads">Multi-threading with SmartHLS Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="#supported-smarthls-thread-apis">Supported SmartHLS Thread APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-flow-parallelism-with-smarthls-threads">Data Flow Parallelism with SmartHLS Threads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#further-throughput-enhancement-with-loop-pipelining">Further Throughput Enhancement with Loop Pipelining</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memory-partitioning-1">Memory Partitioning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#access-based-memory-partitioning">Access-Based Memory Partitioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-specified-memory-partitioning-1">User-Specified Memory Partitioning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#block-partitioning">Block Partitioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cyclic-partitioning">Cyclic Partitioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#complete-partitioning">Complete Partitioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-fields-partitioning">Struct-Fields Partitioning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#struct-support-1">Struct Support</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#struct-packing-1">Struct Packing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#struct-partitioning">Struct Partitioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#return-struct-by-value">Return Struct By Value</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-struct-modes">Default Struct Modes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#limitations">Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-c-c-library">SmartHLS C/C++ Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#streaming-library">Streaming Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#streaming-library-blocking-behaviour">Streaming Library - Blocking Behaviour</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streaming-library-non-blocking-behaviour">Streaming Library - Non-Blocking Behaviour</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-data-types-library">C++ Arbitrary Precision Data Types Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-integer-library">C++ Arbitrary Precision Integer Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printing-arbitrary-precision-integers">Printing Arbitrary Precision integers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-arbitrary-precision-integers">Initializing Arbitrary Precision integers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-arbitrary-precision-integer-arithmetic">C++ Arbitrary Precision Integer Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-arbitrary-precision-integer-explicit-conversions">C++ Arbitrary Precision Integer Explicit Conversions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-bit-level-operations">C++ Arbitrary Precision Bit-level Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#selecting-and-assigning-to-a-range-of-bits">Selecting and Assigning to a Range of Bits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bit-concatenation">Bit Concatenation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-fixed-point-library">C++ Arbitrary Precision Fixed Point Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printing-ap-u-fixpt-types">Printing ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-ap-u-fixpt-types">Initializing ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arithmetic-with-ap-u-fixpt-types">Arithmetic With ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-conversions-of-ap-u-fixpt">Explicit Conversions of ap_[u]fixpt</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point">Supported Operations in ap_[u]int, ap_[u]fixpt, and floating-point</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-double-buffer-and-shared-buffer">C++ Double Buffer and Shared Buffer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#using-doublebuffer-and-sharedbuffer-in-a-multi-threaded-dataflow-design">Using <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> in a multi-threaded dataflow design</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#image-processing-library">Image Processing Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#line-buffer">Line Buffer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#math-library-math-h">Math Library (math.h)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#memory-allocation-library">Memory Allocation Library</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-rtl-interface">Top-Level RTL Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-control-interface-1">Module Control Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-module-control-interface">Simple Module Control Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-target-for-module-control">AXI4 Target for Module Control</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-argument">Scalar Argument</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#simple-scalar-interface">Simple Scalar Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-target-for-scalar-argument">AXI4 Target for Scalar Argument</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-argument-and-shared-global-variable">Pointer Argument and Shared Global Variable</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-interface-1">Memory Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-initiator-interface">AXI4 Initiator Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-target-interface">AXI4 Target Interface</a></li>
<li class="toctree-l4"><a class="reference internal" href="#legacy-axi4-slave-interface">Legacy AXI4 Slave Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hls-fifo-argument">hls::FIFO Argument</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implementing-a-custom-axi4-master-slave-using-hls-fifo">Implementing A Custom AXI4 Master/Slave Using hls::FIFO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-library-for-custom-axi-master-interface">C++ Library for Custom AXI Master Interface</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#axi4-target-interface-vs-legacy-axi4-slave-interface">AXI4 Target Interface vs Legacy AXI4 Slave Interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#driver-functions-for-axi4-target">Driver Functions for AXI4 Target</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-control-driver-functions">Module Control Driver Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-argument-driver-functions">Scalar Argument Driver Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-argument-driver-functions">Pointer Argument Driver Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#axi4-initiator-argument-s-pointer-address-driver-functions">AXI4 Initiator Argument’s Pointer Address Driver Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-level-driver-functions-1">Top-level Driver Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#top-level-driver-options-in-pointer-arguments-axi4-target-interface-pragma">Top-level Driver Options in Pointer Arguments’ AXI4 Target Interface Pragma</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#example-usage-of-the-driver-functions">Example Usage of the Driver Functions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-a-custom-test-bench">Specifying a Custom Test Bench</a></li>
<li class="toctree-l2"><a class="reference internal" href="#synthesize-hardware-to-fpga">Synthesize Hardware to FPGA</a></li>
<li class="toctree-l2"><a class="reference internal" href="#soc-features-1">SoC Features</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#soc-flow-overview">SoC Flow Overview</a></li>
<li class="toctree-l3"><a class="reference internal" href="#soc-data-transfer-methods-1">SoC Data Transfer Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#running-soc-features">Running SoC Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#base-soc-project-programming-cross-compilation">Base SoC Project Programming / Cross-Compilation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#reference-soc-generation-1">Reference SoC Generation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-reference-soc">Running the Reference SoC</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#soc-profiler-1">SoC Profiler</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#soc-profiler-overview">SoC Profiler Overview</a></li>
<li class="toctree-l4"><a class="reference internal" href="#soc-profiling-process">SoC Profiling process</a></li>
<li class="toctree-l4"><a class="reference internal" href="#compiling-and-running-the-profiled-application">Compiling and running the profiled application</a></li>
<li class="toctree-l4"><a class="reference internal" href="#visualizing-the-profiled-data">Visualizing the profiled data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#report-files">Report Files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#smarthls-report">SmartHLS Report</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rtl-interface-section">RTL Interface Section</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scheduling-result">Scheduling Result</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pipeline-result">Pipeline Result</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-usage-1">Memory Usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-target-interface-address-map">AXI4 Target Interface Address Map</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-and-rtl-synthesis-place-route-report">Simulation and RTL Synthesis, Place &amp; Route Report</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-level-distribution-1">Logic Level Distribution</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#schedule-viewer-1">Schedule Viewer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background-llvm-internal-representation-used-by-smarthls">Background: LLVM Internal Representation used by SmartHLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call-graph">Call Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow-graph">Control Flow Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#schedule-chart">Schedule Chart</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline-viewer">Pipeline Viewer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#instantiating-smarthls-ip-core-in-libero-smartdesign">Instantiating SmartHLS IP Core in Libero SmartDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hardware-integration-of-smarthls-modules-into-soc-smartdesigns">Hardware Integration of SmartHLS modules into SoC SmartDesigns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#user-defined-smartdesigns-1">User-defined SmartDesigns</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-output-files">SmartHLS Output Files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#verilog-files">Verilog Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vhdl-wrapper-files-1">VHDL Wrapper Files</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reports">Reports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scripts">Scripts</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accelerator-driver-code">Accelerator Driver Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#reference-soc-design">Reference SoC Design</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-command-line-interface">SmartHLS Command Line Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#launch-cygwin-terminal-on-windows">Launch Cygwin terminal on Windows</a></li>
<li class="toctree-l3"><a class="reference internal" href="#setup">Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#commands">Commands</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#software-macros">Software Macros</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#synthesis-macro-1"><code class="docutils literal notranslate"><span class="pre">__SYNTHESIS__</span></code> Macro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#has-accelerator-macro"><code class="docutils literal notranslate"><span class="pre">HAS_ACCELERATOR</span></code> Macro</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cosim-early-exit-macro"><code class="docutils literal notranslate"><span class="pre">COSIM_EARLY_EXIT</span></code> Macro</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#makefile-variables">Makefile Variables</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#makefile-example-1">Makefile Example</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="optimizationguide.html">Optimization Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwarchitecture.html">Hardware Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pragmas.html">SmartHLS Pragmas Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="constraintsmanual.html">Constraints Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="license_setup.html">SmartHLS License</a></li>
<li class="toctree-l1"><a class="reference internal" href="devices.html">Supported FPGA Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="libero.html">Supported Libero version</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="vhls_to_shls.html">SmartHLS Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="precompiled_sw.html">Precompiled Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="icicle_setup.html">Icicle Kit Setup Instructions</a></li>
</ul>
<p class="caption"><span class="caption-text">SmartHLS Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/MicrochipTech/fpga-hls-examples">GitHub Examples</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SmartHLS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>User Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="user-guide">
<span id="userguide"></span><h1>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction-to-high-level-synthesis">
<h2>Introduction to High-Level Synthesis<a class="headerlink" href="#introduction-to-high-level-synthesis" title="Permalink to this headline">¶</a></h2>
<p>High-level synthesis (HLS) refers to the synthesis of a hardware circuit from a software program specified in a high-level language, where the hardware circuit performs the same functionality as the software program.  For SmartHLS, the input is a C/C++-language program, and the output is a circuit specification in the Verilog hardware description language.  The SmartHLS-generated Verilog can be given to Libero to be programmed on a Microchip FPGA. The underlying motivation for HLS is to raise the level of abstraction for hardware design, by allowing software methodologies to be used to design hardware.  This can help to shorten design cycles, improve design productivity and reduce time-to-market.</p>
<p>While a detailed knowledge of HLS is not required to use SmartHLS, it is worthwhile to highlight the key steps involved in converting software to hardware. The four main steps involved in HLS are allocation, scheduling, binding, and RTL generation, which runs one after another (i.e., binding runs after scheduling is done).</p>
<ul class="simple">
<li>Allocation: The allocation step defines the constraints on the generated hardware, including the number of hardware resources of a given type that may be used (e.g. how many divider units may be used, the number of RAM ports, etc.), as well as the target clock period for the hardware, and other user-supplied constraints.</li>
<li>Scheduling: Software programs are written without any notion of a clock or finite state machine (FSM). The scheduling step of HLS bridges this gap, by assigning the computations in the software to occur in specific clock cycles in hardware. With the user-provided target clock period constraint (e.g. 10 ns), scheduling will assign operations into clock cycles such that the operations in each cycle does not exceed the target clock period, in order to meet the user constraint. In addition, the scheduling step will ensure that the data-dependencies between the operations are met.</li>
<li>Binding: While a software program may contain an arbitrary number of operations of a given type (e.g. multiplications), the hardware may contain only a limited number of units capable of performing such a computation.  The binding step of HLS is to associate (bind) each computation in the software with a specific unit in the hardware.</li>
<li>RTL generation: Using the analysis from the previous steps, the final step of HLS is to generate a description of the circuit in a hardware description language (Verilog).</li>
</ul>
<p>Executing computations in hardware brings speed and energy advantages over performing the same computations in software running on a processor.  The underlying reason for this is that the hardware is dedicated to the computational work being performed, whereas a processor is generic and has the inherent overheads of fetching/decoding instructions, loading/storing from/to memory, etc.  Further acceleration is possible by exploiting hardware parallelism, where computations can concurrently.  With SmartHLS, one can exploit four styles of hardware parallelism, which are instruction-level, loop-level, thread-level, and function-level parallelism.</p>
<div class="section" id="instruction-level-parallelism">
<h3>Instruction-level Parallelism<a class="headerlink" href="#instruction-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>Instruction-level parallelism refers to the ability to concurrently execute computations for instructions concurrently by analyzing data dependencies.  Computations that do not depend on each other can be executed at the same time.  Consider the following code snippet which performs three addition operations.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">z</span> <span class="o">=</span> a + b<span class="p">;</span>
<span class="nv">x</span> <span class="o">=</span> c + d<span class="p">;</span>
<span class="nv">q</span> <span class="o">=</span> z + x<span class="p">;</span>
...
</pre></div>
</div>
<p>Observe that the first and second additions do not depend on one another.  These additions can therefore be executed concurrently, as long as there are two adder units available in the hardware.  SmartHLS automatically analyzes the dependencies between computations in the software to exploit instruction-level parallelism in the generated hardware. The user does not need to do anything. In the above example, the third addition operation depends on the results of the first two, and hence, its execution cannot be done in parallel with the others. Instruction-level parallelism is referred to as fine-grained parallelism, as concurrency is achieved at a fine-grained level (instruction-level) of granularity.</p>
</div>
<div class="section" id="loop-level-parallelism">
<h3>Loop-level Parallelism<a class="headerlink" href="#loop-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>In software, the majority of runtime can be spent on loops, where loop iterations execute sequentially.  That is, loop iteration <em>i</em> needs to finish before iteration <em>i + 1</em> can start. With SmartHLS, it is possible to overlap the execution of a loop iteration with another iterations using a technique called <em>loop pipelining</em> (see <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>). Now, imagine a loop with <em>N</em> iterations, where each iteration takes 100 clock cycles to complete.  In software, this loop would take <em>100N</em> clock cycles to execute. With loop pipelining in hardware, the idea is to execute a portion of a loop iteration <em>i</em> and then commence executing iteration <em>i + 1</em> even before iteration <em>i</em> is complete. If loop pipelining can commence a new loop iteration <em>every</em> clock cycles, then the total number of clock cycles required to execute the entire loop be <em>N + (N-1)</em> cycles – a significant reduction relative to <em>100N</em>. The (N-1) cycles is because each successive loop iteration start 1 cycle after the previous iteration, hence the last loop starts after (N-1) cycles.</p>
<p>A user can specify a loop to be pipelined with the use of the loop pipeline pragma. By default, a loop is not pipelined automatically.</p>
</div>
<div class="section" id="thread-level-parallelism">
<h3>Thread-level Parallelism<a class="headerlink" href="#thread-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>Modern CPUs have multiple cores that can be used to concurrently execute multiple threads in software. Threads are widely used in C/C++, where, parallelism is realized at the granularity of entire C/C++ functions.  Hence thread-level parallelism is referred to as coarse-grained parallelism since one or more functions execute in parallel.  SmartHLS supports hardware synthesis of <code class="docutils literal notranslate"><span class="pre">hls::threads</span></code>, where concurrently executing threads in software are synthesized into concurrently executing hardware units (see <a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading with SmartHLS Threads</span></a>).  This allows a software developer to take advantage of spatial parallelism in hardware using a familiar parallel programming paradigm in software.  Moreover, the parallel execution behaviour of threads can be debugged in software, it is considerably easier than debugging in hardware.</p>
<p>In a multi-threaded software program, synchronization between the threads can be important, with the most commonly used synchronization constructs being mutexes and barriers. SmartHLS supports the synthesis of mutexes and barriers into hardware.</p>
</div>
<div class="section" id="data-flow-streaming-parallelism">
<h3>Data Flow (Streaming) Parallelism<a class="headerlink" href="#data-flow-streaming-parallelism" title="Permalink to this headline">¶</a></h3>
<p>The second style of coarse-grained parallelism is referred to as <em>data flow</em> parallelism.  This form of parallelism arises frequently in <em>streaming</em> applications, and are commonly used for video/audio processing, machine learning, and computational finance.  In such applications, there is a stream of input data that is fed into the application at regular intervals.  For example, in an audio processing application, a digital audio sample may be given to the circuit every clock cycle.  In streaming applications, a succession of computational tasks is executed on the stream of input data, producing a stream of output data.  For example, the first task may be to filter the input audio to remove high-frequency components.  Subsequently, a second task may receive the filtered audio, and boost the bass low-frequency components.  Observe that, in such a scenario, the two tasks may be overlapped with one another.  Input samples are continuously received by the first task and given to the second task.</p>
<p>SmartHLS provides a way for a developer to specify data flow parallelism through the use of function pipelining (see <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a>) and/or threads (see <a class="reference internal" href="#data-flow-parallelism-with-pthreads"><span class="std std-ref">Data Flow Parallelism with SmartHLS Threads</span></a>) with SmartHLS’s FIFO library (see <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a>) used to connect the streaming modules.</p>
</div>
</div>
<div class="section" id="smarthls-overview">
<h2>SmartHLS Overview<a class="headerlink" href="#smarthls-overview" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS accepts a C/C++ software program as input and automatically generates hardware described in Verilog HDL (hardware description language) that can be programmed onto a Microchip FPGA.
The generated hardware can be imported as an HDL+ component into SmartDesign with a Tcl script that is also generated by SmartHLS. SmartHLS also generates a C++ accelerator driver API that can
be used to control the generated hardware from an embedded processor. Optionally, SmartHLS can combine user code with the accelerator driver API and cross-compile it into a binary that can run
on a RISC-V processor in an SoC design.</p>
<img alt="_images/smarthls_flow_soc.png" class="align-center" src="_images/smarthls_flow_soc.png" />
<p>In a software program, user first needs to specify a top-level function (during project creation in the SmartHLS IDE or in the source code with our pragma, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code> ). Please refer to the <a class="reference internal" href="#custom-top-level"><span class="std std-ref">Specifying the Top-level Function</span></a> section for more details specifying the top-level function.</p>
<p>Then the following button, <code class="docutils literal notranslate"><span class="pre">Compile</span> <span class="pre">Software</span> <span class="pre">to</span> <span class="pre">Hardware</span></code> can be clicked to compile software to hardware:</p>
<img alt="_images/icon_hardware_flow.png" class="align-center" src="_images/icon_hardware_flow.png" />
<p>This will compile the top-level function and all of its descendant functions into hardware.
The rest of the program (outside the top-level function) is considered as the software testbench, to give inputs into the top-level function and verify outputs from the top-level function (and its descendants).
The software testbench is used to automatically generate the RTL testbench and stimulus for <a class="reference internal" href="#sw-hw-co-simulation">SW/HW Co-Simulation</a>.</p>
<p>Alongside the generated hardware, the <code class="docutils literal notranslate"><span class="pre">Compile</span> <span class="pre">Software</span> <span class="pre">to</span> <span class="pre">Hardware</span></code> button will also generate <a class="reference internal" href="#accelerator-driver"><span class="std std-ref">C++ driver functions</span></a>, which can be combined with the software testbench and to produce code that can run
on the processor in an SoC system and control the generated hardware. There are also optional SoC-related features offered by SmartHLS, such as generation of a reference SoC and automatic combination and cross-compilation of
the software testbench and accelerator drivers for that reference SoC.</p>
</div>
<div class="section" id="smarthls-soc-flow-1">
<span id="smarthls-soc-flow"></span><h2>SmartHLS SoC Flow<a class="headerlink" href="#smarthls-soc-flow-1" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS can automatically generate a RISC-V processor/accelerator SoC for the PolarFire<sup>®</sup> SoC device on the Icicle Kit. For more information on the SoC features, see <a class="reference internal" href="#soc-features"><span class="std std-ref">SoC Features</span></a>.</p>
</div>
<div class="section" id="smarthls-pragmas-1">
<span id="smarthls-pragmas"></span><h2>SmartHLS Pragmas<a class="headerlink" href="#smarthls-pragmas-1" title="Permalink to this headline">¶</a></h2>
<p>Pragmas can be applied to the software code by the user to apply HLS optimization techniques and/or guide the compiler for hardware generation.
They are applied directly on the applicable software construct (i.e., function, loop, argument, array) to specify a certain optimization for them. For example, to apply pipelining on a loop:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For more details on the supported pragmas, please refer to <a class="reference internal" href="pragmas.html#pragmas"><span class="std std-ref">SmartHLS Pragmas Manual</span></a>.
For more details on loop pipelining, please refer to <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>.</p>
</div>
<div class="section" id="smarthls-constraints-1">
<span id="smarthls-constraints"></span><h2>SmartHLS Constraints<a class="headerlink" href="#smarthls-constraints-1" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS also supports user constraints to guide hardware generation.
Whereas pragmas are applied directly on the source code for optimizations that are specific and local to the software construct that it is being applied on (function, loop, memory, argument, etc),
constraints are used for settings that will be globally applied to the entire program (i.e., setting the target FPGA, target clock period).
Each project specifies its constraints in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file in the project directory.
This file is automatically generated by the SmartHLS IDE. To modify the constraints, click the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">Constraints</span></code> button:</p>
<img alt="_images/icon_constraints.png" class="align-center" src="_images/icon_constraints.png" />
<p>The following window will open:</p>
<a class="reference internal image-reference" href="_images/empty_constraint_setting_window.png"><img alt="_images/empty_constraint_setting_window.png" class="align-center" src="_images/empty_constraint_setting_window.png" style="width: 589.5px; height: 369.75px;" /></a>
<p>You can add, edit, or remove constraints from this window.
Select a constraint type from the first drop-down menu. If you want more information about
a constraint, click the Help button, which will open the corresponding <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a> page.</p>
<p>An important constraint is the target clock period (shown as <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">target</span> <span class="pre">clock</span> <span class="pre">period</span></code> in the drop-down menu).
With this constraint, SmartHLS schedules the operations of a program to meet the specified clock period.
When this constraint is not given, SmartHLS uses the default clock period for each device, as shown below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="27%" />
<col width="33%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">FPGA Vendor</th>
<th class="head">Device</th>
<th class="head">Default Clock Frequency (MHz)</th>
<th class="head">Default Clock Period (ns)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Microchip</td>
<td>PolarFire</td>
<td>100</td>
<td>10</td>
</tr>
<tr class="row-odd"><td>Microchip</td>
<td>SmartFusion2</td>
<td>100</td>
<td>10</td>
</tr>
</tbody>
</table>
<p>Details of all SmartHLS constraints are given in the <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a>.</p>
</div>
<div class="section" id="specifying-the-top-level-function">
<span id="custom-top-level"></span><h2>Specifying the Top-level Function<a class="headerlink" href="#specifying-the-top-level-function" title="Permalink to this headline">¶</a></h2>
<p>When compiling software to hardware with SmartHLS, you must specify the top-level function for your program.
Then SmartHLS will compile the specified top-level function and all of its descendant functions to hardware.
The remainder of the program (i.e., parent functions of the top-level function, typically the <code class="docutils literal notranslate"><span class="pre">main</span></code> function)
becomes a software testbench that is used for <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.
The top-level function is specified with the pragma, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code>, directly on the source code, below the function prototype, as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">hw_top</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="cp">#pragma HLS function top</span>
   <span class="p">...</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="sw-hw-co-simulation">
<span id="sw-hw-cosimulation"></span><h2>SW/HW Co-Simulation<a class="headerlink" href="#sw-hw-co-simulation" title="Permalink to this headline">¶</a></h2>
<p>The circuit generated by SmartHLS should be functionally equivalent to the input software.
Users should not modify the generated Verilog, as it is overwritten every time SmartHLS runs.</p>
<p>SW/HW co-simulation can be used to verify that the generated hardware produces the same outputs for the same inputs as software.
With SW/HW co-simulation, user does not have to write their own RTL testbench, as it is automatically generated.
If user already has their own custom RTL testbench, one can optionally choose their custom RTL testbench (<a class="reference internal" href="#custom-testbench"><span class="std std-ref">Specifying a Custom Test Bench</span></a>) and not use SW/HW co-simulation.</p>
<p>To use SW/HW co-simulation, the input software program will be composed of two parts,</p>
<ul class="simple">
<li>A top-level function (and its descendant functions) to be synthesized to hardware by SmartHLS,</li>
<li>A C/C++ testbench (the parent functions of the top-level function, typically <code class="docutils literal notranslate"><span class="pre">main()</span></code>) that invokes the top-level function with test inputs and verifies outputs.</li>
</ul>
<p>SW/HW co-simulation consists of the following automated steps:</p>
<ol class="arabic simple">
<li>SmartHLS runs your software program and saves all the inputs passed to the top-level function.</li>
<li>SmartHLS automatically creates an RTL testbench that reads in the inputs from step 1 and passes them into the SmartHLS-generated hardware module.</li>
<li>ModelSim simulates the testbench and saves the SmartHLS-generated module outputs.</li>
<li>SmartHLS runs your software program again, but uses the simulation outputs as the output of your top-level function.</li>
</ol>
<p>You should write your C/C++ testbench such that the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function returns a 0 when all outputs from the top-level function are as expected and otherwise return a non-zero value up to 255. We use this return value to determine whether the SW/HW co-simulation has passed.</p>
<p>In step 1, we verify that the program returns 0.</p>
<p>In step 4, we run the program using the outputs from simulation and if the SmartHLS-generated circuit matches the C program then <code class="docutils literal notranslate"><span class="pre">main()</span></code> should still return 0.</p>
<p>If the C/C++ program matches the RTL simulation then you should see: <code class="docutils literal notranslate"><span class="pre">SW/HW</span> <span class="pre">co-simulation:</span> <span class="pre">PASS</span></code></p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The return value of the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function must be within the range of 0 to 255. If the return value is greater than 255, only the lower 8 bits will be used as the return code. For example, a return value of 257 or 1025 will be considered as failed since their lower 8 bits equal to 1, but values such as 256, 512 and 1024 will be considered as passed since their lower 8 bits equal to 0.</p>
</div>
<p>For any values that are shared between software testbench and hardware functions (top-level and descendants), you can either pass in as arguments into the top-level function, or if it is a global variable, it can be directly accessed without being passed in as an argument.
Any variables that are accessed by both software testbench and hardware functions will create an interface at the top-level module.
For example, if there is an array that is initialized in the software testbench and is used as an input to the hardware function, you may pass the array as an argument into the top-level function, which will create a memory interface for the array in the hardware core generated by SmartHLS.
Arguments into the top-level function can be constants, pointers, arrays, and FIFO data types.
The top-level function can also have a return value.
Please refer to the included example in the SmartHLS IDE, <code class="docutils literal notranslate"><span class="pre">C++</span> <span class="pre">Canny</span> <span class="pre">Edge</span> <span class="pre">Detection</span> <span class="pre">(SW/HW</span> <span class="pre">Co-Simulation)</span></code>, as a reference.</p>
<p>If a top-level argument is coming from a dynamically allocated array (e.g., malloc), the size of the array (in bytes) must be specified with our <code class="docutils literal notranslate"><span class="pre">interface</span></code> pragma (e.g., <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">interface</span> <span class="pre">argument(&lt;arg_name&gt;)</span> <span class="pre">depth(&lt;int&gt;)</span></code>).
Please see the <a class="reference internal" href="pragmas.html#pragma-interface-memory"><span class="std std-ref">Memory Interface for Pointer Argument/Global Variable</span></a> for more details. The sizes of arrays that are statically allocated do not need to be specified with the pragma, as SmartHLS will automatically determine them.</p>
<p>For debugging purposes, SmartHLS converts any C <code class="docutils literal notranslate"><span class="pre">printf</span></code>
statements into Verilog <code class="docutils literal notranslate"><span class="pre">$write</span></code> statements so that values printed during
software execution will also be printed during hardware simulation. This
allows easy verification of the correctness of the hardware circuit.  Verilog
<code class="docutils literal notranslate"><span class="pre">$write</span></code> statements are unsynthesizable and will not affect the final FPGA
hardware.</p>
<p>To specify the arguments to be passed to the software testbench (i.e., <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">main(int</span> <span class="pre">argc,</span> <span class="pre">char</span> <span class="pre">*argv[])</span></code>), a Makefile argument <code class="docutils literal notranslate"><span class="pre">PROGRAM_ARGUMENTS</span></code> can be defined in a <code class="docutils literal notranslate"><span class="pre">makefile.user</span></code> file (you need to create the file in the SmartHLS project folder).
For example, if a software testbench takes in two arguments, an input BMP file and a golden output BMP file, you would specify the following in the <code class="docutils literal notranslate"><span class="pre">makefile.user</span></code> file,</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">PROGRAM_ARGUMENTS</span> <span class="o">=</span> <span class="n">input_file</span><span class="p">.</span><span class="n">bmp</span> <span class="n">golden_output_file</span><span class="p">.</span><span class="n">bmp</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Co-simulating multiple top-level modules:</p>
<ul class="last simple">
<li>Co-simulation supports verifying multiple top-level modules simultaneously. Each top-level module is verified solely based on the corresponding top-level function’s input and expected output gathered from the software testbench. However the Co-simulation testbench will simulate all top-level modules simultaneously with the same clock.</li>
<li>If the user wants to verify a single top-level module, the <code class="docutils literal notranslate"><span class="pre">top</span></code> pragma should be only added for the desired function in the source code.</li>
</ul>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Limitations:</p>
<ul class="last simple">
<li>When function pipelining is used, the top-level function cannot have array
interfaces (array arguments or global arrays that are accessed from both SW
testbench and HW functions).</li>
<li>When multi-threading is used (<a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading with SmartHLS Threads</span></a>), Co-Simulation
can only support the case when all threads are joined in the functions where
the threads are forked.  Free-running threads (that are continuously running
and never joined) are not supported by SW/HW Co-Simulation.</li>
</ul>
</div>
</div>
<div class="section" id="loop-pipelining-1">
<span id="loop-pipelining"></span><h2>Loop Pipelining<a class="headerlink" href="#loop-pipelining-1" title="Permalink to this headline">¶</a></h2>
<p>Loop pipelining is an optimization that can automatically extract
loop-level parallelism to create an efficient hardware pipeline.
It allows executing multiple loop iterations concurrently on the same pipelined hardware.</p>
<p>To use loop pipelining, the user needs to specify the loop pipeline pragma above the applicable loop:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An important concept in loop pipelining is the <em>initiation interval (II)</em>, which is
the cycle interval between starting successive iterations of the loop.
The best performance and hardware utilization is achieved when II=1, which means
that successive iterations of the loop can begin every clock cycle.
A pipelined loop with an II=2 means that successive iterations of the loop
can begin every two clock cycles, corresponding to half of the throughput of an II=1 loop.</p>
<p>By default, SmartHLS always attempts to create a pipeline with an II=1.
However, this is not possible in some cases due to resource constraints or
cross-iteration dependencies. Please refer to <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> on more examples and details on loop pipelining.
When II=1 cannot be met, SmartHLS’s pipeline scheduling algorithm will try to find the smallest possible II
that satisfies the constraints and dependencies.</p>
</div>
<div class="section" id="function-pipelining-1">
<span id="function-pipelining"></span><h2>Function Pipelining<a class="headerlink" href="#function-pipelining-1" title="Permalink to this headline">¶</a></h2>
<p>Loop pipelining is one way to exploit pipeline parallelism in a circuit.
An alternative way is to use <code class="docutils literal notranslate"><span class="pre">Function</span> <span class="pre">Pipelining</span></code>.
When a function is marked to be pipelined (by using the <a class="reference internal" href="pragmas.html#pragma-function-pipeline"><span class="std std-ref">Pipeline Function</span></a> pragma), SmartHLS will implement the function as a pipelined circuit that can start a new invocation every <code class="docutils literal notranslate"><span class="pre">II</span></code> cycles.
That is, the circuit can execute again while its previous invocation is still executing, allowing it to continuously process incoming data in a pipelined fashion.
Typically a pipelined function is called together with other pipelined functions, and these are called from within a parent “dataflow function”, specified via the <a class="reference internal" href="pragmas.html#pragma-dataflow"><span class="std std-ref">Dataflow</span></a> pragma described below.</p>
</div>
<div class="section" id="data-flow-parallelism">
<span id="dataflow-parallelism"></span><h2>Data Flow Parallelism<a class="headerlink" href="#data-flow-parallelism" title="Permalink to this headline">¶</a></h2>
<p>Data Flow or “dataflow” parallelism is another commonly used technique to improve hardware throughput. In dataflow parallelism, a succession of computational tasks which process continuous streams of data can execute in parallel.
These tasks are called dataflow sub-functions.
A function is declared as a dataflow function using the pragma <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">dataflow</span></code> (see <a class="reference internal" href="pragmas.html#pragma-dataflow"><span class="std std-ref">Dataflow</span></a>).
Within this dataflow function, the called functions, or sub-functions, will execute with dataflow parallelism.
If the dataflow function contains loops or control-flow, each top-level loop nest or control-flow region will be extracted into a new sub-function.</p>
<p>In a dataflow circuit, synchronization will be required for passing intermediate data between the sub-functions that can run in parallel.
For instance, a producer sub-function can write to an array for another consumer sub-function to read. In this case, the consumer sub-function needs to “know” that the producer has finished writing the array in order to start.
SmartHLS can convert such intermediate data into double/shared buffer or FIFOs.
By default, intermediate data is converted into double buffer. This can be configured via the <a class="reference internal" href="pragmas.html#pragma-dataflow-channel"><span class="std std-ref">Dataflow Channel</span></a> pragma.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Dataflow functions and sub-functions have the following restrictions or properties:</p>
<ol class="last arabic simple">
<li>The dataflow function and all its sub-functions must have <code class="docutils literal notranslate"><span class="pre">void</span></code> return type, with output data passed by pointer or by reference.</li>
<li>Nested dataflow functions must have the parent dataflow function directly calling the child dataflow function.
That is, it is supported for a dataflow function to call another dataflow function;
however it is not allowed to have a dataflow function, calling a non-dataflow function, which further calls a dataflow function.</li>
<li>Sub-functions cannot contain SmartHLS Threads (to use SmartHLS Threads, see <a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading with SmartHLS Threads</span></a>).</li>
<li>When a dataflow function is called from within a loop, the loop body can only contain that call in order for SmartHLS to overlap the invocations of the dataflow function;
otherwise the dataflow function will still run in a non-overlapped manner.</li>
<li>Data external to the dataflow function (declared outside of the dataflow function and its sub-functions) can only be accessed by 1 sub-function, unless the data is of FIFO type.</li>
<li>All intermediate data should have exactly one producer and one consumer sub-function.</li>
<li>When configuring an intermediate data variable (i.e., an array or single-element memory) to be implemented as a FIFO channel using the <a class="reference internal" href="pragmas.html#pragma-dataflow-channel"><span class="std std-ref">Dataflow Channel</span></a> pragma, it is only correct to use the <code class="docutils literal notranslate"><span class="pre">fifo</span></code> type when:
1) the producer function only writes to the variable in a sequential manner,
and 2) the consumer function only reads from the variable in a sequential manner.</li>
<li>If a sub-function calls another synthesizable sub-sub-function, the sub-sub-function will be automatically inlined by SmartHLS.</li>
<li>If a sub-function is called in more than one location inside a dataflow function, the sub-function will be automatically replicated by SmartHLS.</li>
</ol>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a dataflow function contains conditionally executed tasks, the generated circuit may mismatch with the software and may need to be free-running on hardware for the circuit to work properly.
To make the generated circuit free-running, tie the start signal to 1.
For CoSimulation, see <a class="reference internal" href="constraintsmanual.html#cosim-free-running-dataflow-top"><span class="std std-ref">COSIM_FREE_RUNNING_DATAFLOW_TOP</span></a> for how to keep the start signal at 1 during simulation.</p>
</div>
<p>Dataflow parallelism can be used to overlap sub-functions which run in sequence, or to run independent sub-functions in parallel.</p>
<div class="section" id="dataflow-example-canny-with-fifos">
<h3>Dataflow Example: Canny with FIFOs<a class="headerlink" href="#dataflow-example-canny-with-fifos" title="Permalink to this headline">¶</a></h3>
<p>To see this complete code example, please refer to the <cite>C++ Canny Edge Detection (SW/HW Co-Simulation)</cite> example
included in the SmartHLS IDE.</p>
<p>An example of overlapping sequential sub-functions is an image processing pipeline, such as Canny edge detection.
Canny edge detection runs 4 image processing algorithms sequentially.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">canny</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">input_frame</span><span class="p">,</span>
           <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">output_frame</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function dataflow</span>

<span class="cp">#pragma HLS dataflow_channel variable(output_gf) type(double_buffer)</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output_gf</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>
<span class="cp">#pragma HLS dataflow_channel variable(output_sf) type(double_buffer)</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">output_sf</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>
<span class="cp">#pragma HLS dataflow_channel variable(output_nm) type(double_buffer)</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output_nm</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>

    <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">input_frame</span><span class="p">,</span> <span class="n">output_gf</span><span class="p">);</span>
    <span class="n">sobel_filter</span><span class="p">(</span><span class="n">output_gf</span><span class="p">,</span> <span class="n">output_sf</span><span class="p">);</span>
    <span class="n">nonmaximum_suppression</span><span class="p">(</span><span class="n">output_sf</span><span class="p">,</span> <span class="n">output_nm</span><span class="p">);</span>
    <span class="n">hysteresis_filter</span><span class="p">(</span><span class="n">output_nm</span><span class="p">,</span> <span class="n">output_frame</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These can overlap using dataflow parallelism to operate as a single pipeline.
Each time the <code class="docutils literal notranslate"><span class="pre">canny</span></code> function is called, one new piece of data will enter the pipeline.
In the example above, the granularity of data is an entire image, of size HEIGHT * WIDTH pixels.
After the fourth call, the pipeline will be in steady-state, and all 4 sub-functions will be executing in parallel on 4 separate images.
The intermediate data arrays are double-buffered as specified by the <a class="reference internal" href="pragmas.html#pragma-dataflow-channel"><span class="std std-ref">Dataflow Channel</span></a> pragma.</p>
<a class="reference internal image-reference" href="_images/dataflow_canny_pipeline.png"><img alt="_images/dataflow_canny_pipeline.png" class="align-center" src="_images/dataflow_canny_pipeline.png" style="width: 928.25px; height: 418.75px;" /></a>
<p>Because the Canny pipeline processes the image data in sequential order, however, the granularity of data
entering the pipeline each function call does not need to be an entire image. Instead, it can be a single
pixel. The intermediate channels could then be FIFOs.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">canny_fifo</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span>
                <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function dataflow</span>

<span class="cp">#pragma HLS dataflow_channel variable(output_gf) type(fifo)</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output_gf</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>
<span class="cp">#pragma HLS dataflow_channel variable(output_sf) type(fifo)</span>
    <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">output_sf</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>
<span class="cp">#pragma HLS dataflow_channel variable(output_nm) type(fifo)</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">output_nm</span> <span class="p">[</span><span class="n">HEIGHT</span> <span class="o">*</span> <span class="n">WIDTH</span><span class="p">];</span>

    <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">input_fifo</span><span class="p">,</span> <span class="n">output_gf</span><span class="p">);</span>
    <span class="n">sobel_filter</span><span class="p">(</span><span class="n">output_gf</span><span class="p">,</span> <span class="n">output_sf</span><span class="p">);</span>
    <span class="n">nonmaximum_suppression</span><span class="p">(</span><span class="n">output_sf</span><span class="p">,</span> <span class="n">output_nm</span><span class="p">);</span>
    <span class="n">hysteresis_filter</span><span class="p">(</span><span class="n">output_nm</span><span class="p">,</span> <span class="n">output_fifo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this case, the FIFO only needs to be as deep as 2 elements to accommodate the dataflow.
By using FIFO rather than double/shared buffer, we can significantly save resource usage as well as achieve better performance by allowing the pipeline to be in steady state faster.</p>
<a class="reference internal image-reference" href="_images/dataflow_canny_pipeline_fifo.png"><img alt="_images/dataflow_canny_pipeline_fifo.png" class="align-center" src="_images/dataflow_canny_pipeline_fifo.png" style="width: 1124.1px; height: 502.5px;" /></a>
<p>Another way to implement these as fifo channels would be to use the
hls::FIFO library. This final version is included as a complete code example.
Please refer to the <cite>C++ Canny Edge Detection (SW/HW Co-Simulation)</cite> example in the SmartHLS IDE.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">canny_fifo</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span>
                <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS function dataflow</span>

    <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">output_fifo_gf</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="o">&gt;</span> <span class="n">output_fifo_sf</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">output_fifo_nm</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>

    <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">input_fifo</span><span class="p">,</span> <span class="n">output_fifo_gf</span><span class="p">);</span>
    <span class="n">sobel_filter</span><span class="p">(</span><span class="n">output_fifo_gf</span><span class="p">,</span> <span class="n">output_fifo_sf</span><span class="p">);</span>
    <span class="n">nonmaximum_suppression</span><span class="p">(</span><span class="n">output_fifo_sf</span><span class="p">,</span> <span class="n">output_fifo_nm</span><span class="p">);</span>
    <span class="n">hysteresis_filter</span><span class="p">(</span><span class="n">output_fifo_nm</span><span class="p">,</span> <span class="n">output_fifo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The top-level function has been specified with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code>. The top-level function calls the four sub-functions, <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code>, <code class="docutils literal notranslate"><span class="pre">sobel_filter</span></code>, <code class="docutils literal notranslate"><span class="pre">nonmaximum_suppression</span></code>, and <code class="docutils literal notranslate"><span class="pre">hysteresis_filter</span></code>, each of which are specified to be function pipelined with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">pipeline</span></code>.
The top-level arguments are <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code>. The <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> is given as an argument into the first sub-function, <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code>, and gives the inputs into the overall circuit.
The <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code> is given as an argument into the last sub-function, <code class="docutils literal notranslate"><span class="pre">hysteresis_filter</span></code>, and receives the outputs of the overall circuit.
There are also intermediate FIFOs, <code class="docutils literal notranslate"><span class="pre">output_fifo_gf</span></code>, <code class="docutils literal notranslate"><span class="pre">output_fifo_sf</span></code>, and <code class="docutils literal notranslate"><span class="pre">output_fifo_nm</span></code>, which are given as arguments into the sub-function and thus connect them (i.e., outputs of <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code> is given as inputs to <code class="docutils literal notranslate"><span class="pre">sobel_filter</span></code>).</p>
<p>When synthesizing a function with multiple pipelined sub-functions, specifying
<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">dataflow</span></code> causes SmartHLS to parallelize the execution of all
sub-functions, forming a streaming circuit with dataflow parallelism.
In this case <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code> executes as soon as there is data in the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>, and <code class="docutils literal notranslate"><span class="pre">sobel_filter</span></code> starts running as soon as there is data in the <code class="docutils literal notranslate"><span class="pre">output_fifo_sf</span></code>.
In other words, a sub-function does not wait for its previous sub-function to completely finish running before it starts to execute, but rather, it starts running as early as possible.
Each sub-function also starts working on the next data while the previous data is being processed (in a pipelined fashion).
If the initiation interval (II) is 1, a sub-function starts processing new data every clock cycle.
Once the sub-functions reach steady-state, all sub-functions execute concurrently.
This example showcases the synthesis of a streaming circuit that consists of a succession of concurrently executing dataflow sub-functions.</p>
</div>
<div class="section" id="dataflow-example-diamond">
<h3>Dataflow Example: Diamond<a class="headerlink" href="#dataflow-example-diamond" title="Permalink to this headline">¶</a></h3>
<p>Next, consider an example in which there are sub-functions without dependencies.</p>
<a class="reference internal image-reference" href="_images/dataflow_diamond.png"><img alt="_images/dataflow_diamond.png" class="align-center" src="_images/dataflow_diamond.png" style="width: 582.3px; height: 291.9px;" /></a>
<p>The sub-functions B and C can execute in parallel, starting when A is finished.
Once both B and C are finished, D will begin.
An implementation of the dataflow function is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">diamond</span><span class="p">(</span><span class="kt">int</span> <span class="n">in1</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="kt">int</span> <span class="n">in2</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="mi">128</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS function dataflow</span>

<span class="cp">#pragma HLS dataflow_channel variable(tmp1_0) type(double_buffer)</span>
<span class="cp">#pragma HLS dataflow_channel variable(tmp2_0) type(double_buffer)</span>
<span class="cp">#pragma HLS dataflow_channel variable(tmp1_1) type(double_buffer)</span>
<span class="cp">#pragma HLS dataflow_channel variable(tmp2_1) type(double_buffer)</span>

    <span class="kt">int</span> <span class="n">tmp1_0</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="n">tmp2_0</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="n">tmp1_1</span><span class="p">[</span><span class="mi">128</span><span class="p">],</span> <span class="n">tmp2_1</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>
    <span class="n">subfunction_A</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">tmp1_0</span><span class="p">,</span> <span class="n">tmp2_0</span><span class="p">);</span>
    <span class="n">subfunction_B</span><span class="p">(</span><span class="n">tmp1_0</span><span class="p">,</span> <span class="n">tmp1_1</span><span class="p">);</span>
    <span class="n">subfunction_C</span><span class="p">(</span><span class="n">tmp2_0</span><span class="p">,</span> <span class="n">tmp2_1</span><span class="p">);</span>
    <span class="n">subfunction_D</span><span class="p">(</span><span class="n">tmp1_1</span><span class="p">,</span> <span class="n">tmp2_1</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="multi-threading-with-smarthls-threads">
<span id="pthreads-multithreading"></span><h2>Multi-threading with SmartHLS Threads<a class="headerlink" href="#multi-threading-with-smarthls-threads" title="Permalink to this headline">¶</a></h2>
<p>In an FPGA hardware system, the same module can be instantiated multiple times to exploit spatial parallelism, where all module instances execute in parallel to achieve higher throughput.
SmartHLS allows easily inferring such parallelism with the use of SmartHLS Threads which is a simplified API of <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> commonly used in software.
Parallelism described in software with SmartHLS threads is automatically compiled to parallel hardware with SmartHLS.
Each thread in software becomes an independent module that concurrently executes in hardware.</p>
<p>For example, the code snippet below creates <code class="docutils literal notranslate"><span class="pre">N</span></code> threads running the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> function in software.
SmartHLS will correspondingly create <code class="docutils literal notranslate"><span class="pre">N</span></code> hardware instances all implementing the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> function, and parallelize their executions.
SmartHLS also supports mutex and barrier APIs so that synchronization between threads can be specified using locks and barriers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">thread</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SmartHLS supports <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> APIs, which are listed below in
<a class="reference internal" href="#supported-parallel-apis"><span class="std std-ref">Supported SmartHLS Thread APIs</span></a>.</p>
<p>Note that for a <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> kernel, SmartHLS will automatically inline any of its descendant functions.
The inlining cannot be overridden with the <code class="docutils literal notranslate"><span class="pre">noinline</span></code> pragma (see <a class="reference internal" href="pragmas.html#pragmas"><span class="std std-ref">SmartHLS Pragmas Manual</span></a>).</p>
</div>
<div class="section" id="supported-smarthls-thread-apis">
<span id="supported-parallel-apis"></span><h2>Supported SmartHLS Thread APIs<a class="headerlink" href="#supported-smarthls-thread-apis" title="Permalink to this headline">¶</a></h2>
<p>You can use SmartHLS thread library by including the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/thread.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The thread library is provided as a C++ template class.
The template argument of <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;T&gt;</span></code> object specifies the return type <code class="docutils literal notranslate"><span class="pre">T</span></code> of the threaded function.
For example, <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;int&gt;</span></code> is a thread that can invoke a function with <code class="docutils literal notranslate"><span class="pre">int</span></code> return type,
and <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;void&gt;</span></code> is a thread that can invoke a function that returns <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>To start the parallel execution of a function, we will pass the function and
function call arguments to the constructor of a new thread instance,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// f1 is a function that we would like to execute concurrently.</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="c1">// Create a new thread &#39;t1&#39; with the function &#39;f1&#39; and argument &#39;m&#39;.</span>
<span class="c1">// - &lt;void&gt; corresponds to the return type of &#39;f1&#39;.</span>
<span class="c1">// - Argument &#39;m&#39; corresponds to the parameter &#39;a&#39; of &#39;f1&#39;.</span>
<span class="c1">// - In software, this line creates a parallel thread to run the f1 function.</span>
<span class="c1">// - In hardware, this line means a dedicated hardware module for f1 should</span>
<span class="c1">// be created for this specific thread call, and the dedicated hardware</span>
<span class="c1">// module will start the execution right here.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>


<span class="c1">// Another way to create a parallel thread:</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">();</span>                     <span class="c1">// f2 has no argument and the return type is &lt;int&gt;.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>        <span class="c1">// Create a thread &#39;t2&#39; instance first.</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>  <span class="c1">// Assign &#39;t2&#39; later with the function and arguments.</span>
</pre></div>
</div>
<p>The code below shows how to join a thread (i.e., wait for the thread
completion), and optionally retrieve a non-void return value.
Note that joining a thread will block the execution until the threaded function finishes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// The program will block here until thread &#39;t1&#39; finishes running &#39;f1&#39;.</span>

<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// The program will wait for t2 to finish and retrieve the return value.</span>
</pre></div>
</div>
<p>If you have used <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>, you may know passing an argument by reference requires a <code class="docutils literal notranslate"><span class="pre">std::ref</span></code> wrapper around the argument.
Similarly, <code class="docutils literal notranslate"><span class="pre">hls::ref</span></code> is used to wrap the passed-in by reference argument when the <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> is created:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>SmartHLS threads differs from <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> in a few aspects:</p>
<ul class="last simple">
<li>SmartHLS threads support retrieving the return value from the threaded function (this functionality is only supported using <code class="docutils literal notranslate"><span class="pre">std::future</span></code> in the standard threading library).</li>
<li>SmartHLS threads use templates to specify the return type of the threaded function.</li>
<li>SmartHLS threads are auto-detaching, which means if the function where the thread is created is exited without using <code class="docutils literal notranslate"><span class="pre">join</span></code>, the thread will be detached when destructed.
But the threaded function can continue executing.</li>
</ul>
</div>
<p>SmartHLS thread library also supports <code class="docutils literal notranslate"><span class="pre">mutex</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier</span></code> as synchronization primitives.</p>
<p><code class="docutils literal notranslate"><span class="pre">mutex</span></code> can be used to protect shared data from being simultaneously accessed by multiple threads.
<code class="docutils literal notranslate"><span class="pre">hls::mutex</span></code> has <code class="docutils literal notranslate"><span class="pre">lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> methods.</p>
<p><code class="docutils literal notranslate"><span class="pre">barrier</span></code> provides a thread-coordination mechanism that allows at most an expected number of threads to block until the expected number of threads arrive at the barrier.
<code class="docutils literal notranslate"><span class="pre">hls::barrier</span></code> has <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">wait()</span></code> methods.</p>
<p>The following example illustrates the use of <code class="docutils literal notranslate"><span class="pre">hls::mutex</span></code> and <code class="docutils literal notranslate"><span class="pre">hls::barrier</span></code>:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define ARRAY_SIZE 20</span>

<span class="cp">#include</span> <span class="cpf">&lt;hls/thread.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">volatile</span> <span class="kt">int</span> <span class="n">input</span><span class="p">[</span><span class="n">ARRAY_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span>  <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span>  <span class="mi">10</span><span class="p">,</span>
                         <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>

<span class="n">hls</span><span class="o">::</span><span class="n">mutex</span> <span class="n">mutex</span><span class="p">;</span>
<span class="n">hls</span><span class="o">::</span><span class="n">barrier</span> <span class="n">barr</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">final_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thread_no</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="c1">// Use mutex so that only 1 thread can write at any time</span>
    <span class="n">mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
    <span class="n">final_result</span> <span class="o">+=</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>

    <span class="c1">// Wait for all threads to reach this point</span>
    <span class="n">barr</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
    <span class="c1">// Print the result after all threads update final_result</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;thread %d: final_result = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">thread_no</span><span class="p">,</span> <span class="n">final_result</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="c1">// Initialize the barrier.</span>
    <span class="n">barr</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="c1">// Start the threads.</span>
    <span class="kt">int</span> <span class="n">final_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">thread1</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">final_result</span><span class="p">),</span> <span class="cm">/*thread_no*/</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">thread2</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">ref</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">final_result</span><span class="p">),</span> <span class="cm">/*thread_no*/</span> <span class="mi">2</span><span class="p">);</span>

    <span class="c1">// Join the threads.</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">thread1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">thread2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="c1">// Check result.</span>
    <span class="kt">int</span> <span class="n">result_matches</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;result[%d] = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">result_matches</span> <span class="o">+=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">210</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// Check final_result is correct</span>
    <span class="n">result_matches</span> <span class="o">+=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">final_result</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;MATCHES: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result_matches</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result_matches</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="data-flow-parallelism-with-smarthls-threads">
<span id="data-flow-parallelism-with-pthreads"></span><h2>Data Flow Parallelism with SmartHLS Threads<a class="headerlink" href="#data-flow-parallelism-with-smarthls-threads" title="Permalink to this headline">¶</a></h2>
<p>Most of the time a dataflow design can be implemented with the
<a class="reference internal" href="pragmas.html#pragma-dataflow"><span class="std std-ref">Dataflow</span></a> pragma that requires minimal code change.
However, for more complex parallelism, e.g., with feedback/cycles
between sub-functions, multi-threading APIs may be needed to
explicitly describe the parallelism between the functions.</p>
<p>The concurrent execution of computational tasks can also be accurately described in software using <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> APIs.
In addition, the continuous streams of data flowing through the tasks can be inferred using SmartHLS’s built-in FIFO data structure (see <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Also see <a class="reference internal" href="#use-data-buffer-in-multi-threaded-dataflow"><span class="std std-ref">Using DoubleBuffer and SharedBuffer in a multi-threaded dataflow design</span></a> for another example that uses data buffer instead of FIFO to pass data between threads.</p>
</div>
<p>Let’s take a look at the code snippet below, which is from the example project, “Fir Filter (Loop Pipelining with <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code>)”, included in the SmartHLS IDE.
In the example, the <code class="docutils literal notranslate"><span class="pre">main</span></code> function contains the following code snippet:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create input and output FIFOs</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">input_fifo</span><span class="p">(</span><span class="cm">/*depth*/</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output_fifo</span><span class="p">(</span><span class="cm">/*depth*/</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// Launch thread kernels.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_fir</span><span class="p">(</span><span class="n">FIRFilterStreaming</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_injector</span><span class="p">(</span><span class="n">test_input_injector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_checker</span><span class="p">(</span><span class="n">test_output_checker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">);</span>

<span class="c1">// Join threads.</span>
<span class="n">thread_var_injector</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">thread_var_checker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></div>
</div>
<p>The corresponding hardware is illustrated in the figure below.</p>
<div class="figure align-center">
<img alt="_images/FIR_Pthreads_schematic.png" src="_images/FIR_Pthreads_schematic.png" />
</div>
<p>The two hls::FIFO&lt;int&gt;s in the C++ code corresponds to the creation of the two FIFOs, where the bit-width is set according to the type shown in the constructor argument &lt;int&gt;.
The three <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;void&gt;</span></code> calls initiate and parallelize the executions of three computational tasks, where each task is passed in a FIFO (or a pointer to a struct containing more than one FIFO pointers) as its argument.</p>
<p>The FIFO connections and data flow directions are implied by the uses of FIFO <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code> APIs.
For example, the <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> function has a <code class="docutils literal notranslate"><span class="pre">write()</span></code> call writing data into the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>, and the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> function uses a <code class="docutils literal notranslate"><span class="pre">read()</span></code> call to read data out from the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>.
This means that the data flows through the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> from <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> to <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">join()</span></code> API is called to wait for the completion of <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> and <code class="docutils literal notranslate"><span class="pre">test_output_checker</span></code>.
We do not “join” the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> thread since it contains an
infinite loop (see code below) that is always active and processes incoming
data from <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> whenever the FIFO is not empty.
This closely matches the <em>always running</em> behaviour of streaming hardware, where hardware is constantly running and processing data..</p>
<p>Now let’s take a look at the implementation of the main computational task (i.e., the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> threading function).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> <span class="kt">void</span> <span class="nf">FIRFilterStreaming</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">input_fifo</span><span class="p">,</span>
                         <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// This loop is pipelined and will be &quot;always running&quot;, just like how a</span>
     <span class="c1">// streaming module always runs when new input is available.</span>
     <span class="cp">#pragma HLS loop pipeline</span>
     <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// Read from input FIFO.</span>
         <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="n">input_fifo</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">();</span>

         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FIRFilterStreaming input: %d - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
         <span class="k">static</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// Need to store the last TAPS -1 samples.</span>
         <span class="k">const</span> <span class="kt">int</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>
                                         <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>

         <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span>
             <span class="n">previous</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
         <span class="n">previous</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">TAPS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
             <span class="n">temp</span> <span class="o">+=</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

         <span class="kt">int</span> <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">temp</span><span class="p">;</span>

         <span class="c1">// Write to output FIFO.</span>
         <span class="n">output_fifo</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the code shown in the example project, you will notice that all three threading functions contain a loop, which repeatedly reads and/or writes data from/to FIFOs to perform processing.
In SmartHLS, this is how one can specify that functions are continuously processing data streams that are flowing through FIFOs.</p>
<div class="section" id="further-throughput-enhancement-with-loop-pipelining">
<h3>Further Throughput Enhancement with Loop Pipelining<a class="headerlink" href="#further-throughput-enhancement-with-loop-pipelining" title="Permalink to this headline">¶</a></h3>
<p>In this example, the throughput of the streaming circuit will be limited by how frequently the functions can start processing new data (i.e., how frequently the new loop iterations can be started).
For instance, if the slowest function among the three functions can only start a new loop iteration every 4 cycles, then the throughput of the entire streaming circuit will be limited to processing one piece of data every 4 cycles.
Therefore, as you may have guessed, we can further improve the circuit throughput by pipelining the loops in the three functions.
If you run SmartHLS synthesis for the example (<code class="docutils literal notranslate"><span class="pre">Compile</span> <span class="pre">Software</span> <span class="pre">to</span> <span class="pre">Hardware</span></code>), you should see in the <code class="docutils literal notranslate"><span class="pre">Pipeline</span> <span class="pre">Result</span></code> section of our report file, <code class="docutils literal notranslate"><span class="pre">summary.hls.&lt;top_level&gt;.rpt</span></code>, that all loops can be pipelined with an initiation interval of 1.
That means all functions can start a new iteration every clock cycle, and hence the entire streaming circuit can process one piece of data every clock cycle.
Now run the simulation (<code class="docutils literal notranslate"><span class="pre">Simulate</span> <span class="pre">Hardware</span></code>) to confirm our expected throughput. The reported cycle latency should be just slightly more than the number of data samples to be processed
(<code class="docutils literal notranslate"><span class="pre">INPUTSIZE</span></code> is set to 128; the extra cycles are spent on activating the parallel accelerators, flushing out the pipelines, and verifying the results).</p>
</div>
</div>
<div class="section" id="memory-partitioning-1">
<span id="memory-partitioning"></span><h2>Memory Partitioning<a class="headerlink" href="#memory-partitioning-1" title="Permalink to this headline">¶</a></h2>
<p>Memory Partitioning is an optimization where aggregate types such as arrays and structs are partitioned into smaller pieces
allowing for a greater number of reads and writes (accesses) per cycle. SmartHLS instantiates a RAM for each aggregate
type where each RAM has up to two ports (allowing up to two reads/writes per cycle). Partitioning aggregate types into
smaller memories or into its individual elements allows for more accesses per cycle and improves memory bandwidth.</p>
<p>There are two flavors of memory partitioning, access-based partitioning and user-specified partitioning.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last">
<li><p class="first">Accessing memory outside of an array dimension is not supported by memory partitioning and will sometimes cause
incorrect circuit behavior. An example of this is casting a 2-d array to a pointer and iterating through the size
of the 2-d array.</p>
</li>
<li><p class="first">Pointers that alias to different memories (e.g. a function called with different memories) or different sections of the same memory (e.g. a pointer that is assigned to multiple memories based on a condition) can be partitioned if the aliased memories/sections have the same partitions. Otherwise, access-based partitioning will not partition the aliased memories, or a warning will be displayed for user-specified partitioning. The following example shows an unsupported aliasing case:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">sum_array</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">z</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function noinline</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition variable(x) type(block) dim(1) factor(2)</span>
  <span class="kt">int</span> <span class="n">x</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="c1">// x should be partitioned into 2 partitions</span>
<span class="cp">#pragma HLS memory partition variable(x) type(cyclic) dim(1) factor(4)</span>
  <span class="kt">int</span> <span class="n">y</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>   <span class="c1">// x should be partitioned into 4 partitions</span>
  <span class="c1">// ...</span>
  <span class="kt">int</span> <span class="n">sum_x</span> <span class="o">=</span> <span class="n">sum_array</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">sum_y</span> <span class="o">=</span> <span class="n">sum_array</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SmartHLS will output a warning:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Warning: The user specified memory &quot;x&quot; on line 80 of test.cpp could not be partitioned because the memory aliases with another memory at line 71 of test.cpp that has a different partitioning.
Warning: The user specified memory &quot;y&quot; on line 82 of test.cpp could not be partitioned because the memory aliases with another memory at line 71 of test.cpp that has a different partitioning.
</pre></div>
</div>
</li>
<li><p class="first">Partitions with no accesses are discarded.</p>
</li>
</ul>
</div>
<div class="section" id="access-based-memory-partitioning">
<span id="access-based-partitioning"></span><h3>Access-Based Memory Partitioning<a class="headerlink" href="#access-based-memory-partitioning" title="Permalink to this headline">¶</a></h3>
<p>Access-based partitioning is automatically applied to all memories except for those at the top-level interfaces (<a class="reference internal" href="hwarchitecture.html#io-memory"><span class="std std-ref">I/O Memory</span></a>).
This flavor of memory partitioning will analyze the ranges of all accesses to a memory and create partitions based on
these accesses. After analyzing all memory accesses, independent partitions will be implemented in independent memories.
If two partitions overlap in what they access, they will be merged into one partition. If there are any sections of the memory that is not accessed, it will be discarded to reduce memory usage.
For example, if there are two loops, where one loop accesses the first half of an array and the second loop accesses the second half of the array, the accesses to the array from the two loops are completely independent.
In this case the array will be partitioned into two and be implemented in two memories, one that holds the first half of the array and another that holds the second half of the array.
However, if both loops access the entire array, their accesses overlap, hence the two partitions will be merged into one and the array will just be implemented in a single memory (without being partitioned).
Access-based partitioning is done automatically without needing any memory partition pragmas, in order to automatically improve memory bandwidth and reduce memory usage whenever possible.</p>
<p><strong>Example</strong></p>
<p>Access-based partitioning is automatically applied to all memories by SmartHLS except for interface memories (top-level function arguments and global variables accessed by both software testbench and hardware functions) to the
top-level function. Interface memories need to be partitioned with the memory partition pragma.
See the code snippet below that illustrate an example of accessed-based partitioning.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="cp">#pragma HLS loop unroll</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>In the example above, each iteration of the loop access an element of <code class="docutils literal notranslate"><span class="pre">array</span></code> and adds it to <code class="docutils literal notranslate"><span class="pre">result</span></code>. The <code class="docutils literal notranslate"><span class="pre">unroll</span></code> pragma is applied to completely unroll the loop.
Without partitioning, SmartHLS will implement this array in a RAM (with 1000 elements), where an FPGA RAM can have up to two read/write ports.
In this case, the loop will take 500 cycles, as 1000 reads are needed from the RAM and up to two reads can be performed per cycle with a two ported memory.</p>
<p>With access-based partitioning, the accesses to the above array will be analyzed. With unrolling, there will be 1000
load instructions, each of which will access a single array element, with no overlaps in accesses between the load instructions (i.e., the accesses of each load instruction are independent).
This creates 1000 partitions, with one array element in each partition.
After partitioning, all 1000 reads can occur in the same clock cycle, as each memory will only need one memory access. Hence the entire loop can finish in a single cycle.
With this example, we can see that memory partitioning can help to improve memory bandwidth and improve performance.</p>
<p>With access-based partitioning, SmartHLS outputs messages to the console specifying which memory has been partitioned into how many partitions, as shown below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Partitioning memory: array into 1000 partitions.
</pre></div>
</div>
<p>Please refer to the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> for more examples and details.</p>
</div>
<div class="section" id="user-specified-memory-partitioning-1">
<span id="user-specified-memory-partitioning"></span><h3>User-Specified Memory Partitioning<a class="headerlink" href="#user-specified-memory-partitioning-1" title="Permalink to this headline">¶</a></h3>
<p>The user can explicitly specify a memory to be partitioned via the <code class="docutils literal notranslate"><span class="pre">memory</span> <span class="pre">partition</span></code> pragma (<code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">memory</span> <span class="pre">partition</span> <span class="pre">variable</span></code>, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">memory</span> <span class="pre">partition</span> <span class="pre">argument</span></code>). See <a class="reference internal" href="pragmas.html#pragma-memory-partition-argument"><span class="std std-ref">Partition Top-Level Interface</span></a> and <a class="reference internal" href="pragmas.html#pragma-memory-partition-variable"><span class="std std-ref">Partition Memory</span></a> for more details.
User-specified partitioning also analyzes accesses but partitions based on a predefined structure and array dimension.
SmartHLS supports <code class="docutils literal notranslate"><span class="pre">block</span></code>, <code class="docutils literal notranslate"><span class="pre">cyclic</span></code> and <code class="docutils literal notranslate"><span class="pre">complete</span></code> types for arrays, and <code class="docutils literal notranslate"><span class="pre">struct_fields</span></code> and <code class="docutils literal notranslate"><span class="pre">complete</span></code> partitioning for <code class="docutils literal notranslate"><span class="pre">struct</span></code>. Specifying the type to be <code class="docutils literal notranslate"><span class="pre">none</span></code> prevents partitioning the specified memory.</p>
<p>The memory partition pragma has optional arguments <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">dim</span></code> that specifies the partition type and dimension to partition, respectively.
The default type is <code class="docutils literal notranslate"><span class="pre">complete</span></code> which means to partition the array into individual elements, and the default dimension is <code class="docutils literal notranslate"><span class="pre">0</span></code> which means to partition all dimensions.
The <code class="docutils literal notranslate"><span class="pre">factor</span></code> argument is required for <code class="docutils literal notranslate"><span class="pre">block</span></code> and <code class="docutils literal notranslate"><span class="pre">cyclic</span></code> types to specify the partitioning factor, i.e. the number of partitions. Note that the pragma will be ignored if the <code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Lower numbered dimensions correspond to left-ward dimensions of the array and higher numbered dimensions correspond to right-ward dimensions of the array. For an a 2d array <code class="docutils literal notranslate"><span class="pre">A[N][M]</span></code>, <code class="docutils literal notranslate"><span class="pre">dim(1)</span></code> refers to the dimension with <code class="docutils literal notranslate"><span class="pre">N</span></code> elements, and <code class="docutils literal notranslate"><span class="pre">dim(2)</span></code> refers to the dimension with <code class="docutils literal notranslate"><span class="pre">M</span></code> elements.</p>
</div>
<p>With user-specified partitioning, SmartHLS outputs messages to the console stating the variable set to be partitioned and its settings.
SmartHLS also outputs messages specifying if a memory has been partitioned and into how many partitions.
If a memory is specified to be partitioned but cannot be partitioned, SmartHLS will output a warning.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Found user-specified memory: &quot;array&quot; on line 6 of test.c, with partition type: Complete, partition dimension: 0.
Info: Found user-specified memory: &quot;array3d&quot; on line 27 of test.c, with partition type: Block, partition dimension: 1, partition factor 2.
Warning: The user-specified memory &quot;array3d&quot; on line 27 of test.c could not be partitioned because a loop variable indexing into a multi-dimenional array comes from a loop variable and goes out of the array dimension bounds. Going outside of array dimension bounds is not supported for memory partitioning.
Info: Partitioning memory: array into 8 partitions.
</pre></div>
</div>
<p>Please refer to the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> for more examples and details.</p>
<div class="section" id="block-partitioning">
<span id="block-memory-partitioning"></span><h4>Block Partitioning<a class="headerlink" href="#block-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Block partitioning aggregates consecutive elements of the original array into partitions. The number of partitions (blocks) is defined by the <code class="docutils literal notranslate"><span class="pre">factor</span></code> argument.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS memory partition variable(array2d) type(block) dim(1) factor(2)</span>
<span class="kt">int</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">20</span><span class="p">];</span>
</pre></div>
</div>
<p>For example, in the above code snippet <code class="docutils literal notranslate"><span class="pre">array2d</span></code> is specified to partition dimension <code class="docutils literal notranslate"><span class="pre">1</span></code> with factor <code class="docutils literal notranslate"><span class="pre">2</span></code>. The result is two <code class="docutils literal notranslate"><span class="pre">int[5][20]</span></code> partitions where the first partitions has elements <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">1,</span> <span class="pre">2,</span> <span class="pre">3,</span> <span class="pre">4</span></code>, and the second has elements <code class="docutils literal notranslate"><span class="pre">5,</span> <span class="pre">6,</span> <span class="pre">7,</span> <span class="pre">8,</span> <span class="pre">9</span></code> of dimension <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the number of elements <code class="docutils literal notranslate"><span class="pre">N</span></code> in the specified dimension is not divisible by <code class="docutils literal notranslate"><span class="pre">factor</span></code>, all the partitions will have the same size <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">ceil(N/factor)</span></code>, except the last partition which will have the remaining elements <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">(factor</span> <span class="pre">-</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">B</span></code>. For example, if <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">10</span></code> and <code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">=</span> <span class="pre">3</span></code>, the resulting partitions will have <code class="docutils literal notranslate"><span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">4</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> elements respectively.</p>
</div>
</div>
<div class="section" id="cyclic-partitioning">
<span id="cyclic-memory-partitioning"></span><h4>Cyclic Partitioning<a class="headerlink" href="#cyclic-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Cyclic partitioning interleaves elements from the original array into partitions. The number of interleaved partitions is defined by the <code class="docutils literal notranslate"><span class="pre">factor</span></code> argument.
The array is partitioned cyclically by arbitrating the elements between the partitions, putting one element into each partition before coming back to the first one until the array is fully partitioned.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS memory partition variable(array2d) type(cyclic) dim(2) factor(2)</span>
<span class="kt">int</span> <span class="n">array2d</span><span class="p">[</span><span class="mi">10</span><span class="p">][</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</div>
<p>For example, in the above code snippet <code class="docutils literal notranslate"><span class="pre">array2d</span></code> is specified to partition dimension <code class="docutils literal notranslate"><span class="pre">2</span></code> with factor <code class="docutils literal notranslate"><span class="pre">2</span></code>. The result is two <code class="docutils literal notranslate"><span class="pre">int[10][5]</span></code> partitions where the first partition has elements <code class="docutils literal notranslate"><span class="pre">0,</span> <span class="pre">2,</span> <span class="pre">4,</span> <span class="pre">6,</span> <span class="pre">8</span></code>, and the second has elements <code class="docutils literal notranslate"><span class="pre">1,</span> <span class="pre">3,</span> <span class="pre">5,</span> <span class="pre">7,</span> <span class="pre">9</span></code> of dimension <code class="docutils literal notranslate"><span class="pre">2</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the number of elements <code class="docutils literal notranslate"><span class="pre">N</span></code> in the specified dimension is not divisible by <code class="docutils literal notranslate"><span class="pre">factor</span></code>, the number of complete partitions with <code class="docutils literal notranslate"><span class="pre">B</span> <span class="pre">=</span> <span class="pre">ceil(N/factor)</span></code> elements will be <code class="docutils literal notranslate"><span class="pre">M</span> <span class="pre">=</span> <span class="pre">N</span> <span class="pre">%</span> <span class="pre">factor</span></code>, and the rest of partitions will have <code class="docutils literal notranslate"><span class="pre">B-1</span></code> elements. For example, if <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">10</span></code> and <code class="docutils literal notranslate"><span class="pre">factor</span> <span class="pre">=</span> <span class="pre">3</span></code>, the resulting partitions will have <code class="docutils literal notranslate"><span class="pre">4</span></code>, <code class="docutils literal notranslate"><span class="pre">3</span></code> and <code class="docutils literal notranslate"><span class="pre">3</span></code> elements respectively.</p>
</div>
</div>
<div class="section" id="complete-partitioning">
<span id="complete-memory-partitioning"></span><h4>Complete Partitioning<a class="headerlink" href="#complete-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Complete partitioning deconstructs the array into individual elements along the specified dimension. For a multi-dimensional array, each element of the specified dimension will correspond to a partition with the rest of the dimensions preserved. For a one-dimensional array, individual elements are mapped to registers. If <code class="docutils literal notranslate"><span class="pre">dim(0)</span></code> is specified, complete partitioning is applied across all dimensions resulting in scalar elements.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Applying complete partitioning on a (array of) struct, partitions all struct fields (including nested struct elements) and array dimensions.</p>
</div>
<p><strong>Example</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS memory partition variable(_array)</span>
<span class="kt">int</span> <span class="n">_array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">_result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">//...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_result</span> <span class="o">+=</span> <span class="n">_array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
</pre></div>
</div>
<p>The example above shows the same example that was shown for access-based partitioning, however, the loop is not unrolled in this case.
Access-based partitioning will try to partition the array but will only find one load instruction in the loop that accesses the entire array.
This preventing access-based partitioning as all eight accesses come from the same load instruction.</p>
<p>User-specified partitioning can be used to force partitioning of this array with a predefined structure. In the example above,
the memory partition pragma specifies the array to be partitioned completely into eight individual elements.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Partitioning memory: _array into 8 partitions.
</pre></div>
</div>
<p>The benefit in this case is that the loop does not have to be unrolled, which can be useful in cases like when the loop is
pipelined and cannot be unrolled (see <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>).</p>
</div>
<div class="section" id="struct-fields-partitioning">
<span id="struct-fields-memory-partitioning"></span><h4>Struct-Fields Partitioning<a class="headerlink" href="#struct-fields-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Struct-fields partitioning partitions a (array of) struct argument / variable into its individual fields such that each field is a partition.
Unlike complete partitioning, if a field in the partitioned struct is an aggregate type (struct or array), the field is not further partitioned to its elements.
Note that applying Struct-fields partitioning to  an array-of-struct creates an array for each field in the struct.
Unaccessed partitions (fields) are discarded, but the unaccessed elements in an aggreagte partition (field) are not discarded.</p>
<p><strong>Example</strong></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Ty</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">SubTy</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kt">char</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">SubTy</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="n">Ty</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(array) type(struct_fields)</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example above shows <code class="docutils literal notranslate"><span class="pre">array</span></code>, an array of struct of type <cite>Ty</cite>, is
partitioned using Struct-fields partitioning.
With the user-specified partitioning, SmartHLS outputs messages to the console stating that the argument
set to be partitioned and how many partitions are created.
The three partitions are <code class="docutils literal notranslate"><span class="pre">array.x[8]</span></code>, <code class="docutils literal notranslate"><span class="pre">array.y[8][2]</span></code>, and <code class="docutils literal notranslate"><span class="pre">array.z[8]</span></code>, where the 8-element dimensions are inherited from the original array size.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Found user specified memory: &quot;array&quot; on line 15 of struct_sum.cpp, with partition type: Fields, partition dimension: 0.
Info: Partitioning memory: array into 3 partitions.
</pre></div>
</div>
<p>The summary report from SmartHLS lists the 3 partitions created from the fields of the struct.
Note that the array field <cite>Ty.y</cite> has one partition, and similarly the struct field <cite>Ty.z</cite>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+---------------------------------------------------------------------------+
| I/O Memories                                                              |
+---------+-----------------------+------+-------------+------------+-------+
| Name    | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
+---------+-----------------------+------+-------------+------------+-------+
| array_x | sum                   | ROM  | 0           | 8          | 0     |
| array_y | sum                   | ROM  | 0           | 16         | 0     |
| array_z | sum                   | ROM  | 0           | 64         | 0     |
+---------+-----------------------+------+-------------+------------+-------+
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="struct-support-1">
<span id="struct-support"></span><h2>Struct Support<a class="headerlink" href="#struct-support-1" title="Permalink to this headline">¶</a></h2>
<p>A C++ <code class="docutils literal notranslate"><span class="pre">struct</span></code> is a user-defined data type that is used to group several fields, possibly with different data types.
Using <code class="docutils literal notranslate"><span class="pre">struct</span></code> allows passing a set of variables around the design together while retaining the readability and accessibility of each of these variables.
In this section, we will discuss how interfaces and memories with <code class="docutils literal notranslate"><span class="pre">struct</span></code> types are handled in SmartHLS including partitioning, packing, and returning by value.</p>
<p><strong>Example</strong></p>
<p>This example will be used in the following sub-sections to show the different interfaces.  There are three <code class="docutils literal notranslate"><span class="pre">struct</span></code> types in the code below:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Account</span></code>: represents a bank account with checking and savings balances.</li>
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: represents a bank client with an ID <code class="docutils literal notranslate"><span class="pre">id</span></code> and an account <code class="docutils literal notranslate"><span class="pre">acc</span></code> . Note that <code class="docutils literal notranslate"><span class="pre">id</span></code> has a 6-bit unsigned integer type to demonstrate <code class="docutils literal notranslate"><span class="pre">struct</span></code> packing.</li>
<li><code class="docutils literal notranslate"><span class="pre">UpdateResult</span></code>: used as a return type for the top-level function <code class="docutils literal notranslate"><span class="pre">update</span></code>  to report if the update was completed and the final account balance.</li>
</ul>
<p>The top-level function <code class="docutils literal notranslate"><span class="pre">update</span></code>  of the example takes a clients’ list <code class="docutils literal notranslate"><span class="pre">clients</span></code> , an ID <code class="docutils literal notranslate"><span class="pre">id</span></code> and an account balance <code class="docutils literal notranslate"><span class="pre">acc</span></code>  to be added to the client’s balance.
It returns <code class="docutils literal notranslate"><span class="pre">UpdateResult</span></code> with <code class="docutils literal notranslate"><span class="pre">updated</span> <span class="pre">=</span> <span class="pre">1</span></code> and the final balance <code class="docutils literal notranslate"><span class="pre">acc</span></code>  if an account with ID <code class="docutils literal notranslate"><span class="pre">id</span></code> is found in the client’s list <code class="docutils literal notranslate"><span class="pre">clients</span></code> , otherwise it returns <code class="docutils literal notranslate"><span class="pre">updated</span> <span class="pre">=</span> <span class="pre">0</span></code>.</p>
<p>To demonstrate another advantage of using <code class="docutils literal notranslate"><span class="pre">struct</span></code>, <code class="docutils literal notranslate"><span class="pre">Account</span></code> has a member function <code class="docutils literal notranslate"><span class="pre">add</span></code> that is used to update the balances which makes the code more readable in <code class="docutils literal notranslate"><span class="pre">update</span></code>  function.</p>
<p>Another function <code class="docutils literal notranslate"><span class="pre">find</span></code> is used to search for an account with ID <code class="docutils literal notranslate"><span class="pre">id</span></code> in the clients’ list. Notice that this function has <code class="docutils literal notranslate"><span class="pre">noinline</span></code> attribute. This is intended to demonstrate how <code class="docutils literal notranslate"><span class="pre">struct</span></code> types are passed through RTL modules after synthesizing the design.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/ap_int.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 4</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Account</span> <span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">checking</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">savings</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="k">const</span> <span class="n">Account</span> <span class="o">&amp;</span><span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">checking</span> <span class="o">+=</span> <span class="n">acc</span><span class="p">.</span><span class="n">checking</span><span class="p">;</span>
        <span class="n">savings</span> <span class="o">+=</span> <span class="n">acc</span><span class="p">.</span><span class="n">savings</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">Client</span> <span class="p">{</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">Account</span> <span class="n">acc</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">UpdateResult</span> <span class="p">{</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">updated</span><span class="p">;</span>
    <span class="n">Account</span> <span class="n">acc</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function noinline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="n">UpdateResult</span> <span class="n">ret</span><span class="p">{};</span>
    <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">acc</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">acc</span><span class="p">);</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">acc</span> <span class="o">=</span> <span class="n">clients</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">acc</span><span class="p">;</span>
        <span class="n">ret</span><span class="p">.</span><span class="n">updated</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">acc</span><span class="p">.</span><span class="n">checking</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">clients</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">acc</span><span class="p">.</span><span class="n">savings</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Account</span> <span class="n">test_acc</span><span class="p">{</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">passes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">UpdateResult</span> <span class="n">test_ret</span><span class="p">{};</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">test_ret</span> <span class="o">=</span> <span class="n">update</span><span class="p">(</span><span class="n">clients</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">test_acc</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">test_ret</span><span class="p">.</span><span class="n">updated</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">clients</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">acc</span><span class="p">.</span><span class="n">checking</span> <span class="o">==</span> <span class="mi">100</span> <span class="o">&amp;&amp;</span> <span class="n">clients</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">acc</span><span class="p">.</span><span class="n">savings</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span>
                <span class="n">passes</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// Should return 0 if passes == N</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">passes</span> <span class="o">!=</span> <span class="n">N</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="struct-packing-1">
<span id="struct-packing"></span><h3>Struct Packing<a class="headerlink" href="#struct-packing-1" title="Permalink to this headline">¶</a></h3>
<p>Packing a <code class="docutils literal notranslate"><span class="pre">struct</span></code> creates a single scalar with a wide word width.
All the <code class="docutils literal notranslate"><span class="pre">struct</span></code> members are placed in the scalar with their order in the <code class="docutils literal notranslate"><span class="pre">struct</span></code> definition such that the first element is the least significant part of the vector and the last element is the most significant part of the vector.
Packing allows all the <code class="docutils literal notranslate"><span class="pre">struct</span></code> elements to be read and written simultaneously.
There are two packing options in SmartHLS: bit-packing and byte-packing. A pragma is specified for the argument / variable to be packed with the packing option.
Note that packing an array of <code class="docutils literal notranslate"><span class="pre">struct</span></code> results in an array with each element as a wide-vector representing the packed <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Struct packing supports casting a <code class="docutils literal notranslate"><span class="pre">struct</span></code> to another type only if the packed type is the same as the cast type.
For example, the following code shows a supproted cast for <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">s</span></code> because packing the two <code class="docutils literal notranslate"><span class="pre">uint8_t</span></code> members is the same as <code class="docutils literal notranslate"><span class="pre">uint16_t</span></code>:</p>
<blockquote class="last">
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">b</span>
<span class="p">};</span>

<span class="cp">#pragma HLS memory impl variable(s) pack(bit)</span>
<span class="n">S</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">uint16_t</span> <span class="o">&amp;</span><span class="n">cast</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint16_t</span> <span class="o">&amp;</span><span class="p">)</span><span class="n">s</span><span class="p">;</span>
</pre></div>
</div>
</div></blockquote>
</div>
<p><strong>Bit-Packing</strong></p>
<p>Bit-packing uses the bit-width of each of element of the <code class="docutils literal notranslate"><span class="pre">struct</span></code>. In our example, <code class="docutils literal notranslate"><span class="pre">clients</span></code> argument can be bit-packed as following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function noinline</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory impl argument(clients) pack(bit)</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the HLS summary report, the interface for <code class="docutils literal notranslate"><span class="pre">clients</span></code> has a data width of 134, which is the sum of the <code class="docutils literal notranslate"><span class="pre">id</span></code> (6-bits), <code class="docutils literal notranslate"><span class="pre">acc.checking</span></code> (64-bits), and <code class="docutils literal notranslate"><span class="pre">acc.savings</span></code> (64-bits). The following layout of packed <code class="docutils literal notranslate"><span class="pre">struct</span></code> follows the order of the fields such that the first field is the least significant part of the layout.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>|133 .......... 70|69 .......... 6|5 .. 0|
|-----------------|---------------|------|
|   acc.savings   |  acc.checking |  id  |
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                |
+----------+-----------------+---------------------------------+------------------+------------------+
| C++ Name | Interface Type  | Signal Name                     | Signal Bit-width | Signal Direction |
+----------+-----------------+---------------------------------+------------------+------------------+
| clients  | Memory          | clients_address_a               | 2                | output           |
|          |                 | clients_address_b               | 2                | output           |
|          |                 | clients_clken                   | 1                | output           |
|          |                 | clients_read_data_a             | 134              | input            |
|          |                 | clients_read_data_b             | 134              | input            |
|          |                 | clients_read_en_a               | 1                | output           |
|          |                 | clients_read_en_b               | 1                | output           |
|          |                 | clients_write_data_a            | 134              | output           |
|          |                 | clients_write_data_b            | 134              | output           |
|          |                 | clients_write_en_a              | 1                | output           |
|          |                 | clients_write_en_b              | 1                | output           |
+----------+-----------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
<p><strong>Byte-Packing</strong></p>
<p>Byte-packing is similar to bit-packing except that each element of the <code class="docutils literal notranslate"><span class="pre">struct</span></code> is aligned to 8-bits. In our example, <code class="docutils literal notranslate"><span class="pre">clients</span></code> can be byte-packed as following:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function noinline</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory impl argument(clients) pack(byte)</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the HLS summary report, the interface for <code class="docutils literal notranslate"><span class="pre">clients</span></code> has a data width of 136, which is the sum of the <code class="docutils literal notranslate"><span class="pre">id</span></code> (8-bits), <code class="docutils literal notranslate"><span class="pre">acc.checking</span></code> (64-bits), and <code class="docutils literal notranslate"><span class="pre">acc.savings</span></code> (64-bits). The following layout of packed <code class="docutils literal notranslate"><span class="pre">struct</span></code> follows the order of the fields such that the first field is the least significant part of the layout.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>|135 .......... 72|71 .......... 8|7 .. 0|
|-----------------|---------------|------|
|   acc.savings   |  acc.checking |  id  |
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                |
+----------+-----------------+---------------------------------+------------------+------------------+
| C++ Name | Interface Type  | Signal Name                     | Signal Bit-width | Signal Direction |
+----------+-----------------+---------------------------------+------------------+------------------+
| clients  | Memory          | clients_address_a               | 2                | output           |
|          |                 | clients_address_b               | 2                | output           |
|          |                 | clients_clken                   | 1                | output           |
|          |                 | clients_read_data_a             | 136              | input            |
|          |                 | clients_read_data_b             | 136              | input            |
|          |                 | clients_read_en_a               | 1                | output           |
|          |                 | clients_read_en_b               | 1                | output           |
|          |                 | clients_write_data_a            | 136              | output           |
|          |                 | clients_write_data_b            | 136              | output           |
|          |                 | clients_write_en_a              | 1                | output           |
|          |                 | clients_write_en_b              | 1                | output           |
+----------+-----------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
<p>For byte-packing, the interface can either use byte-enable to write individual fields or it can be a wide scalar as shown before.
To use byte-enable signals, <code class="docutils literal notranslate"><span class="pre">byte_enable</span></code> parameter should be set to <code class="docutils literal notranslate"><span class="pre">true</span></code> in the packing pragma:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function noinline</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory impl argument(clients) pack(byte) byte_enable(true)</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The HLS summary report will show <code class="docutils literal notranslate"><span class="pre">clients_byte_en_a</span></code> and <code class="docutils literal notranslate"><span class="pre">clients_byte_en_b</span></code> signals that are added to the interface.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">byte_enable</span></code> parameter is default to <code class="docutils literal notranslate"><span class="pre">false</span></code> and can only be specified with <code class="docutils literal notranslate"><span class="pre">pack(byte)</span></code>, i.e. using it with <code class="docutils literal notranslate"><span class="pre">pack(bit)</span></code> will error during compilation.</p>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                |
+----------+-----------------+---------------------------------+------------------+------------------+
| C++ Name | Interface Type  | Signal Name                     | Signal Bit-width | Signal Direction |
+----------+-----------------+---------------------------------+------------------+------------------+
| clients  | Memory          | clients_address_a               | 2                | output           |
|          |                 | clients_address_b               | 2                | output           |
|          |                 | clients_byte_en_a               | 17               | output           |
|          |                 | clients_byte_en_b               | 17               | output           |
|          |                 | clients_clken                   | 1                | output           |
|          |                 | clients_read_data_a             | 136              | input            |
|          |                 | clients_read_data_b             | 136              | input            |
|          |                 | clients_read_en_a               | 1                | output           |
|          |                 | clients_read_en_b               | 1                | output           |
|          |                 | clients_write_data_a            | 136              | output           |
|          |                 | clients_write_data_b            | 136              | output           |
|          |                 | clients_write_en_a              | 1                | output           |
|          |                 | clients_write_en_b              | 1                | output           |
+----------+-----------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
</div>
<div class="section" id="struct-partitioning">
<h3>Struct Partitioning<a class="headerlink" href="#struct-partitioning" title="Permalink to this headline">¶</a></h3>
<p>Partitioning a <code class="docutils literal notranslate"><span class="pre">struct</span></code> creates a separate interface / memory for each field in the <code class="docutils literal notranslate"><span class="pre">struct</span></code>. Two partitioning types are supported for <code class="docutils literal notranslate"><span class="pre">struct</span></code> types: fields and complete.</p>
<p><strong>Fields Partitioning</strong></p>
<p>Fields partitioning acts on 1-level of nested <code class="docutils literal notranslate"><span class="pre">struct</span></code> types, i.e. only the fields in the top <code class="docutils literal notranslate"><span class="pre">struct</span></code> type are disaggregated.
In our example, to partition <code class="docutils literal notranslate"><span class="pre">clients</span></code> into its fields, <code class="docutils literal notranslate"><span class="pre">partition</span></code> pragma with <code class="docutils literal notranslate"><span class="pre">struct_fields</span></code> type is used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(clients) type(struct_fields)</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the HLS summary report, <code class="docutils literal notranslate"><span class="pre">clients</span></code> result in 2 memory interfaces <code class="docutils literal notranslate"><span class="pre">acc</span></code>  and <code class="docutils literal notranslate"><span class="pre">id</span></code>. Notice that the inner <code class="docutils literal notranslate"><span class="pre">struct</span></code> member <code class="docutils literal notranslate"><span class="pre">acc</span></code>  is not partitioned into its members and kept as a single interface.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                |
+----------+-----------------+---------------------------------+------------------+------------------+
| C++ Name | Interface Type  | Signal Name                     | Signal Bit-width | Signal Direction |
+----------+-----------------+---------------------------------+------------------+------------------+
| clients  | Memory          | clients_a0_acc_address_a        | 2                | output           |
|          |                 | clients_a0_acc_address_b        | 2                | output           |
|          |                 | clients_a0_acc_clken            | 1                | output           |
|          |                 | clients_a0_acc_read_data_a      | 128              | input            |
|          |                 | clients_a0_acc_read_data_b      | 128              | input            |
|          |                 | clients_a0_acc_read_en_a        | 1                | output           |
|          |                 | clients_a0_acc_read_en_b        | 1                | output           |
|          |                 | clients_a0_acc_write_data_a     | 128              | output           |
|          |                 | clients_a0_acc_write_data_b     | 128              | output           |
|          |                 | clients_a0_acc_write_en_a       | 1                | output           |
|          |                 | clients_a0_acc_write_en_b       | 1                | output           |
|          |                 | clients_a0_id_address_a         | 2                | output           |
|          |                 | clients_a0_id_address_b         | 2                | output           |
|          |                 | clients_a0_id_clken             | 1                | output           |
|          |                 | clients_a0_id_read_data_a       | 6                | input            |
|          |                 | clients_a0_id_read_data_b       | 6                | input            |
|          |                 | clients_a0_id_read_en_a         | 1                | output           |
|          |                 | clients_a0_id_read_en_b         | 1                | output           |
+----------+-----------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>Fields partitioning keeps the inner aggregate types (arrays and structs) without partitioning.</li>
<li>Fields partitioning an array of <code class="docutils literal notranslate"><span class="pre">struct</span></code> results in an array for each field in the <code class="docutils literal notranslate"><span class="pre">struct</span></code>.</li>
</ul>
</div>
<p><strong>Complete Partitioning</strong></p>
<p>Complete partitioning of a <code class="docutils literal notranslate"><span class="pre">struct</span></code> type creates a separate interface / memory for each primitive element in the <code class="docutils literal notranslate"><span class="pre">struct</span></code>. This implies that partitioning is applied recursively on the <code class="docutils literal notranslate"><span class="pre">struct</span></code> or a array of <code class="docutils literal notranslate"><span class="pre">struct</span></code>.
In our example, to partition <code class="docutils literal notranslate"><span class="pre">clients</span></code> into its fields, <code class="docutils literal notranslate"><span class="pre">partition</span></code> pragma with <code class="docutils literal notranslate"><span class="pre">complete</span></code> type is used:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">UpdateResult</span> <span class="nf">update</span><span class="p">(</span><span class="n">Client</span> <span class="n">clients</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span> <span class="n">id</span><span class="p">,</span> <span class="n">Account</span> <span class="n">acc</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(clients) type(complete)</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the HLS summary report, <code class="docutils literal notranslate"><span class="pre">clients</span></code> result in 12 interfaces which is 4 array elements with 3 fields for each element.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">+-------------------------------------------------------------------------------------------------------+</span>
<span class="o">|</span> <span class="n">RTL</span> <span class="n">Interface</span> <span class="n">Generated</span> <span class="n">by</span> <span class="n">SmartHLS</span>                                                                   <span class="o">|</span>
<span class="o">+----------+-----------------+------------------------------------+------------------+------------------+</span>
<span class="o">|</span> <span class="n">C</span><span class="o">++</span> <span class="n">Name</span> <span class="o">|</span> <span class="n">Interface</span> <span class="n">Type</span>  <span class="o">|</span> <span class="n">Signal</span> <span class="n">Name</span>                        <span class="o">|</span> <span class="n">Signal</span> <span class="n">Bit</span><span class="o">-</span><span class="n">width</span> <span class="o">|</span> <span class="n">Signal</span> <span class="n">Direction</span> <span class="o">|</span>
<span class="o">+----------+-----------------+------------------------------------+------------------+------------------+</span>
<span class="o">|</span> <span class="n">clients</span>  <span class="o">|</span> <span class="n">Scalar</span> <span class="n">Memory</span>   <span class="o">|</span> <span class="n">clients_a0_acc_checking_read_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_acc_checking_write_data</span> <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_acc_checking_write_en</span>   <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_acc_savings_read_data</span>   <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_acc_savings_write_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_acc_savings_write_en</span>    <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a0_id_read_data</span>            <span class="o">|</span> <span class="mi">6</span>                <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_checking_read_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_checking_write_data</span> <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_checking_write_en</span>   <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_savings_read_data</span>   <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_savings_write_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_acc_savings_write_en</span>    <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a1_id_read_data</span>            <span class="o">|</span> <span class="mi">6</span>                <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_checking_read_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_checking_write_data</span> <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_checking_write_en</span>   <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_savings_read_data</span>   <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_savings_write_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_acc_savings_write_en</span>    <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a2_id_read_data</span>            <span class="o">|</span> <span class="mi">6</span>                <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_checking_read_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_checking_write_data</span> <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_checking_write_en</span>   <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_savings_read_data</span>   <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_savings_write_data</span>  <span class="o">|</span> <span class="mi">64</span>               <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_acc_savings_write_en</span>    <span class="o">|</span> <span class="mi">1</span>                <span class="o">|</span> <span class="n">output</span>           <span class="o">|</span>
<span class="o">|</span>          <span class="o">|</span>                 <span class="o">|</span> <span class="n">clients_a3_id_read_data</span>            <span class="o">|</span> <span class="mi">6</span>                <span class="o">|</span> <span class="n">input</span>            <span class="o">|</span>
<span class="o">+----------+-----------------+------------------------------------+------------------+------------------+</span>
</pre></div>
</div>
</div>
<div class="section" id="return-struct-by-value">
<h3>Return Struct By Value<a class="headerlink" href="#return-struct-by-value" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS supports returning a <code class="docutils literal notranslate"><span class="pre">struct</span></code> by value from the top-level function. In this case, the return value is always bit-packed resulting in a scalar interface.
In our example, the RTL module will have a <code class="docutils literal notranslate"><span class="pre">return_val</span></code> port with 129 bit width (<code class="docutils literal notranslate"><span class="pre">updated</span></code> = 1-bit, <code class="docutils literal notranslate"><span class="pre">acc</span></code> = 128-bits):</p>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">update_top</span>
<span class="p">(</span>
        <span class="n">clk</span><span class="p">,</span>
        <span class="n">reset</span><span class="p">,</span>
        <span class="n">start</span><span class="p">,</span>
        <span class="n">ready</span><span class="p">,</span>
        <span class="n">finish</span><span class="p">,</span>
        <span class="n">return_val</span><span class="p">,</span>
        <span class="p">...</span>
<span class="p">)</span>

<span class="k">input</span>  <span class="n">clk</span><span class="p">;</span>
<span class="k">input</span>  <span class="n">reset</span><span class="p">;</span>
<span class="k">input</span>  <span class="n">start</span><span class="p">;</span>
<span class="k">output</span> <span class="kt">reg</span>  <span class="n">ready</span><span class="p">;</span>
<span class="k">output</span> <span class="kt">reg</span>  <span class="n">finish</span><span class="p">;</span>
<span class="k">output</span> <span class="kt">reg</span> <span class="p">[</span><span class="mh">128</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">return_val</span><span class="p">;</span>
<span class="p">...</span>
</pre></div>
</div>
</div>
<div class="section" id="default-struct-modes">
<h3>Default Struct Modes<a class="headerlink" href="#default-struct-modes" title="Permalink to this headline">¶</a></h3>
<p>The default <code class="docutils literal notranslate"><span class="pre">struct</span></code> mode in SmartHLS is applied when no pragma is specified for the argument / variable. The default mode differs between interfaces and local memories:</p>
<ul class="simple">
<li>For interfaces (top-level argument / global variable interface), bit-packing is the default.</li>
<li>For local memories, automatic partitioning is applied to optimize the design. If partitioning is not possible, bit-packing is applied.</li>
</ul>
</div>
<div class="section" id="limitations">
<h3>Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<p>There are some limitations for <code class="docutils literal notranslate"><span class="pre">struct</span></code> support that can prevent partitioning / packing. The unsupported cases are generally not used in HLS designs:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">struct</span></code> interfaces with pointer fields.</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>Casting a <code class="docutils literal notranslate"><span class="pre">struct</span></code> to another type.</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">S</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<ul class="simple">
<li>Storing the address of a <code class="docutils literal notranslate"><span class="pre">struct</span></code> field.</li>
</ul>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">S</span> <span class="n">s</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">b</span><span class="p">);</span>
<span class="n">foo</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="smarthls-c-c-library">
<h2>SmartHLS C/C++ Library<a class="headerlink" href="#smarthls-c-c-library" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS includes a number of C/C++ libraries that allow creation of efficient hardware.</p>
<div class="section" id="streaming-library">
<span id="streaming-lib"></span><h3>Streaming Library<a class="headerlink" href="#streaming-library" title="Permalink to this headline">¶</a></h3>
<p>The streaming library includes the FIFO (first-in first-out) data structure along with its associated API functions.
The library can be compiled in software to run on the host machine (e.g., x86).
Each FIFO instance in software is implemented as a First Word Fall Through (FWFT) FIFO in hardware.</p>
<p>The FIFO library is provided as a C++ template class.
The FIFO data type can be flexibly defined and specified as a template argument of the FIFO object.
For example, the FIFO data type could be defined as a struct containing multiple integers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">AxisWord</span> <span class="p">{</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">keep</span><span class="p">;</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">last</span><span class="p">;</span> <span class="p">};</span>

<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">AxisWord</span><span class="o">&gt;</span> <span class="n">my_axi_stream_interface_fifo</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A valid data type could be any of the
1) C/C++ primitive integer types,
2) SmartHLS’s <a class="reference internal" href="#ap-lib"><span class="std std-ref">C++ Arbitrary Precision Data Types Library</span></a> (ap_int, ap_uint, ap_fixpt, ap_ufixpt),
or 3) a struct containing primitive integer types or SmartHLS’s C++ arbitrary
Precision Data Types.
In the case of a struct type, it is prohibited to use ‘ready’ or ‘valid’ as
the name of a struct field.  This is because in the generated Verilog, a FIFO
object will introduce an AXI-stream interface associated with valid/ready
handshaking signals and the names will overlap.</p>
</div>
<p>You can use the C++ streaming library by including the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/streaming.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Users should always use the APIs below to create and access FIFOs. Any other uses of FIFOs are not supported in SmartHLS.</p>
</div>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Class Method</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">FIFO&lt;T&gt;</span> <span class="pre">()</span></code></td>
<td>Create a new FIFO.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">FIFO&lt;T&gt;</span> <span class="pre">(unsigned</span> <span class="pre">depth)</span></code></td>
<td>Create a new FIFO with the specified depth.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">write(T</span> <span class="pre">data)</span></code></td>
<td>Write <code class="docutils literal notranslate"><span class="pre">data</span></code> to the FIFO.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">read()</span></code></td>
<td>Read an element from the FIFO.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">empty()</span></code></td>
<td>Returns 1 if the FIFO is empty.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">bool</span> <span class="pre">full()</span></code></td>
<td>Returns 1 if the FIFO is full.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">setDepth(unsigned</span> <span class="pre">depth)</span></code></td>
<td>Set the FIFO’s depth.</td>
</tr>
</tbody>
</table>
<p>An example code for using the streaming library is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/streaming.hpp&gt;</span><span class="cp"></span>

<span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">my_fifo</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// write to the fifo</span>
    <span class="n">my_fifo</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">read_write</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">my_fifo</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">out_fifo</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="c1">// read from the fifo</span>
    <span class="kt">unsigned</span> <span class="n">data</span> <span class="o">=</span> <span class="n">my_fifo</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">();</span>
    <span class="n">out_fifo</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// declare a 32-bit wide fifo</span>
    <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">my_fifo</span><span class="p">;</span>
    <span class="c1">// set the fifo&#39;s depth to 10</span>
    <span class="n">my_fifo</span><span class="p">.</span><span class="n">setDepth</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="c1">// declare a 32-bit wide fifo with a depth of 10</span>
    <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">my_fifo_depth_10</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_fifo</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">read_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_fifo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_fifo_depth_10</span><span class="p">);</span>

    <span class="c1">// check if my_fifo is empty - should be empty since we read from it in</span>
    <span class="c1">// read_write (is_empty = 1)</span>
    <span class="kt">bool</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">my_fifo</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>

    <span class="c1">// check if my_fifo_depth_10 is empty - should not be empty since we write</span>
    <span class="c1">// to it in read_write (is_empty = 0)</span>
    <span class="kt">bool</span> <span class="n">is_second_empty</span> <span class="o">=</span> <span class="n">my_fifo_depth_10</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>

    <span class="c1">// We will use the fail variable to check for any failures. fail will become</span>
    <span class="c1">// 1 if is_empty != 1 and is_second_empty != 0</span>
    <span class="kt">int</span> <span class="n">fail</span> <span class="o">=</span> <span class="p">(</span><span class="n">is_empty</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="p">((</span><span class="n">is_second_empty</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
    <span class="c1">// If fail is 1, test will fail.</span>

    <span class="k">return</span> <span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As shown above, there are two ways of creating a FIFO (<code class="docutils literal notranslate"><span class="pre">hls::FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">hls::FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo_depth_10(10)</span></code>).
The width of the FIFO is determined based on the templated data type of the FIFO.
For example, <code class="docutils literal notranslate"><span class="pre">FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo</span></code> creates a FIFO that is 32 bits wide.
The FIFO’s data type can be any primitive type or arbitrary bitwidth types (ap_int/ap_uint/ap_fixpt/ap_ufixpt),
or a struct of primitive/arbitrary bitwidth types (or nested structs of those types) but
cannot be a pointer or an array (or a struct with a pointer/array).
An array or a struct of FIFOs is supported.</p>
<p>The depth of the FIFO can be provided by the user as a constructor argument
when the FIFO is declared, or it can also be set afterwards with the <code class="docutils literal notranslate"><span class="pre">setDepth(unsigned</span> <span class="pre">depth)</span></code> function.
If the depth is not provided by the user, SmartHLS uses a default FIFO depth of 2.
The depth of a FIFO can also be set to 0, in which case SmartHLS will create direct ready/valid/data wire connections (without a FIFO) between the source and the sink.</p>
<div class="section" id="streaming-library-blocking-behaviour">
<h4>Streaming Library - Blocking Behaviour<a class="headerlink" href="#streaming-library-blocking-behaviour" title="Permalink to this headline">¶</a></h4>
<p>Note that the fifo <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code> calls are blocking.
Hence if a module attempts to read from a FIFO that is empty, it will be stalled.
Similarly, if it attempts to write to a FIFO that is full, it will be stalled.
If you want non-blocking behaviour, you can check if the FIFO is
empty (with <code class="docutils literal notranslate"><span class="pre">empty()</span></code>) before calling <code class="docutils literal notranslate"><span class="pre">read()</span></code>, and likewise, check
if the FIFO is full (with <code class="docutils literal notranslate"><span class="pre">full()</span></code>) before calling <code class="docutils literal notranslate"><span class="pre">write()</span></code> (see <a class="reference internal" href="#streaming-lib-non-blocking"><span class="std std-ref">Streaming Library - Non-Blocking Behaviour</span></a>).</p>
<p>With the blocking behaviour, if the depths of FIFOs are not sized properly,
it can cause a deadlock. SmartHLS prints out messages to alert the user that
a FIFO is causing stalls.</p>
<p>In hardware simulation, the following messages are shown.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Warning: fifo_write<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being full.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_write<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being full.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
</pre></div>
</div>
<p>If you continue to see these messages, you can suspect that there may be a
deadlock. In this case, we recommend making sure there is no blocking read from
an empty FIFO or blocking write to a full FIFO, and potentially increasing the
depth of the FIFOs.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We recommend the minimum depth of a FIFO to be 2, as a depth of 1 FIFO can cause excessive stalls.</p>
</div>
</div>
<div class="section" id="streaming-library-non-blocking-behaviour">
<span id="streaming-lib-non-blocking"></span><h4>Streaming Library - Non-Blocking Behaviour<a class="headerlink" href="#streaming-library-non-blocking-behaviour" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, non-blocking FIFO behaviour can be created with the use of <code class="docutils literal notranslate"><span class="pre">empty()</span></code> and <code class="docutils literal notranslate"><span class="pre">full()</span></code> functions.
Non-blocking FIFO read and write can be achieved as shown below.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span>!fifo_a.empty<span class="o">())</span>
    unsigned <span class="nv">data_in</span> <span class="o">=</span> fifo_a.read<span class="o">()</span><span class="p">;</span>

<span class="k">if</span> <span class="o">(</span>!fifo_b.full<span class="o">())</span>
    fifo_b.write<span class="o">(</span>data_out<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A deadlock may occur if a fifo with a depth of 0 uses non-blocking write on its source and non-block read on its sink.</p>
</div>
</div>
</div>
<div class="section" id="c-arbitrary-precision-data-types-library">
<span id="ap-lib"></span><h3>C++ Arbitrary Precision Data Types Library<a class="headerlink" href="#c-arbitrary-precision-data-types-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Data Types Library provides numeric types <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code>, which can be used to specify data types of arbitrary bitwidths in software (e.g., ap_int&lt;9&gt; for a 9-bit integer variable).
These data types will be efficiently translated to create hardware with the exact widths. The data types also come with bit manipulation utilities, such as bit range selection and concatenation.</p>
</div>
<div class="section" id="c-arbitrary-precision-integer-library">
<span id="ap-int"></span><h3>C++ Arbitrary Precision Integer Library<a class="headerlink" href="#c-arbitrary-precision-integer-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> type allows specifying signed and unsigned data types of any bitwidth.
They can be used for arithmetic, concatenation, and bit level operations. You can use the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> type
by including the following header file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The desired width of the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> can be specified as a template parameter, <code class="docutils literal notranslate"><span class="pre">ap_[u]int&lt;W&gt;</span></code>,
allowing for wider types than the existing C arbitrary bit-width library.</p>
<p>An example using the C++ library is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="s">&quot;0123456789ABCDEF0123456789ABCDEF&quot;</span><span class="p">);</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If this four bit range of data is &lt;= 7</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="c1">// iostream doesn&#39;t synthesize to hardware, so only include this</span>
<span class="c1">// line in software compilation. Any block surrounded by this ifdef</span>
<span class="c1">// will be ignored when compiling to hardware.</span>
<span class="cp">#ifndef __SYNTHESIS__</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above code we iterate through a 128 bit unsigned integer in four bit segments,
and track the difference between how many segments are above and below 7.
All variables have been reduced to their specified minimum widths.</p>
<div class="section" id="printing-arbitrary-precision-integers">
<h4>Printing Arbitrary Precision integers<a class="headerlink" href="#printing-arbitrary-precision-integers" title="Permalink to this headline">¶</a></h4>
<p>The C++ Arbitrary Precision Integer Library provides some utilities for printing <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types. The <code class="docutils literal notranslate"><span class="pre">to_string(base,</span> <span class="pre">signedness)</span></code> function
takes an optional base argument (one of 2, 10, and 16) which defaults to 16, as well as an optional signedness argument which determines if the data
should be printed as signed or unsigned, which defaults to false. The output stream operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> is also overloaded to put arbitrary precision integer
types in the output stream as if they were called with the default <code class="docutils literal notranslate"><span class="pre">to_string</span></code> arguments.</p>
<p>Some example code using these utilities is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">ap_u</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">ap</span> <span class="o">=</span> <span class="o">-</span><span class="mi">22</span><span class="p">;</span>

    <span class="c1">// prints: 0x15</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ap_u = 0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ap_u</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// prints: -22</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ap.to_string(10,true) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ap</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// prints: 234</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ap.to_string(10) = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ap</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// prints 00010101</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;ap_u.to_string(2) = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap_u</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-arbitrary-precision-integers">
<h4>Initializing Arbitrary Precision integers<a class="headerlink" href="#initializing-arbitrary-precision-integers" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types can be constructed and assigned to from other arbitrary precision integers, C++ integral
types, <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types, as well as concatenations and bit selections. They can also be initialized from a hexadecimal
string describing the exact bits.</p>
<p>Some examples of initializing arbitrary precision integer types are show below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

    <span class="c1">//...</span>
    <span class="c1">// Initialized to -7</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">7</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int1 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Initialized to 15</span>
    <span class="c1">// The bits below the decimal are truncated.</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int2</span> <span class="o">=</span> <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">AP_RND</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">15.5</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int2 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Initialized to 132</span>
    <span class="c1">// Could also write &quot;0x84&quot;</span>
    <span class="c1">// The 0x is optional</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">int3</span><span class="p">(</span><span class="s">&quot;84&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int3 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Initialized to 4</span>
    <span class="c1">// Bit selections are zero extended to match widths</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int4</span> <span class="o">=</span> <span class="n">int3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int4 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Initialized to 128</span>
    <span class="c1">// ap_uint types are zero extended to match widths</span>
    <span class="c1">// ap_int types are sign extended to match widths</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">int5</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;80&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int5 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Initialized to 2</span>
    <span class="c1">// The value 4098 (= 4096 + 2) is wrapped to 2</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">int6</span> <span class="o">=</span> <span class="mi">4098</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;int6 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">int6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="c-arbitrary-precision-integer-arithmetic">
<h4>C++ Arbitrary Precision Integer Arithmetic<a class="headerlink" href="#c-arbitrary-precision-integer-arithmetic" title="Permalink to this headline">¶</a></h4>
<p>The C++ Arbitrary Precision Integer library supports all standard arithmetic, logical bitwise, shifts, and comparison operations.
Note that for shifting that &gt;&gt; and &lt;&lt; are logical, and the .ashr(x) function implements arithmetic right shift.
The output types of an operation are wider than their operands as necessary to hold the result. Operands of ap_int, and ap_uint type,
as well as operands of different widths can be mixed freely.
By default ap_int will be sign extended to the appropriate width for an operation,
while ap_uint will be zero extended. When mixing ap_int and ap_uint in an arithmetic operation
the resulting type will always be ap_int. Some of this behaviour is demonstrated in the example below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

    <span class="c1">//...</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// Multiply expands to the sum of a and b&#39;s width</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;d = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Add result in max of widths + 1</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;e = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Logical bitwise ops result in max of widths</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Mixing ap_int and ap_uint results in ap_int</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;g = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// ap_(u)int types can be mixed freely with integral types</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">33</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;h = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">h</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="c-arbitrary-precision-integer-explicit-conversions">
<h4>C++ Arbitrary Precision Integer Explicit Conversions<a class="headerlink" href="#c-arbitrary-precision-integer-explicit-conversions" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types support several explicit conversion functions which allow the value to be interpreted in different ways.
The <code class="docutils literal notranslate"><span class="pre">to_uint64()</span></code> function will return a 64 bit <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> with the same bits as the original <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code>, zero extending
and wrapping as necessary. Assigning an <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> wider than 64 bits to an <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> would also wrap to match widths,
without needing to call <code class="docutils literal notranslate"><span class="pre">to_uint64()</span></code>. The <code class="docutils literal notranslate"><span class="pre">to_int64()</span></code> function will return a 64 bit <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> and will sign extend as necessary.</p>
<p>An arbitrary precision integer data type can be casted to an arbitrary precision fixed-point data type with the <code class="docutils literal notranslate"><span class="pre">to_fixpt&lt;I_W&gt;()</span></code> and <code class="docutils literal notranslate"><span class="pre">to_ufixpt&lt;I_W&gt;()</span></code> functions (returns <code class="docutils literal notranslate"><span class="pre">ap_fixpt&lt;W,</span> <span class="pre">I_W&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_ufixpt&lt;W,</span> <span class="pre">I_W&gt;</span></code> types respectively), with the same bits as the original <code class="docutils literal notranslate"><span class="pre">ap_[u]int&lt;W&gt;</span></code>.
For more on the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> template, please refer to the <a class="reference internal" href="#ap-fixpt"><span class="std std-ref">C++ Arbitrary Precision Fixed Point Library</span></a> section.</p>
<p>An example demonstrating these functions is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

    <span class="c1">//...</span>
    <span class="c1">// zero extend 16 bit -32768 to 64 bit 32768</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">32768</span><span class="p">).</span><span class="n">to_uint64</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// wrap from 65 bit 2**64 + 1 to 64 bit 1</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">B</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">65</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;10000000000000001&quot;</span><span class="p">).</span><span class="n">to_uint64</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;B = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">B</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// interpret 8 bit uint as 8 bit ufixpt with four bits above decimal</span>
    <span class="c1">// by value 248 becomes 15.5 (== 248 / 2**4)</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">248</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;C = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">C</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// interpret 4 bit int as 4 bit fixpt with leading bit 8 bits above decimal</span>
    <span class="c1">// by value -8 becomes -128 (== -8 * 2**4)</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">8</span><span class="p">).</span><span class="n">to_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;D = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">D</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// interpret 6 bit int as 6 bit ufixpt with 6 bits above decimal</span>
    <span class="c1">// by value 8 becomes 8</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;E = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">E</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="c-arbitrary-precision-bit-level-operations">
<h3>C++ Arbitrary Precision Bit-level Operations<a class="headerlink" href="#c-arbitrary-precision-bit-level-operations" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Library provides utilities to select, and update ranges of arbitrary precision data,
as well as perform concatenation.</p>
<p>Bit selection and updating is defined for all C++ arbitrary precision numeric types. Concatenation is defined on all
C++ Arbitrary Precision Library constructs including arbitrary precision numeric types, as well as bit selections, and other concatenations.</p>
<div class="section" id="selecting-and-assigning-to-a-range-of-bits">
<h4>Selecting and Assigning to a Range of Bits<a class="headerlink" href="#selecting-and-assigning-to-a-range-of-bits" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

    <span class="c1">//...</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">Aa</span><span class="p">(</span><span class="mh">0xBC</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Aa = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Aa</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">Bb</span> <span class="o">=</span> <span class="n">Aa</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// Bb initialized as 0xB; &quot;Aa(7, 4)&quot; is equivalent</span>
                             <span class="c1">// to &quot;Aa.range(7, 4)&quot;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Bb = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Bb</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">Cc</span> <span class="o">=</span> <span class="n">Aa</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// Cc initialized as 0x1</span>
                          <span class="c1">// Aa[2] is zero extended to match widths</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cc = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cc</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Aa</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span>
        <span class="mh">0xA</span><span class="p">;</span> <span class="c1">// Aa becomes 0xBA; &quot;Aa(3, 0) is equivalent to &quot;Aa.range(3, 0)&quot;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Aa = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Aa</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Aa</span><span class="p">.</span><span class="n">byte</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xC</span><span class="p">;</span> <span class="c1">// Aa becomes 0xCA;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Aa = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Aa</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">Aa</span><span class="p">.</span><span class="n">bytes</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xD</span><span class="p">;</span> <span class="c1">// AA becomes 0xDA</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Aa = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Aa</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>On C++ arbitrary precision types <code class="docutils literal notranslate"><span class="pre">num(a,</span> <span class="pre">b)</span></code> (or <code class="docutils literal notranslate"><span class="pre">num.range(a,</span> <span class="pre">b)</span></code>) will select and create a reference to the underlying arbitrary precision value.
The operator <code class="docutils literal notranslate"><span class="pre">num[a]</span></code> selects and creates a reference to a single bit.
This reference can be assigned to, and used to access the underlying data.
The arbitrary precision <code class="docutils literal notranslate"><span class="pre">num.byte(n,</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">8)</span></code> function selects and creates a
reference to the <code class="docutils literal notranslate"><span class="pre">n-th</span></code> byte of the number which can be assigned to and used
to access the underlying data. Similarly, the <code class="docutils literal notranslate"><span class="pre">num.bytes(m,</span> <span class="pre">n,</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">8)</span></code>
function selects and creates a reference to a range of bytes from the
<code class="docutils literal notranslate"><span class="pre">m-th</span></code> to the <code class="docutils literal notranslate"><span class="pre">n-th</span></code> byte (inclusive) of the number. In both functions, the
last argument is an optional argument which defines the number of bits per byte,
and defaults to 8.</p>
</div>
<div class="section" id="bit-concatenation">
<h4>Bit Concatenation<a class="headerlink" href="#bit-concatenation" title="Permalink to this headline">¶</a></h4>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>
    <span class="c1">//...</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">AA</span><span class="p">(</span><span class="mh">0xA</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;AA = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AA</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">BB</span><span class="p">(</span><span class="mh">0xCB</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;BB = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">BB</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">AB</span><span class="p">((</span><span class="n">AA</span><span class="p">,</span> <span class="n">BB</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)));</span> <span class="c1">// AB initialized as 0xAB</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;AB = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">AB</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">ABC</span><span class="p">(</span>
        <span class="p">(</span><span class="n">AA</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0xB</span><span class="p">),</span> <span class="n">BB</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">)));</span> <span class="c1">// ABC initialized as 0xABC</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;ABC = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ABC</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Putting any C++ arbitrary precision types in a comma separated list will generate a concatenation.
The concatenation can currently be used to create arbitrary precision types (zero extending or truncating to match widths), but can not be assigned to.</p>
</div>
</div>
<div class="section" id="c-arbitrary-precision-fixed-point-library">
<span id="ap-fixpt"></span><h3>C++ Arbitrary Precision Fixed Point Library<a class="headerlink" href="#c-arbitrary-precision-fixed-point-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Fixed Point library provides fast bit accurate software simulation, and efficient equivalent
hardware generation. The C++ <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types allow specifying signed and unsigned fixed point numbers of arbitrary width,
and arbitrary fixed position relative to the decimal. They can be used
for arithmetic, concatenation, and bit level operations. You can use the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> type by including the
following header file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> template allows specifying the width of the type, how far the most significant bit is above the decimal,
as well as several quantization and overflow modes.</p>
<p>Quantization and overflow handling is triggered during assignment and construction.
The policies used for quantization and overflow are based on the quantization and overflow modes of the
left hand side of an assignment, or of the value being constructed.</p>
<p>The template <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt&lt;W,</span> <span class="pre">I_W,</span> <span class="pre">Q_M,</span> <span class="pre">O_M&gt;</span></code> is described in the following table. The last two template parameters are optional.</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="23%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter</th>
<th class="head" colspan="2">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>W</td>
<td colspan="2">The width of the word in bits.</td>
</tr>
<tr class="row-odd"><td>I_W</td>
<td colspan="2"><p class="first">How far the most significant bit is above the decimal.
I_W can be negative. I_W &gt; 0 implies the MSB is above the
decimal. I_W &lt;= 0 implies the MSB is below the decimal.</p>
<p class="last">If W &gt;= I_W &gt;= 0, then I_W is the number of bits used for
the integer portion.</p>
</td>
</tr>
<tr class="row-even"><td rowspan="8">Q_M</td>
<td colspan="2"><p class="first">The Quantization(rounding) mode used when a result has
precision below the least significant bit.</p>
<p class="last">Defaults to AP_TRN.</p>
</td>
</tr>
<tr class="row-odd"><td>AP_TRN</td>
<td>Truncate bits below the LSB bringing the
result closer to -∞.</td>
</tr>
<tr class="row-even"><td>AP_TRN_ZERO</td>
<td>Truncate bits below the LSB bringing the
result closer to zero.</td>
</tr>
<tr class="row-odd"><td>AP_RND</td>
<td>Round to the nearest representable value
with the midpoint going towards +∞.</td>
</tr>
<tr class="row-even"><td>AP_RND_INF</td>
<td>Round to the nearest representable value
with the midpoint going towards -∞ for
negative numbers, and +∞ for positive
numbers.</td>
</tr>
<tr class="row-odd"><td>AP_RND_MIN_INF</td>
<td>Round to the nearest representable value
with the midpoint going towards -∞.</td>
</tr>
<tr class="row-even"><td>AP_RND_ZERO</td>
<td>Round to the nearest representable value
with the midpoint going towards 0.</td>
</tr>
<tr class="row-odd"><td>AP_RND_CONV</td>
<td>Round to the nearest representable value
with the midpoint going towards the
nearest even multiple of the quantum.
(This helps to remove bias in rounding).</td>
</tr>
<tr class="row-even"><td rowspan="5">O_M</td>
<td colspan="2"><p class="first">The Overflow mode used when a result exceeds the maximum or
minimum representable value.</p>
<p class="last">Defaults to AP_WRAP.</p>
</td>
</tr>
<tr class="row-odd"><td>AP_WRAP</td>
<td>Wraparound between the minimum and maximum
representable values in the range.</td>
</tr>
<tr class="row-even"><td>AP_SAT</td>
<td>On positive and negative overflow saturate
the result to the maximum or minimum value
in the range respectively.</td>
</tr>
<tr class="row-odd"><td>AP_SAT_ZERO</td>
<td>On any overflow set the result to zero.</td>
</tr>
<tr class="row-even"><td>AP_SAT_SYM</td>
<td><p class="first">On positive and negative overflow saturate
the result to the maximum or minimum value
in the range symmetrically about zero.</p>
<p class="last">For ap_ufixpt this is the same as AP_SAT.</p>
</td>
</tr>
</tbody>
</table>
<p>An <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> is a W bit wide integer, in 2’s complement for the signed case, which
has some fixed position relative to the decimal. This means that arithmetic is efficiently
implemented as integer operations with some shifting to line up decimals. Generally a
fixed point number can be thought of as a signed or unsigned integer word multiplied by 2^(I_W - W).
The range of values that an <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> can take on, as well as the quantum that
separates those values is determined by the W, and I_W template parameters. The AP_SAT_SYM
overflow mode forces the range to be symmetrical about zero for signed fixed point types.
This information is described in the following table. Q here represents the quantum.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="25%" />
<col width="30%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Type</td>
<td>Quantum</td>
<td>Range</td>
<td>AP_SAT_SYM Range</td>
</tr>
<tr class="row-even"><td>ap_ufixpt</td>
<td>2^(I_W - W)</td>
<td><p class="first">0</p>
<p>to</p>
<p class="last">2^(I_W) - Q</p>
</td>
<td><p class="first">0</p>
<p>to</p>
<p class="last">2^(I_W) - Q</p>
</td>
</tr>
<tr class="row-odd"><td>ap_fixpt</td>
<td>2^(I_W - W)</td>
<td><p class="first">-2^(I_W - 1)</p>
<p>to</p>
<p class="last">2^(I_W - 1) - Q</p>
</td>
<td><p class="first">-2^(I_W - 1) + Q</p>
<p>to</p>
<p class="last">2^(I_W - 1) - Q</p>
</td>
</tr>
</tbody>
</table>
<p>Some <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> ranges are demonstrated in the following table.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="28%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Type</td>
<td>Quantum</td>
<td>Range</td>
</tr>
<tr class="row-even"><td>ap_fixpt&lt;8, 4&gt;</td>
<td>0.0625</td>
<td>-8 to 7.9375</td>
</tr>
<tr class="row-odd"><td>ap_ufixpt&lt;4, 12&gt;</td>
<td>256</td>
<td>0 to 3840</td>
</tr>
<tr class="row-even"><td>ap_ufixpt&lt;4, -2&gt;</td>
<td>0.015625</td>
<td>0 to 0.234375</td>
</tr>
</tbody>
</table>
<p>An example using <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> is show below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/streaming.hpp&quot;</span><span class="cp"></span>

<span class="cp">#define TAPS 8</span>

<span class="c1">// A signed fixed point type with 10 integer bits and 6 fractional bits</span>
<span class="c1">// It employs convergent rounding for quantization, and saturation for overflow.</span>
<span class="k">typedef</span> <span class="n">hls</span><span class="o">::</span><span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">AP_RND_CONV</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">fixpt_t</span><span class="p">;</span>

<span class="c1">// A signed fixed point type with 3 integer bits and 1 fractional bit</span>
<span class="c1">// It uses the default truncation, and wrapping modes.</span>
<span class="k">typedef</span> <span class="n">hls</span><span class="o">::</span><span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fixpt_s_t</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">fir</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">fixpt_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">fixpt_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS function pipeline</span>
    <span class="n">fixpt_t</span> <span class="n">in</span> <span class="o">=</span> <span class="n">input_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

    <span class="k">static</span> <span class="n">fixpt_t</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">const</span> <span class="n">fixpt_s_t</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">previous</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

    <span class="n">fixpt_t</span> <span class="n">accumulate</span><span class="p">[</span><span class="n">TAPS</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TAPS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">accumulate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Accumulate results, doing adds and saturation in</span>
    <span class="c1">// a binary tree to reduce the number of serial saturation</span>
    <span class="c1">// checks. This significantly improves pipelining results</span>
    <span class="c1">// over serially adding results together when saturation</span>
    <span class="c1">// is required.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">TAPS</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">accumulate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">accumulate</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">output_fifo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">accumulate</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example implements a streaming FIR filter with 8 taps. Using the minimum width <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> to represent
the constant coefficients allows the multiply to happen at a smaller width than if they were the same (wider)
type as the inputs. This example ensures that no overflows occur by always assigning to an <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> that uses the AP_SAT
overflow mode. This does incur a performance penalty, but this is minimized here by accumulating the results in a binary
fashion, such that there are only log(TAPS) = 3 saturating operations that depend on each other. If the results were
accumulated in a single variable in one loop then there would be TAPS = 8 saturating operations depending on each other.
Having more saturating operations in a row is slower because at each step overflow needs to be checked before the next
operation can occur.</p>
<div class="section" id="printing-ap-u-fixpt-types">
<h4>Printing ap_[u]fixpt Types<a class="headerlink" href="#printing-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The Arbitrary Precision Fixed Point Library provides some utilities for printing <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types in software, demonstrated below.
The <code class="docutils literal notranslate"><span class="pre">to_fixpt_string(base,</span> <span class="pre">signedness)</span></code> function takes an optional base argument which is one of 2, 10, or 16, and defaults to 10,
as well as an optional signedness argument which determines if the data should be treated as signed or unsigned. The signedness argument defaults to false
for ap_ufixpt, and true for ap_fixpt.</p>
<p>The output stream operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> can be used to put a fixed point number into an output stream
as if it were called with the default <code class="docutils literal notranslate"><span class="pre">to_fixpt_string</span></code> arguments.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">to_double()</span></code> function can be useful for printing, but it can lose precision over a wide fixed point. It can be used
in hardware, but this is expensive, and should be avoided when possible.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

    <span class="c1">//...</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed</span> <span class="o">=</span> <span class="mf">12.75</span><span class="p">;</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">s_fixed</span><span class="p">(</span><span class="s">&quot;CC&quot;</span><span class="p">);</span>

    <span class="c1">// prints: -52 * 2^-4</span>
    <span class="c1">// Read -52 * 0.0625 = -3.25</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s_fixed</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// prints: 11001100 * 2^-4</span>
    <span class="c1">// Read unsigned 11001100 * 2^-4 = 204 * 0.0625</span>
    <span class="c1">// = 12.75</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fixed</span><span class="p">.</span><span class="n">to_fixpt_string</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>

    <span class="c1">// prints: CC * 2^-4</span>
    <span class="c1">// Read signed CC * 2^-4 = -52 * 0.0625</span>
    <span class="c1">// = -3.25</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s_fixed</span><span class="p">.</span><span class="n">to_fixpt_string</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// prints: -3.25</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s_fixed</span><span class="p">.</span><span class="n">to_double</span><span class="p">());</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-ap-u-fixpt-types">
<h4>Initializing ap_[u]fixpt Types<a class="headerlink" href="#initializing-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types can be constructed and assigned from other fixed points, the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types, C++ integer and floating
point types, as well as concatenations and bit selections. They can also be initialized from a hexadecimal string describing the exact
bits. Note that construction and assignment will always trigger the quantization and overflow handling of the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> being constructed or assigned to,
except when copying from the exact same type, or initializing from a hexadecimal string. For logical assignments of bits, bit selection assignments can be used, as well as
the <code class="docutils literal notranslate"><span class="pre">from_raw_bits</span></code> function, or the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> <code class="docutils literal notranslate"><span class="pre">to_fixpt&lt;I_W&gt;()</span></code> functions in the case of <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Initializing <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types from floating point types in hardware is expensive, and should be avoided when possible. However, initializing
<code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> from floating point literals is free, and happens at compile time.</p>
</div>
<p>Some examples of initializing fixed point types are shown in the following code snippet.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>


    <span class="c1">//...</span>
    <span class="c1">// Initialized to -13.75</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed1</span> <span class="o">=</span> <span class="o">-</span><span class="mf">13.75</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed1 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to 135</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">fixed2</span> <span class="o">=</span> <span class="mi">135</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed2 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed2</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to -112</span>
    <span class="c1">// Could also write &quot;0x9&quot;</span>
    <span class="c1">// 0x is optional</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">fixed3</span><span class="p">(</span><span class="s">&quot;9&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed3 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed3</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to 14</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed4</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed4 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed4</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to -1 (AP_SAT triggered)</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AP_TRN</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">fixed5</span> <span class="o">=</span> <span class="o">-</span><span class="mi">4</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed5 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed5</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to 1.5 (AP_RND triggered)</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">AP_RND</span><span class="o">&gt;</span> <span class="n">fixed6</span> <span class="o">=</span> <span class="mf">1.25</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed6 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed6</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialized to 15.75 from a logical string of bits</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed7</span><span class="p">;</span>
    <span class="n">fixed7</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;FC&quot;</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed7 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed7</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Assign an existing ap_uint variable to an ap_ufixpt variable</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">ap_uint_var</span> <span class="o">=</span> <span class="mi">15</span><span class="p">;</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed8</span><span class="p">;</span>
    <span class="n">fixed8</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ap_uint_var</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed8 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed8</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialize to 13 from a logical string of bits</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">fixed9</span><span class="p">;</span>
    <span class="n">fixed9</span><span class="p">.</span><span class="n">from_raw_bits</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">26</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed9 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed9</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialize to -32 from a logical string of bits</span>
    <span class="c1">// (First convert ap_uint&lt;4&gt; to ap_fixpt&lt;4, 6&gt; logically,</span>
    <span class="c1">// then perform fixed point assignment)</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">fixed10</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">).</span><span class="n">to_fixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed10 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed10</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Initialize to 32 from a logical string of bits</span>
    <span class="c1">// (First convert ap_int&lt;4&gt; to ap_ufixpt&lt;4, 6&gt; logically,</span>
    <span class="c1">// then perform fixed point assignment)</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">fixed11</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;fixed11 = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">fixed1</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="arithmetic-with-ap-u-fixpt-types">
<h4>Arithmetic With ap_[u]fixpt Types<a class="headerlink" href="#arithmetic-with-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The Arbitrary Precision Fixed Point library supports all standard arithmetic, logical bitwise, shifts, and comparison
operations. During arithmetic intermediate results are kept in a wide enough type to hold all of the possible resulting values. Operands
are shifted to line up decimal points, and sign or zero extended to match widths before an operation is performed. For fixed
point arithmetic, whenever the result of a calculation can be negative the intermediate type is an <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ap_ufixpt</span></code>
regardless of whether any of the operands were ap_fixpt.
Overflow and quantization handling only happen when the result is assigned to a fixed point type.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Overflow and quantization handling is not performed for any assigning shifting operations (&lt;&lt;=, &gt;&gt;=) on <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types.
Also, non-assigning shifts (&lt;&lt;, &gt;&gt;, .ashr(x)) do not change the width or type of the fixed point they are applied to. This means that bits can be shifted out of
range.</p>
</div>
<p>Fixed point types can be mixed freely with other arbitrary precision and c++ numeric types for arithmetic, logical bitwise, and comparison operations,
with some caveats for floating point types.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For arithmetic and logical bitwise operations floating point types <strong>must</strong> be explicitly cast to an <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> type before
being used, because of the wide range of possible values the floating point type could represent. It is also a good idea, but not required, to
use <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types in place of C++ integers when less width is required.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For convenience floating point types can be used directly in fixed point comparisons, however floating points are truncated
and wrapped as if they were assigned to a signed <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> just big enough to hold all values of the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code>
type being compared against, with the AP_TRN and AP_WRAP modes on.</p>
</div>
<p>An example demonstrating some of this behaviour is show below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>


    <span class="c1">//...</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">65</span><span class="p">,</span> <span class="mi">14</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">32.5714285713620483875274658203125</span><span class="p">;</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="mf">3.125</span><span class="p">;</span>

    <span class="c1">// the resulting type is wide enough to hold all</span>
    <span class="c1">// 51 fractional bits of a, and 15 integer bits of b</span>
    <span class="c1">// the width, and integer width are increased by 1 to hold</span>
    <span class="c1">// all possible results of the addition</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">67</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 39.5714285713620483875274658203125</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;d = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// the resulting type is a signed fixed point</span>
    <span class="c1">// with width, and integer width that are the sum</span>
    <span class="c1">// of the two operands&#39; widths</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">23</span><span class="p">,</span> <span class="mi">19</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// -21.875</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;e = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Assignment triggers the AP_TRN_ZERO quantization mode</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">AP_TRN_ZERO</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// -21.5</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Mask out bits above the decimal</span>
    <span class="n">f</span> <span class="o">&amp;=</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="c1">// -22</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">f</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="c1">// Assignment triggers the AP_SAT overflow mode,</span>
    <span class="c1">// and saturates the negative result to 0</span>
    <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">AP_TRN</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 0</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;g = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">g</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="explicit-conversions-of-ap-u-fixpt">
<h4>Explicit Conversions of ap_[u]fixpt<a class="headerlink" href="#explicit-conversions-of-ap-u-fixpt" title="Permalink to this headline">¶</a></h4>
<p>There are several functions to explicitly convert <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types into other types, besides value based assignments. The <code class="docutils literal notranslate"><span class="pre">raw_bits</span></code> function produces a uint of
the same width as the ap_[u]fixpt with the same raw data, and to_double returns a double representing the value of the ap_[u]fixpt. Note that
for wide enough ap_[u]fixpt to_double can lose precision, and can be inefficient in hardware. These are demonstrated in the
following code snippet.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>


    <span class="c1">//...</span>
    <span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">ffixed</span><span class="p">(</span><span class="s">&quot;898&quot;</span><span class="p">);</span>

    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">logical_fixed</span> <span class="o">=</span> <span class="n">ffixed</span><span class="p">.</span><span class="n">raw_bits</span><span class="p">();</span>
    <span class="n">logical_fixed</span> <span class="o">==</span> <span class="mh">0x898</span><span class="p">;</span> <span class="c1">// true</span>

    <span class="kt">double</span> <span class="n">double_fixed</span> <span class="o">=</span> <span class="n">ffixed</span><span class="p">.</span><span class="n">to_double</span><span class="p">();</span>
    <span class="n">double_fixed</span> <span class="o">==</span> <span class="o">-</span><span class="mf">14.8125</span><span class="p">;</span> <span class="c1">// true</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point">
<h3>Supported Operations in ap_[u]int, ap_[u]fixpt, and floating-point<a class="headerlink" href="#supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point" title="Permalink to this headline">¶</a></h3>
<p>The table below shows all the standard arithmetic operations that are supported in
our Arbitrary Precision Integer and Fixed Point Libraries as well as for
floating-point data types. It also shows some useful APIs that can be used to
convert from one type to another or to convert to standard integral types or strings.</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="28%" />
<col width="19%" />
<col width="13%" />
<col width="15%" />
<col width="12%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Type</td>
<td>Operator</td>
<td>Description</td>
<td>ap_[u]int</td>
<td>ap_[u]fixpt</td>
<td>floating</td>
</tr>
<tr class="row-even"><td rowspan="7">Arithmetic</td>
<td>+</td>
<td>Addition</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>Subtraction</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>*</td>
<td>Multiplication</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>/</td>
<td>Division</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>%</td>
<td>Modulo</td>
<td>Y</td>
<td>Y</td>
<td>Note Below</td>
</tr>
<tr class="row-odd"><td>++</td>
<td>Increment</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>–</td>
<td>Decrement</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td rowspan="11">Assignment</td>
<td>=</td>
<td>Assignment</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>+=</td>
<td>Add and assign</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>-=</td>
<td>Sub and assign</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>*=</td>
<td>Mult and assign</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>/=</td>
<td>Div and assign</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>%=</td>
<td>Mod and assign</td>
<td>Y</td>
<td>Y</td>
<td>Note Below</td>
</tr>
<tr class="row-odd"><td>&amp;=</td>
<td>bitwise AND
and assign</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>|=</td>
<td>Bitwise OR
and assign</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>^=</td>
<td>Bitwise XOR
and assign</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>&gt;&gt;=</td>
<td>SHR and assign</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>&lt;&lt;=</td>
<td>SHL and assign</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td rowspan="6">Comparison</td>
<td>==</td>
<td>Equal to</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>!=</td>
<td>Not equal to</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>&gt;</td>
<td>Greater than</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>&lt;</td>
<td>Less than</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td>&gt;=</td>
<td>Greater than
or equal to</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-odd"><td>&lt;=</td>
<td>Less than
or equal to</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr class="row-even"><td rowspan="5">Bitwise</td>
<td>&amp;</td>
<td>Bitwise AND</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>^</td>
<td>Bitwise XOR</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>|</td>
<td>Bitwise OR</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>~</td>
<td>Bitwise Not</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>.or_reduce()</td>
<td>Bitwise OR
reduction</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td rowspan="3">Shift</td>
<td>&lt;&lt;</td>
<td>Shift left</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>&gt;&gt;</td>
<td>Shift right</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>.ashr(ap_uint numbits)</td>
<td>Arithmetic
shift right</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td rowspan="6">Bit level
access</td>
<td>num(a, b)</td>
<td>Range
selection</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>num.range(a, b)</td>
<td>Range
selection</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>num[a]</td>
<td>Bit
selection</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>num.byte(n, s = 8)</td>
<td>Select <code class="docutils literal notranslate"><span class="pre">n-th</span></code>
byte with
<code class="docutils literal notranslate"><span class="pre">s</span></code> bits per
byte</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>num.bytes(m, n, s = 8)</td>
<td>Select <code class="docutils literal notranslate"><span class="pre">m-th</span></code>
to <code class="docutils literal notranslate"><span class="pre">n-th</span></code>
byte
(inclusive)
with <code class="docutils literal notranslate"><span class="pre">s</span></code>
bits per byte</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>(numa, numb, numc)</td>
<td>Concat</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td rowspan="7">Explicit
Conversion</td>
<td>.to_ufixpt()</td>
<td>Convert to
ap_ufixpt</td>
<td>Y</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>.to_fixpt()</td>
<td>Convert to
ap_fixt</td>
<td>Y</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>.to_uint64()</td>
<td>Convert to
uint64</td>
<td>Y</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>.to_int64()</td>
<td>Convert to
int64</td>
<td>Y</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>.raw_bits()</td>
<td>Convert to
raw bits</td>
<td>N/A</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>.from_raw_bits()</td>
<td>Convert from
raw bits</td>
<td>N/A</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>.to_double()</td>
<td>Convert to
double</td>
<td>N/A</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td rowspan="2">String
Conversion</td>
<td>.to_fixpt_string()</td>
<td>Convert to
fixpt string</td>
<td>N/A</td>
<td>Y</td>
<td>N/A</td>
</tr>
<tr class="row-even"><td>.to_string()</td>
<td>Convert to
int string</td>
<td>Y</td>
<td>Y</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>To use floating point remainder, call the <code class="docutils literal notranslate"><span class="pre">fmod</span></code> or <code class="docutils literal notranslate"><span class="pre">fmodf</span></code> function from the &lt;math.h&gt; header.</p>
<p class="last">Note that the floating-point remainder core can be very large when used in a pipeline, so it should be
used with care. For the same reason, floating point remainder is only directly supported for
the float type. For double, the inputs to the core will be cast down to float,
and the result will be cast back to double. This can result in a loss of precision,
or incorrect results when the double input is not representable in the range of float.</p>
</div>
</div>
<div class="section" id="c-double-buffer-and-shared-buffer">
<span id="data-buffer"></span><h3>C++ Double Buffer and Shared Buffer<a class="headerlink" href="#c-double-buffer-and-shared-buffer" title="Permalink to this headline">¶</a></h3>
<p>With SmartHLS’ <a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading</span></a> feature, users can create a dataflow design where producer and consumer functions/threads execute simultaneously with data flowing from producer to consumer (also see <a class="reference internal" href="#data-flow-parallelism-with-pthreads"><span class="std std-ref">Data Flow Parallelism with SmartHLS Threads</span></a>).
Multi-threaded dataflow designs typically need some form of buffering and handshaking to pass intermediate data from producer thread to consumer thread.
For example, SmartHLS’ <a class="reference internal" href="#streaming-lib"><span class="std std-ref">FIFO</span></a> class allows to buffer intermediate data and the blocking <code class="docutils literal notranslate"><span class="pre">write()</span></code> and <code class="docutils literal notranslate"><span class="pre">read()</span></code> methods implement the handshaking for data passing.
However, the FIFO construct is not suitable for the scenarios where the producer and consumer access the data in different orders, or require repeated accesses to the data.
In this case, SmartHLS’ <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> classes can be useful alternatives.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">DoubleBuffer&lt;T&gt;</span></code> (or <code class="docutils literal notranslate"><span class="pre">SharedBuffer&lt;T&gt;</span></code>) class contains two copies of storage (or one copy for <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>) for buffering the data of type <code class="docutils literal notranslate"><span class="pre">T</span></code>, which is specified as a template argument of the class.
Each class object is expected to be accessed by two functions, typically two threads, one producer writing data to the buffer, and one consumer reading data from the buffer.
The producer and consumer functions will use the following class methods to access the buffer and perform synchronization,</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td colspan="2">Producer Side Methods</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&amp;producer()</span></code></td>
<td>Returns a reference to the buffer that should be used exclusively by the producer function.
The reference stays unchanged throughout the entire lifetime of the buffer object.
Hence the producer function typically only needs to call this method once.
Although the producer function is meant to store output to the buffer,
the producer function can still read back the self-written data via the reference.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">producer_acquire()</span></code></td>
<td>Acquires a buffer for producer to store the output.
After this function returns, the producer may start writing to the buffer.
This method is a blocking call – if there is an available buffer, the method returns immediately;
otherwise the method blocks until a buffer becomes available, after the consumer
side calls the <code class="docutils literal notranslate"><span class="pre">consumer_release()</span></code> method to release a buffer.
Initially all buffers (2 for <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code>, 1 for <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>) are available for the producer function to acquire.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">producer_release()</span></code></td>
<td>Releases the previously acquired buffer after finish writing output.
The released buffer can then be acquired by the consumer to access as input.
This method is not a blocking call and returns immediately.
If the producer does not have an acquired buffer when calling this release method,
the method simply returns with no operation, no buffer will be released.</td>
</tr>
<tr class="row-odd"><td colspan="2">Consumer Side Methods</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">&amp;consumer()</span></code></td>
<td>Returns a reference to the buffer that should be used exclusively by the consumer function.
The reference stays unchanged throughout the entire lifetime of the buffer object.
Hence the consumer function typically only needs to call this method once.
Although the consumer function is meant to read the buffer as input,
the consumer function can also write data to the buffer via the reference.
However the data written by the consumer function won’t be visible to the producer function.</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">consumer_acquire()</span></code></td>
<td>Acquires a producer-released buffer in the <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> or <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> for the consumer to access as input.
This method is a blocking call – if there is a producer-released buffer available, the method returns immediately;
otherwise the method blocks until a buffer becomes available, after the producer
side calls the <code class="docutils literal notranslate"><span class="pre">producer_release()</span></code> method to release a buffer.</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">consumer_release()</span></code></td>
<td>Releases the previously acquired buffer after finish reading input.
The released buffer is returned back to the producer side for producer to write the next set of data.
This method is not a blocking call and returns immediately.
If the consumer does not have an acquired buffer when calling this release method,
the method simply returns with no operation, no buffer will be released.</td>
</tr>
</tbody>
</table>
<p>Let’s use an example to illustrate the usage of these class methods.
Say we have a <code class="docutils literal notranslate"><span class="pre">CopyArray</span></code> function that copies from array A to array B.
If we want to overlap <code class="docutils literal notranslate"><span class="pre">CopyArray</span></code> function’s execution with its upstream function (who produces A) and downstream function (who consumes B),
we can invoke the upstream, <code class="docutils literal notranslate"><span class="pre">CopyArray</span></code> and downstream functions as threads, and change the intermediate arrays to <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> data type to implement shared storage and synchronization between threads.
The <code class="docutils literal notranslate"><span class="pre">CopyArray</span></code> function would be the consumer of input array A and the producer of output array B.
The code below demonstrates the changes to access input and output arrays as <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> type.
To use <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> instead, the only change in the code below is to use <code class="docutils literal notranslate"><span class="pre">SharedBuffer&lt;int[100]&gt;</span></code>; all other class methods stay the same.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">CopyArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="kt">int</span> <span class="n">B</span><span class="p">[</span><span class="mi">100</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//=== Change to use DoubleBuffer: ===</span>

<span class="kt">void</span> <span class="nf">CopyArray</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">BufferA</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="mi">100</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">BufferB</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">A</span> <span class="o">=</span> <span class="n">BufferA</span><span class="p">.</span><span class="n">consumer</span><span class="p">();</span> <span class="c1">// Obtain the reference to input buffer.</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">B</span> <span class="o">=</span> <span class="n">BufferB</span><span class="p">.</span><span class="n">producer</span><span class="p">();</span> <span class="c1">// Obtain the reference to output buffer.</span>

    <span class="n">BufferA</span><span class="p">.</span><span class="n">consumer_acquire</span><span class="p">();</span>  <span class="c1">// Acquire input buffer from upstream.</span>
    <span class="n">BufferB</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span>  <span class="c1">// Acquire buffer for output.</span>

    <span class="c1">// Note that the original code reading/writing the data</span>
    <span class="c1">// stays unchanged via the references with &#39;T&amp;&#39; type.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

    <span class="n">BufferA</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span>  <span class="c1">// Release input buffer back to upstream.</span>
    <span class="n">BufferB</span><span class="p">.</span><span class="n">producer_release</span><span class="p">();</span>  <span class="c1">// Release output buffer to downstream.</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="using-doublebuffer-and-sharedbuffer-in-a-multi-threaded-dataflow-design">
<span id="use-data-buffer-in-multi-threaded-dataflow"></span><h4>Using <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> in a multi-threaded dataflow design<a class="headerlink" href="#using-doublebuffer-and-sharedbuffer-in-a-multi-threaded-dataflow-design" title="Permalink to this headline">¶</a></h4>
<p>We will use a more complete example to further demonstrate how to use <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> and <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> in a multi-threaded dataflow design, and how the buffer classes enable parallelism between the dataflow threads.</p>
<p>Say we have a continuous input stream, every 2048 elements in the stream is considered as a segment.
We are going to sort each 2048-element segment of the input stream and write the sorted segments to an output stream.</p>
<p>As we know, no algorithm can sort with an O(n) runtime performance.
That is, a sorting algorithm needs to visit each element more than once, and hence the sorting algorithm cannot process the data stream at line rate and cannot work on the streaming FIFO interfaces directly.
A dataflow design in this case can be composed of three stages, 1) store each 2048-element segment of input stream into a buffer, 2) sort the elements in the buffer, and 3) stream out the sorted elements.
The three processing stages form a dataflow design, where the output produced by the earlier stage is consumed by the next stage.</p>
<a class="reference internal image-reference" href="_images/DoubleBufferDataflow.png"><img alt="_images/DoubleBufferDataflow.png" class="align-center" src="_images/DoubleBufferDataflow.png" style="width: 852.2px; height: 74.6px;" /></a>
<p>For better throughput, we can overlap the three processing stages with multi-threading, and use <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> or <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> to synchronize the accesses to the shared buffer between upstream and downstream threads.
Compared to <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>, each <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> contains two copies of storage instead of one, which reduces the delay that a processing stage waits for the buffer to become available.</p>
<p>The code below describes the design in C++:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/data_buffer.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;hls/streaming.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="cp">#define N 2048</span>

<span class="k">using</span> <span class="n">hls</span><span class="o">::</span><span class="n">DoubleBuffer</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hls</span><span class="o">::</span><span class="n">ref</span><span class="p">;</span>
<span class="k">using</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="p">;</span>

<span class="c1">// Reads input stream into array.</span>
<span class="kt">void</span> <span class="nf">StreamToBuffer</span><span class="p">(</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">in_fifo</span><span class="p">,</span> <span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">in_buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">buf_array</span> <span class="o">=</span> <span class="n">in_buffer</span><span class="p">.</span><span class="n">producer</span><span class="p">();</span> <span class="c1">// Obtain the reference to buffer.</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in_buffer</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span> <span class="c1">// Acquire buffer to write output data.</span>

<span class="cp">#pragma HLS loop pipeline</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">buf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

        <span class="n">in_buffer</span><span class="p">.</span><span class="n">producer_release</span><span class="p">();</span> <span class="c1">// Release buffer to downstream.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Forward declare the MergeSortArray function. Implementation is shown below.</span>
<span class="kt">void</span> <span class="nf">MergeSortArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="n">N</span><span class="p">]);</span>

<span class="c1">// Performs merge sort whenever the input and output buffers become available.</span>
<span class="kt">void</span> <span class="nf">MergeSort</span><span class="p">(</span><span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">in_buffer</span><span class="p">,</span> <span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">out_buffer</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">in</span> <span class="o">=</span> <span class="n">in_buffer</span><span class="p">.</span><span class="n">consumer</span><span class="p">();</span>   <span class="c1">// Obtain the reference to input buffer.</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">out</span> <span class="o">=</span> <span class="n">out_buffer</span><span class="p">.</span><span class="n">producer</span><span class="p">();</span> <span class="c1">// Obtain the reference to output buffer.</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">in_buffer</span><span class="p">.</span><span class="n">consumer_acquire</span><span class="p">();</span>  <span class="c1">// Acquire input buffer from upstream.</span>
        <span class="n">out_buffer</span><span class="p">.</span><span class="n">producer_acquire</span><span class="p">();</span> <span class="c1">// Acquire buffer for output.</span>

        <span class="n">MergeSortArray</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>

        <span class="n">out_buffer</span><span class="p">.</span><span class="n">producer_release</span><span class="p">();</span> <span class="c1">// Release output buffer to downstream.</span>
        <span class="n">in_buffer</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span>  <span class="c1">// Release input buffer back to upstream.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Writes array into output stream.</span>
<span class="kt">void</span> <span class="nf">BufferToStream</span><span class="p">(</span><span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">out_buffer</span><span class="p">,</span> <span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">out_fifo</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="o">&amp;</span><span class="n">buf_array</span> <span class="o">=</span> <span class="n">out_buffer</span><span class="p">.</span><span class="n">consumer</span><span class="p">();</span> <span class="c1">// Obtain the reference to buffer.</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out_buffer</span><span class="p">.</span><span class="n">consumer_acquire</span><span class="p">();</span> <span class="c1">// Acquire buffer to read data from upstream.</span>

<span class="cp">#pragma HLS loop pipeline</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
            <span class="n">out_fifo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">buf_array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

        <span class="n">out_buffer</span><span class="p">.</span><span class="n">consumer_release</span><span class="p">();</span> <span class="c1">// Release buffer back to upstream.</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Top-level function implementing a pipeline that sorts data stream.</span>
<span class="kt">void</span> <span class="nf">MergeSortPipeline</span><span class="p">(</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">in_fifo</span><span class="p">,</span> <span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">out_fifo</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Create two buffers as the intermediate storage for the three threads/functions.</span>
    <span class="n">DoubleBuffer</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="n">in_buffer</span><span class="p">,</span> <span class="n">out_buffer</span><span class="p">;</span>

    <span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StreamToBuffer</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">in_fifo</span><span class="p">),</span> <span class="n">ref</span><span class="p">(</span><span class="n">in_buffer</span><span class="p">));</span>
    <span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MergeSort</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">in_buffer</span><span class="p">),</span> <span class="n">ref</span><span class="p">(</span><span class="n">out_buffer</span><span class="p">));</span>
    <span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BufferToStream</span><span class="p">,</span> <span class="n">ref</span><span class="p">(</span><span class="n">out_buffer</span><span class="p">),</span> <span class="n">ref</span><span class="p">(</span><span class="n">out_fifo</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">StreamToBuffer</span></code>, <code class="docutils literal notranslate"><span class="pre">MergeSort</span></code>, and <code class="docutils literal notranslate"><span class="pre">BufferToStream</span></code> functions correspond to the blue function blocks in the above diagram.<ul>
<li><code class="docutils literal notranslate"><span class="pre">StreamToBuffer</span></code> reads <code class="docutils literal notranslate"><span class="pre">in_fifo</span></code> stream and writes to <code class="docutils literal notranslate"><span class="pre">in_buffer</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">MergeSort</span></code> reads <code class="docutils literal notranslate"><span class="pre">in_buffer</span></code> and writes to <code class="docutils literal notranslate"><span class="pre">out_buffer</span></code>,</li>
<li><code class="docutils literal notranslate"><span class="pre">BufferToStream</span></code> reads <code class="docutils literal notranslate"><span class="pre">out_buffer</span></code> and writes to <code class="docutils literal notranslate"><span class="pre">out_fifo</span></code> stream,</li>
<li>each function calls the corresponding producer or consumer side methods to access the shared <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code>, as described in the above section.</li>
</ul>
</li>
<li>The <code class="docutils literal notranslate"><span class="pre">MergeSortPipeline</span></code> function implements the dataflow pipeline,<ul>
<li>the <code class="docutils literal notranslate"><span class="pre">in_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">out_fifo</span></code> arguments correspond to the input and output streams of the pipeline,</li>
<li>the intermediate <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> are instantiated: <code class="docutils literal notranslate"><span class="pre">in_buffer</span></code> and <code class="docutils literal notranslate"><span class="pre">out_buffer</span></code>, corresponding to the gray buffer blocks in the above diagram,</li>
<li>the three processing functions are then invoked as parallel threads, and the input and output data are passed by reference to the threads (also see <a class="reference internal" href="#supported-parallel-apis"><span class="std std-ref">Supported SmartHLS Thread APIs</span></a>).</li>
</ul>
</li>
<li>Since we want the pipeline to continuously process the data stream, the three processing threads are made free-running. To achieve this,<ul>
<li>in each of the three processing functions, wrap the operations inside an infinite <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(1)</span></code> loop; each loop iteration processes one segment of data,</li>
<li>the three threads forked in <code class="docutils literal notranslate"><span class="pre">MergeSortPipeline</span></code> function are never joined and left constantly running.</li>
</ul>
</li>
<li>Now we have three free-running threads, each can start processing a new segment of data whenever the input/output storage becomes available to acquire via the <code class="docutils literal notranslate"><span class="pre">&lt;producer|consumer&gt;_acquire()</span></code> methods.</li>
</ul>
<p>In this design, each of the input and output buffers has two copies of storage for the 2048-element segment.
By having two copies of storage in a double buffer, the upstream producer can write a new batch of output to one copy of storage,
while the downstream consumer simultaneously processes the previous batch stored in the other copy of storage as input.</p>
<p>The figure below illustrates how <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> allows to overlap the executions of upstream and downstream threads,</p>
<a class="reference internal image-reference" href="_images/DoubleBufferTimeline.png"><img alt="_images/DoubleBufferTimeline.png" class="align-center" src="_images/DoubleBufferTimeline.png" style="width: 800.75px; height: 293.75px;" /></a>
<ul class="simple">
<li>At time a, <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> starts to receive input stream and store every 2048 input elements to storage A of input buffer (annotated as “in/A” in the figure).</li>
<li>At time b, when <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> finishes storing the first segment,<ul>
<li><code class="docutils literal notranslate"><span class="pre">Sort</span></code> starts working on the input stored in storage A of input buffer, and saves sorted result into storage A of output buffer,</li>
<li>meanwhile <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> can start storing the second segment to storage B of input buffer.</li>
</ul>
</li>
<li>At time c, when <code class="docutils literal notranslate"><span class="pre">Sort</span></code> finishes sorting the first segment,<ul>
<li>output buffer’s storage A is released for <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code> to send sorted segment to output stream,</li>
<li>input buffer’s storage A is freed up for <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> to store the next segment (segment 3),</li>
<li>and by this time, <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> has finished storing segment 2 into input buffer’s storage B, so <code class="docutils literal notranslate"><span class="pre">Sort</span></code> can immediately start working on segment 2.<ul>
<li>We assume <code class="docutils literal notranslate"><span class="pre">Sort</span></code> takes more time than <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code>.</li>
</ul>
</li>
</ul>
</li>
<li>From this point on, the dataflow pipeline enters steady state – whenever <code class="docutils literal notranslate"><span class="pre">Sort</span></code> finishes (e.g., at time c, d, and e),<ul>
<li>one input storage is released to the upstream <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> to store a new input segment,</li>
<li>one output storage is released to the downstream <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code> to stream out the sorted segment,</li>
<li>the <code class="docutils literal notranslate"><span class="pre">Sort</span></code> stage itself can work on the next segment immediately,</li>
<li><strong>the throughput of the dataflow pipeline is determined by the most time-consuming stage, i.e.,</strong> <code class="docutils literal notranslate"><span class="pre">Sort</span></code> <strong>in this case.</strong></li>
</ul>
</li>
</ul>
<p>The above C++ code can be easily changed to use <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>, by simply replacing all <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> type with <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code> type.
When using <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>, each buffer has only one copy of storage, which can only be accessed by one function at a time. So two adjacent upstream and downstream functions cannot be both active simultaneously.
The figure below shows the timeline when using <code class="docutils literal notranslate"><span class="pre">SharedBuffer</span></code>:</p>
<a class="reference internal image-reference" href="_images/SharedBufferTimeline.png"><img alt="_images/SharedBufferTimeline.png" class="align-center" src="_images/SharedBufferTimeline.png" style="width: 802.0px; height: 230.25px;" /></a>
<p>Notice at time b, when <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> finishes writing a segment to input buffer, <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> cannot immediately start writing the next segment as in the <code class="docutils literal notranslate"><span class="pre">DoubleBuffer</span></code> case.
<code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> needs to wait until <code class="docutils literal notranslate"><span class="pre">Sort</span></code> finishes sorting at time c and releases the only input buffer storage, in order to start storing the next segment.
Similarly, when <code class="docutils literal notranslate"><span class="pre">Sort</span></code> is running and has the output buffer acquired, the downstream <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code> has to wait.</p>
<p>In short, when <code class="docutils literal notranslate"><span class="pre">Sort</span></code> is running, its upstream <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> and downstream <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code> have no available buffers to continue processing and have to wait;
when <code class="docutils literal notranslate"><span class="pre">Sort</span></code> finishes, <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> and <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code> can be both active (e.g., from time c to d), because they do not access common buffers.</p>
<p>In this case, <strong>the throughput of the dataflow pipeline is determined by the latency of</strong> <code class="docutils literal notranslate"><span class="pre">Sort</span></code> <strong>plus</strong> <code class="docutils literal notranslate"><span class="pre">Str2Buf</span></code> (or <code class="docutils literal notranslate"><span class="pre">Buf2Str</span></code>, whichever is longer).</p>
<p>For completeness, the code below implements the merge sort algorithm (<code class="docutils literal notranslate"><span class="pre">MergeSortArray</span></code>) and a main function injecting input and checking output to/from the dataflow pipeline.
Note that,</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">MergeOnePass</span></code> function merges the multiple pairs of halves from one array into another array.
The <code class="docutils literal notranslate"><span class="pre">MergeSortArray</span></code> calls <code class="docutils literal notranslate"><span class="pre">MergeOnePass</span></code> repeatedly with a doubling partition size, and alternates the input and output array arguments between calls to reuse memory.
The two arrays are the storage inside the input and output buffers.
As you can see, the sort function, being the consumer of the input buffer, can also write to the buffer; and being the producer of the output buffer, can also read from the buffer.</li>
<li>Since free-running threads (that are continuously running and never joined) are not supported by SW/HW Co-Simulation (limitation listed in <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>),
we make the <code class="docutils literal notranslate"><span class="pre">main</span></code> function as the top-level to generate hardware for the entire program, so that the <code class="docutils literal notranslate"><span class="pre">Simulate</span> <span class="pre">Hardware</span></code> (<code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">sim</span></code>) feature can run directly without a custom testbench.</li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// One pass of merge with partition_size -- merging multiple pairs of halves</span>
<span class="c1">// across the whole array.</span>
<span class="c1">// For each pair, merges the two haves in[l .. m] and in[m + 1 .. r] into out[l</span>
<span class="c1">// .. r], where m = l + partition_size - 1, r = l + 2 * partition_size - 1</span>
<span class="c1">// Assume the array size is a power of 2.</span>
<span class="kt">void</span> <span class="nf">MergeOnePass</span><span class="p">(</span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">partition_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">left_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">left_idx</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">left_idx</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">partition_size</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">left_idx</span> <span class="o">+</span> <span class="n">partition_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="n">partition_size</span><span class="p">;</span>
        <span class="c1">// Indices in the input and output arrays.</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#pragma HLS loop pipeline</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">left_idx</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">left_idx</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">partition_size</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">copy_i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="o">?</span> <span class="nb">false</span> <span class="o">:</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">)</span> <span class="o">?</span> <span class="nb">true</span> <span class="o">:</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">copy_i</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="n">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">out</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
                <span class="n">j</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Merge sort is done in multiple steps, each step merges on two partitions with</span>
<span class="c1">// twice bigger the size of previous step.</span>
<span class="kt">void</span> <span class="nf">MergeSortArray</span><span class="p">(</span><span class="kt">int</span> <span class="n">in</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">out</span><span class="p">[</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// Each MergeOnePass merges from halves in array &#39;in&#39; to &#39;out&#39;, then</span>
    <span class="c1">// alternates to merge halves in array &#39;out&#39; to &#39;in&#39;.</span>
    <span class="c1">// We can reuse the memory by alternating the in and out arrays.</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="mi">32</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">64</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="mi">128</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="mi">512</span><span class="p">);</span>
    <span class="n">MergeOnePass</span><span class="p">(</span><span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="mi">1024</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define TEST_ITERATIONS 10</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_fifo</span><span class="p">(</span><span class="n">TEST_ITERATIONS</span> <span class="o">*</span> <span class="n">N</span><span class="p">),</span> <span class="n">out_fifo</span><span class="p">(</span><span class="n">TEST_ITERATIONS</span> <span class="o">*</span> <span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TEST_ITERATIONS</span> <span class="o">*</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">in_fifo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">TEST_ITERATIONS</span> <span class="o">*</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">MergeSortPipeline</span><span class="p">(</span><span class="n">in_fifo</span><span class="p">,</span> <span class="n">out_fifo</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="n">err_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">TEST_ITERATIONS</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="n">out_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">out_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;i: %d, last (%d) &gt; cur (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>
                <span class="n">err_cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">err_cnt</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FAIL. err_cnt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_cnt</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASS. err_cnt = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err_cnt</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">err_cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="image-processing-library">
<h3>Image Processing Library<a class="headerlink" href="#image-processing-library" title="Permalink to this headline">¶</a></h3>
<p>The SmartHLS image processing library provides C++ class/function APIs for a
number of commonly used image processing operations.
You can use these class/function APIs by including the following header file,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/image_processing.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<div class="section" id="line-buffer">
<span id="line-buffer-user-guide"></span><h4>Line Buffer<a class="headerlink" href="#line-buffer" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class implements the line buffer structure that is commonly
seen in image convolution (filtering) operations, where a filter kernel is
“slided” over an input image and is applied on a local window (e.g., a square)
of pixels at every sliding location.  As the filter is slided across the image,
the line buffer is fed with a new pixel at every new sliding location while
retaining the pixels of the previous image rows that can be covered for the
sliding window.
The public interface of the <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class is shown below,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">PixelType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ImageWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">WindowSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LineBuffer</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">PixelType</span> <span class="n">window</span><span class="p">[</span><span class="n">WindowSize</span><span class="p">][</span><span class="n">WindowSize</span><span class="p">];</span>
    <span class="kt">void</span> <span class="nf">ShiftInPixel</span><span class="p">(</span><span class="n">PixelType</span> <span class="n">input_pixel</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Below shows an example usage of the LineBuffer class:</p>
<ul class="simple">
<li>Instantiate the line buffer in your C++ code, with template
arguments being the pixel data type, input image width, and sliding window
size.  The window maintained by the line buffer assumes a square
<code class="docutils literal notranslate"><span class="pre">WindowSize</span> <span class="pre">x</span> <span class="pre">WindowSize</span></code> window.  If you are instantiating the line buffer
inside a pipelined function (accepting a new pixel in every function call),
you will need to add ‘static’ to make the line buffer static.</li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">hls</span><span class="o">::</span><span class="n">LineBuffer</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="n">ImageWidth</span><span class="p">,</span> <span class="n">WindowSize</span><span class="o">&gt;</span> <span class="n">line_buffer</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li>Shift in a new pixel by calling the <code class="docutils literal notranslate"><span class="pre">ShiftInPixel</span></code> method:</li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">line_buffer</span><span class="p">.</span><span class="n">ShiftInPixel</span><span class="p">(</span><span class="n">input_pixel</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li>Then your filter can access any pixels in the <code class="docutils literal notranslate"><span class="pre">window</span></code> by:</li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">line_buffer</span><span class="p">.</span><span class="n">window</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>The figure below illustrates how the line buffer <code class="docutils literal notranslate"><span class="pre">window</span></code> is being updated
after each call of <code class="docutils literal notranslate"><span class="pre">ShiftInPixel</span></code>.  You will notice that the <cite>window</cite> can
contain out-of-bound pixels at certain sliding locations.</p>
<a class="reference internal image-reference" href="_images/LineBufferClass.png"><img alt="_images/LineBufferClass.png" class="align-center" src="_images/LineBufferClass.png" style="width: 764.1px; height: 1044.0px;" /></a>
<p>For more details about when/why to use the <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class, see
<a class="reference internal" href="optimizationguide.html#line-buffer-opt-guide"><span class="std std-ref">Inferring a Line Buffer</span></a> in the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a>.</p>
</div>
</div>
<div class="section" id="math-library-math-h">
<span id="c-math-library"></span><h3>Math Library (math.h)<a class="headerlink" href="#math-library-math-h" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS supports a subset of the C Math Library. These functions are supported for functionality, however, may not lead to an efficient hardware implementation.
If you require high performance, we recommend restructuring your software code to not call these math functions.
The table below shows supported math functions.</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="21%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">Function Types</th>
<th class="head">Function Names</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="2">Trigonometric functions</td>
<td>cos, cosf, sin, sinf, tan, tanf, acos, acosf, asin, asinf, atan, atanf, atan2</td>
</tr>
<tr class="row-odd"><td colspan="2">Hyperbolic functions</td>
<td>cosh, coshf, sinh, sinhf, tanh, tanhf, acosh, acoshf, asinh, asinhf, atanh, atanhf</td>
</tr>
<tr class="row-even"><td colspan="2">Exponential and logarithmic functions</td>
<td>exp, expf, frexp, log, logf, log10, modf, exp2, expm1, ilogb, log1p, log2, logb, scalbn, scalbln</td>
</tr>
<tr class="row-odd"><td colspan="2">Power functions</td>
<td>pow, powf, sqrt, hypot, cbrt</td>
</tr>
<tr class="row-even"><td colspan="2">Error and gamma functions</td>
<td>erf, erfc, tgamma</td>
</tr>
<tr class="row-odd"><td colspan="2">Rounding and remainder functions</td>
<td>ceil, floor, fmod, fmodf, trunc, round, lround, llround, rint, lrint, llrint, nearbyint, remainder, remquo</td>
</tr>
<tr class="row-even"><td colspan="2">Floating-point manipulation functions</td>
<td>copysign, nan, nextafter</td>
</tr>
<tr class="row-odd"><td colspan="2">Minimum, maximum, difference functions</td>
<td>fdim, fmax, fmin</td>
</tr>
<tr class="row-even"><td colspan="2">Other functions</td>
<td>fabs, fabsf, fma</td>
</tr>
<tr class="row-odd"><td rowspan="2">Implemented as macros in C
and as functions in C++</td>
<td>Classification macros or functions</td>
<td>isinf, isnan</td>
</tr>
<tr class="row-even"><td>Comparison macros or functions</td>
<td>isgreater, isgreaterequal, isless, islessequal, islessgreater</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="memory-allocation-library">
<span id="allocation-library"></span><h3>Memory Allocation Library<a class="headerlink" href="#memory-allocation-library" title="Permalink to this headline">¶</a></h3>
<p>For SoC designs on platforms running Linux, the SmartHLS Memory Allocation Library can be used to allocate memory in special areas outside of the areas normally used by the operating system.
Memory in these areas is guaranteed to be physically contiguous and free from the virtual-physical mapping that is normally imposed by the operating system.
Having contiguous, physically pinned down memory is required for efficient memory transfers between DDR and components on the FPGA fabric, since it avoids issues such as paging and virtual-to-physical address translation.
The SmartHLS memory allocation library should be used for any accelerator arguments that use DMA Copy or Accelerator Direct Access <a class="reference internal" href="#soc-data-transfer-methods"><span class="std std-ref">SoC Data Transfer Methods</span></a>.
An Example of how to use the library is shown below:</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/hls_alloc.h&quot;</span><span class="cp"></span>

<span class="c1">// Allocate enough memory for an array of 8 32-bit numbers in the default memory</span>
<span class="c1">// region using hls_malloc. This call has the same function signature as</span>
<span class="c1">// standard C malloc().</span>
<span class="kt">uint32_t</span> <span class="n">array_size</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">);</span>
<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">array_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">hls_malloc</span><span class="p">(</span><span class="n">array_size</span><span class="p">);</span>

<span class="c1">// Allocate the same amount of memory in the non-cached DDR region. The second</span>
<span class="c1">// optional argument is used to specify which memory region to use.</span>
<span class="kt">uint32_t</span> <span class="o">*</span><span class="n">noncached_array_ptr</span> <span class="o">=</span>
<span class="p">(</span><span class="kt">uint32_t</span> <span class="o">*</span><span class="p">)</span><span class="n">hls_malloc</span><span class="p">(</span><span class="n">array_size</span><span class="p">,</span> <span class="n">HLS_ALLOC_NONCACHED</span><span class="p">);</span>

<span class="c1">// Use hls_memcpy to move data from one array to another. This call has the same</span>
<span class="c1">// signature as standard C memcpy(), with additional arguments to specify where</span>
<span class="c1">// the transfer is going and what method to use. In this example, we move data</span>
<span class="c1">// from one array in MSS DDR to another array in MSS DDR, using the hard DMA</span>
<span class="c1">// controller in the MSS.</span>
<span class="n">hls_memcpy</span><span class="p">(</span><span class="n">noncached_array_ptr</span><span class="p">,</span> <span class="n">array_ptr</span><span class="p">,</span> <span class="n">array_size</span><span class="p">,</span> <span class="n">HLS_ALLOC_MSS_TO_MSS</span><span class="p">,</span>
<span class="n">HLS_ALLOC_PDMA</span><span class="p">);</span>

<span class="c1">// Free the allocated buffers using hls_free, has the same function signuture as</span>
<span class="c1">// standard C free().</span>
<span class="n">hls_free</span><span class="p">(</span><span class="n">array_ptr</span><span class="p">);</span>
<span class="n">hls_free</span><span class="p">(</span><span class="n">noncached_array_ptr</span><span class="p">);</span>
</pre></div>
</div>
<p>The optional second argument in <code class="docutils literal notranslate"><span class="pre">hls_malloc</span></code> defines what memory region memory should be allocated in, and is of type <code class="docutils literal notranslate"><span class="pre">hls_alloc_memory_type_t</span></code>, defined in the <code class="docutils literal notranslate"><span class="pre">hls_alloc.h</span></code>.
Using the SmartHLS reference SoC linux image, there are three memory regions available for use with the Memory Allocation Library, oulined in the table below.
The address and size of each region can be modified to fit other Linux images by changing the <code class="docutils literal notranslate"><span class="pre">hls_alloc_buffer_regions</span></code> struct in <code class="docutils literal notranslate"><span class="pre">hls_alloc.h</span></code> and recompiling the library.</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="7%" />
<col width="8%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Region</th>
<th class="head">Address</th>
<th class="head">Size (bytes)</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>HLS_ALLOC_CACHED</td>
<td>0xae000000</td>
<td>0x02000000</td>
<td>Cached DDR. Default if region unspecified. Recommended for best overall transfer times.</td>
</tr>
<tr class="row-odd"><td>HLS_ALLOC_NONCACHED_WCB</td>
<td>0xd8000000</td>
<td>0x08000000</td>
<td>Non-cached DDR with write-combine buffer. Slightly better performance than Cached DDR for writes, but worse for reads.</td>
</tr>
<tr class="row-even"><td>HLS_ALLOC_NONCACHED</td>
<td>0xc0000000</td>
<td>0x08000000</td>
<td>Non-cached DDR. Not recommended (lower performance than other options).</td>
</tr>
</tbody>
</table>
<p>There are two extra arguments in <code class="docutils literal notranslate"><span class="pre">hls_memcpy</span></code> compared to the standard C <code class="docutils literal notranslate"><span class="pre">memcpy</span></code>. The first extra argument is of type <code class="docutils literal notranslate"><span class="pre">hls_alloc_direction_t</span></code>, and describes
the direction in which data is moving, which is required by the underlying library to properly move data between the MSS DDR and buffers on the FPGA fabric.
The second extra argument is of type <code class="docutils literal notranslate"><span class="pre">hls_alloc_transfer_type_t</span></code>, and allows the user to choose between two transfer methods. Selecting <code class="docutils literal notranslate"><span class="pre">HLS_ALLOC_MEMCPY</span></code>
will invoke <code class="docutils literal notranslate"><span class="pre">memcpy</span></code> under the hood, and let the OS choose the best way to move the data. Selecting <code class="docutils literal notranslate"><span class="pre">HLS_ALLOC_PDMA</span></code> will use the platform DMA engine
in the MSS to move the data. Argument types are defined as enums in <code class="docutils literal notranslate"><span class="pre">hls_alloc.h</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">hls_memcpy</span></code> function is automatically used as part of the accelerator driver generated by SmartHLS. Users are not expected to have to invoke this function to use SmartHLS accelerators.</p>
</div>
</div>
</div>
<div class="section" id="top-level-rtl-interface">
<span id="rtl-interface"></span><h2>Top-Level RTL Interface<a class="headerlink" href="#top-level-rtl-interface" title="Permalink to this headline">¶</a></h2>
<p>The SmartHLS-generated top-level RTL module can be instantiated and integrated with other HDL blocks, by following the protocols used by the SmartHLS’s
RTL interface.
This section describes the types of interfaces that are supported by SmartHLS, the
default interface for each data type in C/C++, and how to customize the
interface.</p>
<div class="section" id="module-control-interface-1">
<span id="module-control-interface"></span><h3>Module Control Interface<a class="headerlink" href="#module-control-interface-1" title="Permalink to this headline">¶</a></h3>
<p>The top-level Verilog module generated by SmartHLS is always associated with a
module control interface to start the HLS module, read completion status and
retrieve return data.
Two interface protocols are available for module control, <code class="docutils literal notranslate"><span class="pre">simple</span></code> and
<code class="docutils literal notranslate"><span class="pre">axi_target</span></code>. The default interface is <code class="docutils literal notranslate"><span class="pre">simple</span></code>. The module control
interface can be explicitly specified via an <code class="docutils literal notranslate"><span class="pre">interface</span></code> pragma at the
beginning of the top-level function’s definition body:</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add at the beginning of the function definition</span>
<span class="cp">#pragma HLS interface control type(&lt;simple|axi_target&gt;)</span>
</pre></div>
</div>
<div class="section" id="simple-module-control-interface">
<span id="module-control-simple"></span><h4>Simple Module Control Interface<a class="headerlink" href="#simple-module-control-interface" title="Permalink to this headline">¶</a></h4>
<p>The table below shows the interface ports of the simple module control interface.</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="9%" />
<col width="81%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Name</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>clock</cite></td>
<td>IN</td>
<td>The input clock signal to the RTL module.</td>
</tr>
<tr class="row-odd"><td><cite>reset</cite></td>
<td>IN</td>
<td>The input reset signal to the RTL module.</td>
</tr>
<tr class="row-even"><td><cite>ready</cite></td>
<td>OUT</td>
<td>Indicates the readiness of the RTL module.
<cite>ready</cite> is set to 1 when the RTL module is ready to start a new iteration (invocation) with a new set
of inputs.</td>
</tr>
<tr class="row-odd"><td><cite>start</cite></td>
<td>IN</td>
<td>When <cite>ready</cite> is 1, setting <cite>start</cite> to 1 will start the execution of the RTL module;
When <cite>ready</cite> is 0, the <cite>start</cite> signal is ignored by the RTL module.</td>
</tr>
<tr class="row-even"><td><cite>finish</cite></td>
<td>OUT</td>
<td><cite>finish</cite> is set to 1 for one clock cycle when the RTL module finishes.</td>
</tr>
<tr class="row-odd"><td><cite>return_val</cite></td>
<td>OUT</td>
<td>Holds the valid return value when <cite>finish</cite> is asserted.
This signal does not exist if the top-level function has a void return type.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<ul class="last simple">
<li>The top-level module starts a new iteration of execution upon the
handshaking when both <cite>ready</cite> and <cite>start</cite> are high at a positive edge
clock.</li>
<li>For a circuit containing pipelined functions, the <cite>ready</cite> signal can be
high before the previous invocations have finished, allowing multiple
invocations to overlap and run in parallel.</li>
<li>For circuits without pipelined functions, the <cite>ready</cite> signal is only
asserted when the last invocation has finished.</li>
<li>The scalar arguments (described in the next section) should be provided at
the same time when the <cite>start</cite> signal is set to high.</li>
</ul>
</div>
<div class="section" id="timing-diagram-no-pipeline-functions">
<h5>Timing Diagram (No Pipeline Functions)<a class="headerlink" href="#timing-diagram-no-pipeline-functions" title="Permalink to this headline">¶</a></h5>
<img alt="_images/control_intf.png" class="align-center" src="_images/control_intf.png" />
<p>The timing diagram above illustrates the behaviour of the module control
interface when the generated circuit contains no pipelined circuits.</p>
<ul class="simple">
<li>First, the <cite>ready</cite> signal comes out high after reset (label 0).</li>
<li>When the <cite>start</cite> signal becomes high at the next cycle (label a), the
handshaking between <cite>ready</cite> and <cite>start</cite> (label 1 &amp; a) occurs and the
top-level module starts running.<ul>
<li>Notice that at the same time as the <cite>start</cite> signal is asserted (label a),
the argument inputs (i.e., <cite>arg_X</cite> and <cite>arg_Y</cite>) should also be provided to
the top-level module.  The scalar argument inputs are sampled by the
top-level module when the handshaking occurs and will be used as the input
for the current invocation.</li>
</ul>
</li>
<li>Then the <cite>ready</cite> signal goes to low at the next cycle (label 2) to indicate
the top-level module cannot accept a new invocation.</li>
<li>When the <cite>ready</cite> signal is low, the <cite>start</cite> signal is ignored by the
top-level module.
For example, the <cite>start</cite> signal becomes high at label b. The <cite>ready</cite> signal
from the top-level module is still low at this cycle and hence a new function
invocation won’t be started yet.</li>
<li>At label x, when the previous invocation finishes, the top-level module sets
<cite>finish</cite> signal high for one clock cycle. In this clock cycle, the return
value of the top-level function is available on the <cite>return_val</cite> port.</li>
<li>Meanwhile, the <cite>ready</cite> signal becomes high as the previous invocation
finishes (label 3). A new handshaking with <cite>start</cite> occurs (label 3 &amp; c), then
the top-level function starts the second invocation and finishes at label y.</li>
</ul>
</div>
<div class="section" id="timing-diagram-pipeline-functions">
<h5>Timing Diagram (Pipeline Functions)<a class="headerlink" href="#timing-diagram-pipeline-functions" title="Permalink to this headline">¶</a></h5>
<img alt="_images/control_intf_func_pipeline.png" class="align-center" src="_images/control_intf_func_pipeline.png" />
<p>The timing diagram above illustrates the module control interface when the
generated circuit contains pipelined function(s).  In this case, the SmartHLS
circuit can overlap the execution of multiple invocations, by starting a new
invocation with a new set of inputs before previous invocations have finished.</p>
<ul class="simple">
<li>There are a total of five invocations (or five <cite>ready</cite> &amp; <cite>start</cite>
handshakings, label 0-4 &amp; a-e). As shown in the diagram, the new invocations
can start without waiting for the prior invocations to finish.</li>
<li>Although the SmartHLS circuit can process multiple invocations in parallel,
there are times when the SmartHLS circuit cannot start a new invocation.
Such case can happen when the pipeline initiation internal is not 1 (i.e.,
the SmartHLS circuit cannot start a new invocation every clock cycle),
or when the circuit is stalled waiting for resource/data to become available
(e.g., waiting to read from an input FIFO).
When the SmartHLS circuit can not start a new invocation, the <cite>ready</cite> signal
will be set to low.<ul>
<li>For example, the <cite>ready</cite> signal is low for one cycle before label 2,
postponing the start of the third invocation until the <cite>ready</cite> signal is
back to high at label 2 &amp; c.</li>
</ul>
</li>
<li>The external logic of the SmartHLS circuit can also lower the <cite>start</cite> signal to
delay the start of a new invocation, as shown in the cycle before label d.</li>
<li>The invocations are always finished in the same order as they started.
That is, the handshakings at label 0 &amp; a, 1 &amp; b, 2 &amp; c, 3 &amp; d, 4 &amp; e,
are corresponding to the completion at label o, p, q, r, s, respectively.</li>
</ul>
</div>
</div>
<div class="section" id="axi4-target-for-module-control">
<span id="module-control-axi-target"></span><h4>AXI4 Target for Module Control<a class="headerlink" href="#axi4-target-for-module-control" title="Permalink to this headline">¶</a></h4>
<p>The HLS module can also be controlled via an AXI4 target interface in a
memory-mapped manner.
When <code class="docutils literal notranslate"><span class="pre">axi_target</span></code> interface type is specified in the pragma, a <cite>module
control register</cite> and a <cite>return value register</cite> will be created and made
accessible behind the HLS module’s AXI4 target interface.
The AXI4 target interface’s associated ports are named as <code class="docutils literal notranslate"><span class="pre">axi4target_*</span></code>.
Writing a value of 1 to the <cite>module control register</cite> will start the HLS module.
When reading from the <cite>module control register</cite>, a value of 1 means the HLS
module is still running; a value of 0 means the HLS module is idle (or has
finished running).
When the HLS module finishes, the return value of the top-level function (if
not <code class="docutils literal notranslate"><span class="pre">void</span></code> type) can be retrieved by reading the <cite>return value register</cite>.
The memory-mapped address offsets of these registers can be found in the
<a class="reference internal" href="#axi-target-addr-map"><span class="std std-ref">AXI4 Target Interface Address Map</span></a> section of the <a class="reference internal" href="#shls-report"><span class="std std-ref">SmartHLS Report</span></a>.
In addition, driver functions are generated for convenient module control from
an attached processor (see <a class="reference internal" href="#module-control-driver"><span class="std std-ref">Module Control Driver Functions</span></a>).</p>
<p>Note that to use AXI4 target interface for module control, the top-level
function’s return type must be a C primitive data type (e.g., char, unsigned
int, double, and etc; cannot be a struct or <code class="docutils literal notranslate"><span class="pre">ap_int</span></code> type).
Using AXI4 target interface for module control is not suitable for designs with
pipeline functions.</p>
</div>
</div>
<div class="section" id="scalar-argument">
<span id="scalar-arg-interface"></span><h3>Scalar Argument<a class="headerlink" href="#scalar-argument" title="Permalink to this headline">¶</a></h3>
<p>Scalar arguments of the top-level function (e.g., <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">MyTopFunc(int</span>
<span class="pre">MyScalarArg)</span></code>;) can also be configured via an interface pragma, with the two
supported interface types, <code class="docutils literal notranslate"><span class="pre">simple</span></code> (default) or <code class="docutils literal notranslate"><span class="pre">axi_target</span></code>.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Add at the beginning of the function definition</span>
<span class="c1">// Note that the stable option is only available for simple type.</span>
<span class="cp">#pragma HLS interface argument(&lt;SCALAR_ARGUMENT_NAME&gt;) type(&lt;simple|axi_target&gt;) stable(&lt;false|true&gt;)</span>
</pre></div>
</div>
<div class="section" id="simple-scalar-interface">
<h4>Simple Scalar Interface<a class="headerlink" href="#simple-scalar-interface" title="Permalink to this headline">¶</a></h4>
<p>A scalar argument with a <code class="docutils literal notranslate"><span class="pre">simple</span></code> interface type becomes an input port of the
top-level RTL module. Valid argument values should be provided on these input
ports when the HLS module starts (i.e., when <cite>start</cite> signal is asserted, or
when the <code class="docutils literal notranslate"><span class="pre">MyTopFunc_start()</span></code> driver function is called).
If the input port can be held valid and unchanged throughout the whole
iteration of the execution, a <cite>stable</cite> option can be specified using the
following pragma to inform SmartHLS and potentially save register usage in the
generated module.</p>
<p>As shown in the table below, each scalar argument corresponds to an input port
of the top-level module,</p>
<table border="1" class="docutils">
<colgroup>
<col width="16%" />
<col width="8%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Name</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>&lt;ARGUMENT_NAME&gt;</cite></td>
<td>IN</td>
<td>The input value of the scalar argument.  This input port is sampled by the SmartHLS module when both
<cite>start</cite> and <cite>ready</cite> signals are 1.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="axi4-target-for-scalar-argument">
<span id="scalar-arg-axi-target"></span><h4>AXI4 Target for Scalar Argument<a class="headerlink" href="#axi4-target-for-scalar-argument" title="Permalink to this headline">¶</a></h4>
<p>When a scalar argument’s interface type is configured to <code class="docutils literal notranslate"><span class="pre">axi_target</span></code>, a
register corresponding to the scalar argument will be made accessible behind
the HLS module’s AXI4 target interface.
Typically, a write operation to the AXI4 target interface is performed to
update the scalar argument value before starting the HLS module.
The register value stays unchanged until next write to the register, so no need
to update the scalar argument register again if a new invocation of the HLS
module uses the same value for the scalar argument as the last invocation.
The scalar argument registers are also readable via the AXI4 target interface.
The corresponding memory-mapped address offset of the scalar argument register
can be found in the <a class="reference internal" href="#axi-target-addr-map"><span class="std std-ref">AXI4 Target Interface Address Map</span></a> section of the
<a class="reference internal" href="#shls-report"><span class="std std-ref">SmartHLS Report</span></a>.
In addition, SmartHLS generates driver functions for convenient write and read
to the scalar argument (see <a class="reference internal" href="#scalar-arg-driver"><span class="std std-ref">Scalar Argument Driver Functions</span></a>).</p>
<p>Note that to use AXI4 target interface for a scalar argument, the argument type
needs to be a C primitive data type (e.g., char, unsigned int, double, and etc;
cannot be a struct or <code class="docutils literal notranslate"><span class="pre">ap_int</span></code> type).</p>
</div>
</div>
<div class="section" id="pointer-argument-and-shared-global-variable">
<span id="ptr-arg-and-shared-gv"></span><h3>Pointer Argument and Shared Global Variable<a class="headerlink" href="#pointer-argument-and-shared-global-variable" title="Permalink to this headline">¶</a></h3>
<p>Pointer arguments and global variables are considered as “memories” that
maintain states in the circuit.  The “memories” may be implemented inside or
outside of the SmartHLS-generated circuit, depending on the specified interface
type.  For a global variable, a top-level RTL interface is only created if the
variable is shared/accessed by both the software testbench and the HLS
function.  If the global variable is only accessed by the HLS function, the
“memory” will be implemented inside the generated circuit and has no top-level
interface.</p>
<p>There are four interface types for pointer arguments and shared global
variables: memory, AXI4 initiator, AXI4 target and legacy AXI4 slave.
As shown in the table below, the available interface types vary depending on
the data type of the pointer or global variable.  We will explain each
interface type in the sections below.</p>
<table border="1" class="docutils">
<colgroup>
<col width="12%" />
<col width="24%" />
<col width="18%" />
<col width="14%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" rowspan="2">Data Type</th>
<th class="head" colspan="4">Interface Type</th>
</tr>
<tr class="row-even"><th class="head">Memory (default)</th>
<th class="head">AXI4 Initiator</th>
<th class="head">AXI4 Target</th>
<th class="head">Legacy AXI4 Slave</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-odd"><td>Array</td>
<td rowspan="3">Pointer arguments
and global variables
of these data types
are supported.</td>
<td colspan="2" rowspan="3">Pointer arguments of
these data types are
supported, but not for
global variables.</td>
<td>n/a</td>
</tr>
<tr class="row-even"><td>Struct</td>
<td>Supports global struct only.</td>
</tr>
<tr class="row-odd"><td>Scalar</td>
<td>n/a</td>
</tr>
</tbody>
</table>
<div class="section" id="memory-interface-1">
<span id="memory-interface"></span><h4>Memory Interface<a class="headerlink" href="#memory-interface-1" title="Permalink to this headline">¶</a></h4>
<p>The memory interface can be used for any pointer arguments or global variables
(including array and struct types).
The memory interface can be connected to an external RAM module that stores the
corresponding data so that the HLS module can access the data in the external
RAM.
The pragma below specifies the memory interface type for a given argument or
global variable,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// For top-level function arguments:</span>
<span class="c1">// Add at the beginning of the function definition</span>
<span class="cp">#pragma HLS interface argument(&lt;ARGUMENT_NAME&gt;) type(memory) num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;)</span>

<span class="c1">// For shared global variables:</span>
<span class="c1">// Add before the variable definition</span>
<span class="cp">#pragma HLS interface variable(&lt;ARGUMENT_NAME&gt;) type(memory) num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;)</span>
</pre></div>
</div>
<p>The <cite>num_elements</cite> option is only available for array type arguments. The array size
can be specified or overridden (over the declared size in C++) by specifying
the <cite>num_elements</cite> option.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The specified num_elements will represent the total number of elements of the
array.  In the case of multi-dimensional array, the size of the outermost
dimension will be overrided to (num_elements / COMBINE_DEPTH_OF_INNER_DIMENSIONS),
and the sizes of inner dimensions will remain the same.
For multi-dimensional arrays, the specified num_elements has to be a multiple
of the combined number of elements of all inner dimensions (except the
outermost dimension).  Meaning only the outermost dimension’s size can be
overrided.</p>
</div>
<div class="section" id="aggregate-memory-type-array-struct-or-class">
<h5>Aggregate Memory Type (array, struct, or class)<a class="headerlink" href="#aggregate-memory-type-array-struct-or-class" title="Permalink to this headline">¶</a></h5>
<p>When the memory has more than 1 elements (not a scalar type memory), SmartHLS
creates an interface with two RAM ports. Each RAM port can do both read and
write to the external RAM. A one cycle read latency is expected.
Typically an external true dual-port RAM can be connected to the interface,
allowing both ports to perform independent reads/writes simultaneously.
The same port will not perform read and write at the same cycle.
Simultaneous writes from both ports are guaranteed to be with different write addresses.</p>
<p>The table below lists the signals of each RAM port, with “_a” and “_b” suffixes
respectively.  Some signals are not available when the memory is read-only or
write-only, i.e., when the top-level function (and its descendant functions)
never write to or read from the memory.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="9%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Name</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>&lt;ARG_NAME&gt;_address_&lt;a|b&gt;</cite></td>
<td>OUT</td>
<td>The address pointing to the RAM entry that SmartHLS module wants to access.</td>
</tr>
<tr class="row-odd"><td><cite>&lt;ARG_NAME&gt;_read_en_&lt;a|b&gt;</cite></td>
<td>OUT</td>
<td>Read enable port (n/a for write-only memory).</td>
</tr>
<tr class="row-even"><td><cite>&lt;ARG_NAME&gt;_read_data_&lt;a|b&gt;</cite></td>
<td>IN</td>
<td>Read data port (n/a for write-only memory).</td>
</tr>
<tr class="row-odd"><td><cite>&lt;ARG_NAME&gt;_write_en_&lt;a|b&gt;</cite></td>
<td>OUT</td>
<td>Write enable port (n/a for read-only memory).</td>
</tr>
<tr class="row-even"><td><cite>&lt;ARG_NAME&gt;_byte_en_&lt;a|b&gt;</cite></td>
<td>OUT</td>
<td>Byte-enable port. Only available if the memory requires writes to partial
bytes of a memory word.
(n/a for read-only memory, or when all write operations update the whole
memory words).</td>
</tr>
<tr class="row-odd"><td><cite>&lt;ARG_NAME&gt;_write_data_&lt;a|b&gt;</cite></td>
<td>OUT</td>
<td>Write data port (n/a for read-only memory).</td>
</tr>
</tbody>
</table>
<p>The timing diagram shows the memory interface behaviour expected by the SmartHLS-generated module.</p>
<img alt="_images/memory_intf.png" class="align-center" src="_images/memory_intf.png" />
<ul class="simple">
<li>At Cycle a, the top-level module performs a write operation to the connected
external memory, by setting the <cite>arg_write_en</cite> port to high and providing the
address “A0” and write data “D0” on the <cite>arg_address</cite> and <cite>arg_write_data</cite>
ports respectively.</li>
<li>At Cycle b, the top-level module issues a read from the connected external
memory by setting <cite>arg_address</cite> to the read address “A0” and <cite>arg_read_en</cite> to
high.  SmartHLS module expects the read data “D0” to be available on the
<cite>arg_read_data</cite> port in the subsequent cycle (i.e., Cycle c).</li>
<li>At Cycle d, the top-level module writes “D1” to address “A1”</li>
<li>Keeping the address port the same and setting <cite>arg_read_en</cite> high at the next
cycle, the top-level module reads from address “A1” at Cycle e, and expects to
receive “D1” at the right next cycle at Cycle f.</li>
</ul>
</div>
<div class="section" id="scalar-memory-type">
<h5>Scalar Memory Type<a class="headerlink" href="#scalar-memory-type" title="Permalink to this headline">¶</a></h5>
<p>When the pointer argument is referencing a single element scalar, or the global
variable is of a scalar type, this means the external memory has only one
element.
In these cases, the HLS module uses the scalar memory interface, which can be
thought of as a special memory interface that has no address port and expects a
0-cycle read latency.</p>
<p>Note that specifying an array / struct data type to be partitioned into
individual elements using <cite>#pragma HLS memory partition</cite> (See
<a class="reference internal" href="#memory-partitioning"><span class="std std-ref">Memory Partitioning</span></a> for details) can create scalar interfaces.
The following example has an array interface <cite>array</cite> that is partitioned
completely into 10 elements, each element is a scalar memory.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(array) type(complete)</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The table below lists the associated RTL module ports for each scalar memory
interface.  Some signals are not available when the memory is read-only or
write-only, i.e., when the top-level function (and its descendant functions)
never write to or read from the memory.</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="10%" />
<col width="65%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Port Name</th>
<th class="head">Direction</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>&lt;ARG_NAME&gt;_read_data</cite></td>
<td>IN</td>
<td>The input value of the argument (n/a for write-only memory).
The signal is not sampled at the start of circuit execution.
The external logic needs to keep the signal stable
and valid at any given time during the circuit execution.</td>
</tr>
<tr class="row-odd"><td><cite>&lt;ARG_NAME&gt;_write_data</cite></td>
<td>OUT</td>
<td>The output value of the argument (n/a for read-only memory).
The <cite>write_data</cite> port has valid value
only when the <cite>write_en</cite> signal is high.
This port is not available if the SmartHLS circuit never writes to the
pointer argument (or global variable).</td>
</tr>
<tr class="row-even"><td><cite>&lt;ARG_NAME&gt;_write_en</cite></td>
<td>OUT</td>
<td>Indicates the write_data is valid (n/a for read-only memory).
This port is not available if the SmartHLS circuit never writes to the
pointer argument (or global variable).</td>
</tr>
</tbody>
</table>
<p>Note that SmartHLS circuit expects a 0-cycle read latency.
This is, the <cite>&lt;ARG_NAME&gt;_read_data</cite> port is expected to always hold the valid
data for the pointer argument such that the SmartHLS circuit can use its value at
any time.</p>
<p>One way of using the scalar memory interface is to connect the scalar memory
interface to a register outside of the SmartHLS module. The <cite>read_data</cite> port can
be connected to the register itself. The <cite>write_en</cite> and <cite>write_data</cite> ports will
be used to update the register.</p>
<img alt="_images/scalar_memory_intf.png" class="align-center" src="_images/scalar_memory_intf.png" />
<p>The timing diagram gives an example of how the scalar memory interface would
behave when it is connected to an external register.  Initially the external
register is holding a value of “D0” and providing the value to the
<cite>arg_read_data</cite> port.
At Cycle a, the top-level module writes to the register by asserting
<cite>arg_write_en</cite> and setting <cite>arg_write_data</cite> to “D1”.
Then at the next cycle, Cycle b, the register value is updated, and the
<cite>arg_read_data</cite> is also immediately updated to the new value.</p>
<p>Note that the scalar memory interface does not always have to be connected to
an external register.
One use case of the scalar memory interface could be to connect the
<cite>arg_read_data</cite> port to an input signal that is changing while the SmartHLS
circuit runs, allowing the SmartHLS circuit to read the up-to-date value from the
input. Typically, the pointer argument is read-only by the SmartHLS circuit in
such case.</p>
<p>Similarly, the <cite>arg_write_data</cite> can be connected to an output that needs to be
updated in real-time.  In this case, the pointer argument is normally only
written to by the SmartHLS circuit (with no read access).</p>
</div>
</div>
<div class="section" id="axi4-initiator-interface">
<span id="pointer-arg-axi-initiator"></span><h4>AXI4 Initiator Interface<a class="headerlink" href="#axi4-initiator-interface" title="Permalink to this headline">¶</a></h4>
<p>When AXI4 initiator is used for a pointer argument (not available for global
variable), the HLS module will include an AXI4 initiator interface, with the
associated ports named as <code class="docutils literal notranslate"><span class="pre">axi4initiator_*</span></code>.
The “memory” referenced by the pointer argument is considered external to the
HLS module.
All memory accesses to the pointer argument will be translated into read or
write AXI4 transactions through the AXI4 initiator interface.
The pragma below specifies the AXI4 initiator interface type for a pointer
argument (including array, struct, class types),</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS interface argument(&lt;ARGUMENT_NAME&gt;) type(axi_initiator) \</span>
<span class="cp">                      ptr_addr_interface(&lt;simple|axi_target&gt;) \</span>
<span class="cp">                      num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;) \</span>
<span class="cp">                      max_burst_len(&lt;AXI4I_MAX_BURST_LENGTH&gt;) \</span>
<span class="cp">                      max_outstanding_reads(&lt;AXI4I_MAX_OUTSTANDING_READS&gt;) \</span>
<span class="cp">                      max_outstanding_writes(&lt;AXI4I_MAX_OUTSTANDING_WRITE&gt;)</span>
</pre></div>
</div>
<p>Typically the AXI4 initiator interface is connected to the AXI4 target (or AXI4
slave) interface of a memory block like DDR.
The external logic would need to inform the HLS module where in the memory block
to access the data referenced by the pointer argument.
This is the same concept as a pointer argument of a software function that runs
on a processor — consider invoking a function <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">foo(int</span> <span class="pre">*ptr_arg)</span></code> in
software, the <code class="docutils literal notranslate"><span class="pre">ptr_arg</span></code> is essentially the address in processor memory for
function <code class="docutils literal notranslate"><span class="pre">foo</span></code> to access.
Hence each argument using AXI4 initiator interface is associated with a
<cite>pointer address interface</cite> for specifying the base address in the connected
memory block that the HLS module will access.
The <cite>pointer address interface</cite> can be configured via the
<code class="docutils literal notranslate"><span class="pre">ptr_addr_interface</span></code> option with two modes, <code class="docutils literal notranslate"><span class="pre">simple</span></code> and <code class="docutils literal notranslate"><span class="pre">axi_target</span></code>.</p>
<ul class="simple">
<li>For <code class="docutils literal notranslate"><span class="pre">simple</span></code>: the HLS module will have a simple input port with the same
name as the pointer argument.
The external logic should set the base pointer address on the input port
before the HLS module starts.</li>
<li>For <code class="docutils literal notranslate"><span class="pre">axi_target</span></code>: the HLS module will create a register behind the AXI4
target interface.
The external logic should use AXI4 write transaction to set the base pointer
address via the AXI4 target interface.
The address offset of the register can be found in the
<a class="reference internal" href="#axi-target-addr-map"><span class="std std-ref">AXI4 Target Interface Address Map</span></a> section of the <a class="reference internal" href="#shls-report"><span class="std std-ref">SmartHLS Report</span></a>.
A driver function will be generated to set the register (see
<a class="reference internal" href="#axi-initiator-ptr-addr-driver"><span class="std std-ref">AXI4 Initiator Argument’s Pointer Address Driver Functions</span></a>).</li>
<li>The default <code class="docutils literal notranslate"><span class="pre">ptr_addr_interface</span></code> is <code class="docutils literal notranslate"><span class="pre">simple</span></code>; but when the
default-to-<code class="docutils literal notranslate"><span class="pre">axi_target</span></code> interface pragma (see
<a class="reference internal" href="pragmas.html#pragma-interface-default"><span class="std std-ref">Default All Interfaces to Use AXI4 Target</span></a>) is used, the default <code class="docutils literal notranslate"><span class="pre">ptr_addr_interface</span></code>
becomes <code class="docutils literal notranslate"><span class="pre">axi_target</span></code>.</li>
</ul>
<p>To illustrate further about pointer address, consider the following example,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">incr</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="cp">#pragma HLS interface argument(ptr) type(axi_initiator) ptr_addr_interface(axi_target)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
        <span class="n">ptr</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// Increment the pointer by 1 byte.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In this example, when we start the incr hardware block, we need to pass the base pointer address using the AXI4 target interface, as specified by the <code class="docutils literal notranslate"><span class="pre">ptr_addr_interface(axi_target)</span></code>.
Assuming we write a base address of 0xFFFF0000 to the AXI4 target interface, then this module will read the data, increment by 3, and write back new data, for each of the ten <code class="docutils literal notranslate"><span class="pre">char</span></code> from memory address 0xFFFF0000 to 0xFFFF0009.</p>
<p>The <cite>num_elements</cite> option is only available for array type arguments. The array
size can be specified or overridden (over the declared size in C++) by
specifying the <cite>num_elements</cite> option.
This option is needed by the <a class="reference internal" href="#sw-hw-co-simulation">SW/HW Co-Simulation</a> feature to know the size of the external memory to be modelled in the simulation testbench; this option does not affect the HLS-generated RTL/circuit.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">AXI4 initiator burst support is currently a beta feature in SmartHLS, and is under active development. Data transfer throughput will be improved and additional features will be added in subsequent SmartHLS releases.</p>
</div>
<p>By default, each read or write to an AXI4 initiator pointer argument in the C++ will become a non-burst AXI4 transaction. However, when the read or write is inside a loop, SmartHLS can detect when a burst transaction can be used instead, and SmartHLS will combine the reads or writes that occur over multiple loop iterations into an AXI4 burst transaction. In order to use a loop to infer an AXI4 burst transfer, the loop should have the following properties:</p>
<ul class="simple">
<li>The loop should be pipelined (see <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>).</li>
<li>The loop bound should be known before the loop executes.</li>
<li>The loop should have no more than 1 read and no more than 1 write to AXI4 initiator pointer arguments.</li>
<li>The addressing for the reads and writes should be incrementing by 1 word per loop iteration.</li>
<li>The reads and writes should not be inside conditional statements.</li>
</ul>
<p>If the user expects a burst read or write to an AXI4 initiator pointer argument, they can use the <code class="docutils literal notranslate"><span class="pre">max_burst_len</span></code> option in the interface pragma to specify the burst length to use when doing a burst read or write transaction for that argument. If the <code class="docutils literal notranslate"><span class="pre">max_burst_len</span></code> is unspecified, SmartHLS will use a default value of <code class="docutils literal notranslate"><span class="pre">16</span></code>. An example of using a loop that meets all the criteria to infer an AXI4 initiator burst is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NUM_ELEMENTS 1000</span>

<span class="kt">void</span> <span class="nf">init_array</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">out_array</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="c1">// In the interface argument, set the max burst length to 64</span>
<span class="cp">#pragma HLS interface argument(out_array) type(axi_initiator)                  \</span>
<span class="cp">    ptr_addr_interface(axi_target) num_elements(NUM_ELEMENTS)                  \</span>
<span class="cp">        max_burst_len(64)</span>

<span class="c1">// Burstable</span>
<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_ELEMENTS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An example of loops that do not meet the burst criteria (and will produce warnings if pipelined) is shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NUM_ELEMENTS 1000</span>

<span class="kt">void</span> <span class="nf">init_array</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">out_array</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="c1">// In the interface argument, set the max burst length to 64</span>
<span class="cp">#pragma HLS interface argument(out_array) type(axi_initiator)                  \</span>
<span class="cp">    ptr_addr_interface(axi_target) num_elements(NUM_ELEMENTS)                  \</span>
<span class="cp">        max_burst_len(64)</span>

<span class="c1">// Not burstable - two writes per iteration</span>
<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_ELEMENTS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
        <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// Not burstable - address is not incrementing by one</span>
<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_ELEMENTS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="c1">// Not burstable - write is inside conditional code</span>
<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_ELEMENTS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SmartHLS also supports allowing multiple AXI4 Initiator burst requests to be left outstanding without stalling the accelerator. By sending more burst requests in advance, the AXI4 target can have more time to respond, potentially reducing the time the SmartHLS accelerator needs to wait.
Using this feature infers internal FIFOs in the design, of size <code class="docutils literal notranslate"><span class="pre">max_ouststanding_&lt;reads/writes&gt;</span> <span class="pre">*</span> <span class="pre">addr_size</span></code> for the ARADDR and AWADDR channels and <code class="docutils literal notranslate"><span class="pre">max_outstanding_&lt;reads/writes&gt;</span> <span class="pre">*</span> <span class="pre">max_burst_len</span> <span class="pre">*</span> <span class="pre">word_size</span></code> for RDATA and WDATA channels.
The <code class="docutils literal notranslate"><span class="pre">max_burst_len</span></code> and <code class="docutils literal notranslate"><span class="pre">max_outstanding_&lt;reads/writes&gt;</span></code> can be set separately for input and output AXI4 Initiator arguments, allowing the user to optimize their read and write burst transactions separately. An example of how to use the interface pragmas to specify this behaviour is shown below.
In this example, <code class="docutils literal notranslate"><span class="pre">addr_size</span></code> depends on the AXI4 interface address width (SmartHLS will generate an interface with address width <code class="docutils literal notranslate"><span class="pre">64</span></code>), and <code class="docutils literal notranslate"><span class="pre">word_size</span></code> depends on the argument type (in this case since the argument is an <code class="docutils literal notranslate"><span class="pre">int</span></code> pointer, the word size is <code class="docutils literal notranslate"><span class="pre">32</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define NUM_ELEMENTS 10000</span>

<span class="c1">// Use AXI initiator to copy data from one cpu-side location to another</span>
<span class="kt">void</span> <span class="nf">cpy_array</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">in_array</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">out_array</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS interface default type(axi_target)</span>
<span class="cp">#pragma HLS interface argument(in_array) type(axi_initiator)                   \</span>
<span class="cp">    num_elements(NUM_ELEMENTS) max_burst_len(256) max_outstanding_reads(8)</span>
<span class="cp">#pragma HLS interface argument(out_array) type(axi_initiator)                  \</span>
<span class="cp">    num_elements(NUM_ELEMENTS) max_burst_len(64) max_outstanding_writes(2)</span>
<span class="c1">// Burstable</span>
<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">NUM_ELEMENTS</span><span class="p">;</span> <span class="o">++</span><span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out_array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_array</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The values specified for these interface pragmas can be tuned to optimize the throughput of the AXI4 Initiator interface. For more information on how to pick these values to improve performance, see <a class="reference internal" href="optimizationguide.html#axi4i-performance-optimization"><span class="std std-ref">Optimizing AXI4 Initiator Performance</span></a>.
For more information on the semantics of the interface pragmas themselves, see the relevant Pragma Guide section: <a class="reference internal" href="pragmas.html#pragma-interface-axi-initiator-argument"><span class="std std-ref">AXI4 Initiator Interface for Pointer Argument</span></a>.
If finer control of the burst transfer is required, consider <a class="reference internal" href="#custom-axi4-using-fifo"><span class="std std-ref">Implementing A Custom AXI4 Master/Slave Using hls::FIFO</span></a>.</p>
</div>
<div class="section" id="axi4-target-interface">
<span id="pointer-arg-axi-target"></span><h4>AXI4 Target Interface<a class="headerlink" href="#axi4-target-interface" title="Permalink to this headline">¶</a></h4>
<p>In contrast to the memory interface and AXI4 initiator interface, when the AXI4
target (or the legacy AXI4 slave below) interface is used, the “memories” for
storing the data is inside the SmartHLS-generated RTL module rather than
outside.  The logic outside of SmartHLS module is responsible for initializing
and/or retrieving the memory content before and/or after the execution of
SmartHLS module.
For example, when a <code class="docutils literal notranslate"><span class="pre">int32_t</span> <span class="pre">array[128]</span></code> argument is configured to use AXI4
target interface, the HLS module will include a 32-bit wide, 128-element deep
on-chip buffer for the <code class="docutils literal notranslate"><span class="pre">array</span></code> argument.
If the argument is an input to the top-level function, initialization of the
on-chip buffer should be performed before the HLS module starts execution.
If the argument is an output, the external logic can retrieve the output value
from the on-chip buffer after HLS module’s execution.
An argument can be both input and output to the top-level function, in which
case the data initialization and retrieval are done before and after the
execution.
The memory-mapped address offset and size of the on-chip buffer can be found in
the <a class="reference internal" href="#axi-target-addr-map"><span class="std std-ref">AXI4 Target Interface Address Map</span></a> section of the <a class="reference internal" href="#shls-report"><span class="std std-ref">SmartHLS Report</span></a>.
Driver functions will be also generated to facilitate data transfer to/from the
on-chip buffer from software (see <a class="reference internal" href="#ptr-arg-driver"><span class="std std-ref">Pointer Argument Driver Functions</span></a>)</p>
<p>The pragma below specifies an AXI4 target interface for a pointer argument
(including array, struct, class types),</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// The axi_target interface type can only be used for function arguments, not for global variables.</span>
<span class="c1">// Add at the beginning of the function definition</span>
<span class="cp">#pragma HLS interface argument(&lt;ARGUMENT_NAME&gt;) type(axi_target) \</span>
<span class="cp">                      num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;) dma(true|false) requires_copy_in(true|false)</span>
</pre></div>
</div>
<p>The <cite>num_elements</cite> option is only available for array type arguments. The array
size can be specified or overridden (over the declared size in C++) by
specifying the <cite>num_elements</cite> option.</p>
<p>The <cite>dma</cite> and <cite>requires_copy_in</cite> options are to configure the behaviour of the
top-level driver function, and do not affect the HLS-generated hardware.
See <a class="reference internal" href="#ptr-arg-pragma-options"><span class="std std-ref">Top-level Driver Options in Pointer Arguments’ AXI4 Target Interface Pragma</span></a> for details about how these two options
affect the top-level driver functions.</p>
<p>When accessing the on-chip buffer via the AXI4 target interface, incremental
burst transfer can be used for better transfer throughput.  However, an AXI4
transaction can not cover addresses that belong to more than one on-chip buffers
(i.e., access more than one arguments in one AXI4 transfer).</p>
<p>Note that the AXI4 target interface can not be applied to a global variable.</p>
</div>
<div class="section" id="legacy-axi4-slave-interface">
<span id="global-variable-axi-slave"></span><h4>Legacy AXI4 Slave Interface<a class="headerlink" href="#legacy-axi4-slave-interface" title="Permalink to this headline">¶</a></h4>
<p>The legacy AXI4 slave interface is similar to the AXI4 target interface in hardware.
The legacy AXI4 slave interface can only be applied to a global variable with a struct data type, where each struct element becomes a memory-mapped register or RAM that can be accessed via the AXI4 slave interface.
The pragma below specifies an AXI4 slave interface,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// For shared global variables:</span>
<span class="c1">// Add before the variable definition</span>
<span class="cp">#pragma HLS interface variable(&lt;GLOBAL_VARIABLE_NAME&gt;) type(axi_slave) concurrent_access(true|false)</span>
</pre></div>
</div>
<p>When the <cite>concurrent_access</cite> option is set to true (default to false), the
external logic can read/write the AXI4 slave interface while the SmartHLS module is
running.  The concurrent access will however reduce the SmartHLS module’s
throughput to access the memory.</p>
<p>After compilation, SmartHLS will generate a report file
(<code class="docutils literal notranslate"><span class="pre">hls_output/reports/axi_slave_memory_map.hls.rpt</span></code>) to specify the address map for
each struct element.
Here is an example struct and its corresponding memory map,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __SLAVE_LAYOUT_H__</span>
<span class="cp">#define __SLAVE_LAYOUT_H__</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="c1">// Define the AXI slave memory layout as a struct in a header file.</span>
<span class="k">struct</span> <span class="n">SlaveLayout</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">sum_result</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">xor_result</span><span class="p">,</span> <span class="n">or_result</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a &#39;SlaveLayout&#39; type global variable in C++ source file (.cpp).</span>
<span class="c1">// Use HLS interface pragma with axi_slave type to specify an AXI4 slave interface.</span>
<span class="cp">#pragma HLS interface variable(global_var) type(axi_slave) concurrent_access(true)</span>
<span class="n">SlaveLayout</span> <span class="n">global_var</span><span class="p">;</span>
</pre></div>
</div>
<p>The corresponding address map report
(<code class="docutils literal notranslate"><span class="pre">hls_output/reports/axi_slave_memory_map.hls.rpt</span></code>) is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Address Map for AXI Slave Interface: global_var

+--------------+-----------+-------------------+----------+
| Word Address | Bit Range | Variables         | Removed? |
+--------------+-----------+-------------------+----------+
| 0            |  15 :  0  | memory.array[0]   |          |
|              |  31 : 16  | memory.array[1]   |          |
|              |  47 : 32  | memory.array[2]   |          |
|              |  63 : 48  | memory.array[3]   |          |
| 1            |  15 :  0  | memory.array[4]   |          |
|              |  31 : 16  | memory.array[5]   |          |
|              |  47 : 32  | memory.array[6]   |          |
|              |  63 : 48  | memory.array[7]   |          |
| 2            |  31 :  0  | memory.a          |          |
|              |  63 : 32  | memory.b          |          |
| 3            |  63 :  0  | memory.sum_result |          |
| 4            |  31 :  0  | memory.xor_result |          |
|              |  63 : 32  | memory.or_result  |          |
| 5            |   0 :  0  | slave_memory_ctrl |          |
+--------------+-----------+-------------------+----------+
</pre></div>
</div>
<ul class="simple">
<li>Note that the first column in the report shows the word-address – multiply
by 8 to get the byte-address.</li>
<li>The last column will indicate the struct elements that are optimized away
from compilation because the SmartHLS module does not access them.</li>
<li>Notice that the last element in the table, <code class="docutils literal notranslate"><span class="pre">slave_memory_ctrl</span></code>, is not part
of the struct definition.  This is a special status control register for the
SmartHLS module. Writing to the address of <code class="docutils literal notranslate"><span class="pre">slave_memory_ctrl</span></code> will start the
SmartHLS module (if the module was not running), and reading the register can
poll the status, a value of 1 indicates the SmartHLS module has finished
running, and 0 otherwise.  This memory-mapped control interface can be useful
for an AXI4 master to control the SmartHLS-generated module’s execution (e.g., a
processor controlling the SmartHLS-generated module).</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>IMPORTANT: the legacy AXI4 slave has some restrictions</strong>,</p>
<ul class="last simple">
<li>A SmartHLS module can have at most one AXI4 slave interface, and the AXI4
slave interface type can only be specified for a global variable with a
struct data type.<ul>
<li>If multiple data need to be placed behind the AXI4 slave interface, you
can define a new struct type to include all the data, then instantiate a
global variable with the struct type, and specify the above pragma for
the global variable.</li>
</ul>
</li>
<li>AXI4 slave interface is incompatible with any top-level that has
<a class="reference internal" href="#module-control-axi-target"><span class="std std-ref">AXI4 Target for Module Control</span></a>. If your design uses any AXI4 slave
interface, you can’t use <a class="reference internal" href="#module-control-axi-target"><span class="std std-ref">AXI4 Target for Module Control</span></a> for any top-level.</li>
<li>The AXI4 slave interface always uses 32-bit address and 64-bit data width.</li>
<li>The AXI4 slave interface only supports the AXI4-lite protocol with
additional support for incremental bursting.</li>
<li>The AxBURST and AxSIZE input signals are ignored by the slave logic.<ul>
<li>Regardless of the actual input values of the AxBURST and AxSIZE signals,
the AXI4 slave always uses the incremental burst type (AxBURST == 1) with a
size of 8 bytes per transfer (AxSIZE == 3).</li>
</ul>
</li>
<li>Byte-enable write (via WSTRB port) must be aligned to the elements in the
struct.<ul>
<li>For the WSTRB bits corresponding to (different bytes of) a common struct
element, these WSTRB bits must be all 1s or all 0s.</li>
<li>For example, if we are writing to a word address that maps to two ‘int’
type integers (4 bytes each, packed together as one 64-bit AXI word), the
upper 4 bits of the WSTRB port must be all 1s or 0s, and the same applies
to the lower 4 bits of the WSTRB port.
That is, we cannot update partial bytes of either ‘int’ type integers, but
updating all bytes of one of the two ‘int’ type integers is allowed.</li>
</ul>
</li>
<li>The SW/HW Co-Simulation is only supported if the top level function is not
pipelined.</li>
<li>When AXI4 slave interface is used, the top-level function must use void
return type.</li>
</ul>
</div>
</div>
</div>
<div class="section" id="hls-fifo-argument">
<span id="rtl-interface-fifo-argument"></span><h3>hls::FIFO Argument<a class="headerlink" href="#hls-fifo-argument" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS provides a <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a> which includes a FIFO
template class for inferring the AXI4-stream like, ready-valid-data (RVD)
interface.  When a <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> type argument is used by the top-level
function, a corresponding RVD interface is always generated.</p>
<p>The RVD interface is useful to transfer data from an upstream producer to a
downstream consumer. The upstream sends the data along with a valid signal to
indicate the data validity, while the downstream controls a ready signal to
indicate its readiness to consume the data.  A data is only transferred when
both valid and ready signals are high at a positive clock edge.</p>
<img alt="_images/rvd_intf.png" class="align-center" src="_images/rvd_intf.png" />
<p>As shown in the above timing diagram, three sets of data are transferred at
the 2rd, 4th, and 6th positive clock edges.
No data transfer occurs at the 3rd positive clock edge because the upstream
does not assert the valid signal.
The data “D2” is also not transferred at the 5th positive clock edge because
the downstream back-pressures the upstream by lowering the ready signal.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> template class is declared as</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pack</span> <span class="o">=</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">FIFO</span><span class="p">;</span>
</pre></div>
</div>
<p>The template argument <code class="docutils literal notranslate"><span class="pre">T</span></code> defines the data type, which can be a scalar data
type or a struct of multiple scalar types. The template argument <code class="docutils literal notranslate"><span class="pre">pack</span></code>
defines whether the scalar elements inside the struct should be packed into a
single data port. When <code class="docutils literal notranslate"><span class="pre">pack</span></code> is false, each scalar element has its own data
port, and all scalar elements in the struct share the same pair of ready and
valid ports.
A <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> argument must be either write-only or read-only. The data and
valid ports always have the same direction (output if write-only, input if
read-only), while the ready port has the opposite direction. The following
table shows the interface ports of the <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> argument depending on
the template parameters.</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="19%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head" colspan="2">Template Parameter</th>
<th class="head">Port Name</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td colspan="2"><code class="docutils literal notranslate"><span class="pre">T</span></code> is a scalar data type  (<code class="docutils literal notranslate"><span class="pre">pack</span></code> is ignored)</td>
<td><div class="first last line-block">
<div class="line">&lt;ARG_NAME&gt;</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
<tr class="row-odd"><td rowspan="2"><p class="first"><code class="docutils literal notranslate"><span class="pre">T</span></code> is a struct of scalars, e.g.,</p>
<p class="last">struct MyAxiStream {
ap_uint&lt;32&gt; data;
ap_uint&lt;8&gt;  keep;
ap_uint&lt;1&gt;  last;
};</p>
</td>
<td><code class="docutils literal notranslate"><span class="pre">pack</span></code> = false</td>
<td><div class="first last line-block">
<div class="line">&lt;ARG_NAME&gt;_data</div>
<div class="line">&lt;ARG_NAME&gt;_keep</div>
<div class="line">&lt;ARG_NAME&gt;_last</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">pack</span></code> = true</td>
<td><div class="first last line-block">
<div class="line">&lt;ARG_NAME&gt;  // 41-bit wide.</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>In the struct type example above, the <code class="docutils literal notranslate"><span class="pre">ap_uint</span></code> template class is from
<a class="reference internal" href="#ap-lib"><span class="std std-ref">C++ Arbitrary Precision Data Types Library</span></a>, which allows you
to define custom bit-width integers.</p>
<p>If you are familiar with the AXI4-stream interface, you may already notice that
the struct example (non-pack case) yields an AXI4-stream interface.
Indeed, this is how to infer AXI4-stream interface using <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> library.</p>
<div class="section" id="implementing-a-custom-axi4-master-slave-using-hls-fifo">
<span id="custom-axi4-using-fifo"></span><h4>Implementing A Custom AXI4 Master/Slave Using hls::FIFO<a class="headerlink" href="#implementing-a-custom-axi4-master-slave-using-hls-fifo" title="Permalink to this headline">¶</a></h4>
<p>In addition to inferring an AXI4-stream interface as shown in the example
above, <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> can also be used to implement a custom AXI4 slave or
AXI4 master.
The AXI4 interface protocol has 5 channels, read address (AR), read data (R),
write address (AW), write data (W), and write response (B). Each channel is an
AXI4 stream interface and can be described in C++ as a <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> object.
For example, the read address channel has an address signal and a length
signal.  The AXI4 channel can be implemented as following in C++ to get the
corresponding AR channel in the RTL interface.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">RdAddrSignals</span> <span class="p">{</span> <span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">;</span>  <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">MyTopFunctoin</span> <span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">RdAddrSignals</span><span class="o">&gt;</span> <span class="n">ar</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RdAddrSignals</span> <span class="n">ar_sig</span><span class="p">;</span>
  <span class="n">ar_sig</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span>
  <span class="n">ar_sig</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>  <span class="c1">// 8-beat burst.</span>
  <span class="n">ar</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ar_sig</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">MyTopFunction</span> <span class="p">(</span>
  <span class="k">input</span> <span class="n">clock</span><span class="p">,</span>
  <span class="k">input</span> <span class="n">reset</span><span class="p">,</span>
  <span class="k">input</span>         <span class="n">ar_ready</span><span class="p">,</span>
  <span class="k">output</span>        <span class="n">ar_valid</span><span class="p">,</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ar_addr</span><span class="p">,</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span>  <span class="n">ar_len</span>
<span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="c-library-for-custom-axi-master-interface">
<h4>C++ Library for Custom AXI Master Interface<a class="headerlink" href="#c-library-for-custom-axi-master-interface" title="Permalink to this headline">¶</a></h4>
<p>SmartHLS provides a C++ library for implementing the AXI4 master interfaces. The
library defines the AXI4 master interface in C++ and provides several API
functions for typical operations. For advanced users hoping to have more
fine-grained custom control, or additional AXI4 interface signals that are not
included in the library, the library can serve as a reference implementation
for customization (create your own AXI4 master library based on SmartHLS’s
<code class="docutils literal notranslate"><span class="pre">axi_interface.hpp</span></code> header file).</p>
<p>To create an AXI4 master interface using SmartHLS’s library, include the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/axi_interface.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>To add an AXI4 master interface, you will need to</p>
<ol class="arabic simple">
<li>Create an instance of the <code class="docutils literal notranslate"><span class="pre">AxiInterface</span></code> class and specify the address width, data width and wstrb width through template parameters.</li>
<li>Pass the created instance by reference to the top-level function.
E.g., <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">MyTop(AxiInterface&lt;/*</span> <span class="pre">ADDR:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;32&gt;,</span> <span class="pre">/*</span> <span class="pre">DATA:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;64&gt;,</span> <span class="pre">/*</span> <span class="pre">WSTRB:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;8&gt;&gt;</span> <span class="pre">&amp;master);</span></code></li>
<li>Use the utility functions (APIs) defined in the header to control the AXI master interface.</li>
</ol>
<p>Below are the API functions to access the AXI master interface.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">Send a read request starting from &#39;byte_addr&#39; for &#39;burst_len&#39; number of transfers.</span>
<span class="cm">- &#39;burst_len&#39; can not be greater than 256 (max: 256) according to AXI4 specification.</span>
<span class="cm">- &#39;burst_type&#39; is optional. The default value is 1 (incremental).</span>
<span class="cm">- &#39;transfer_size&#39; is optional. The default value is automatically set to the full size matching T_DATA.</span>
<span class="cm">  - The byte size per transfer equals to 2 to the power of transfer_size.</span>
<span class="cm">  - e.g., if T_DATA is of an ap_uint&lt;64&gt; or uint64 type, the default transfer_size is 3.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_read_req</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                    <span class="n">T_ADDR</span> <span class="n">byte_addr</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">burst_len</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">burst_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">transfer_size</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">SIZE_MATCHING_T_DATA</span><span class="o">&gt;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Receive the read data (return value) for one read transfer.</span>
<span class="cm">- The function should be called after a read request is sent by &#39;axi_m_read_req&#39;.</span>
<span class="cm">- For a read request with &#39;burst_len&#39; number of transfers, this function</span>
<span class="cm">  should be called for &#39;burst_len&#39; number of times to receive all read data.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="n">T_DATA</span> <span class="n">axi_m_read_data</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Send a write request starting from &#39;byte_addr&#39; for &#39;burst_len&#39; number of transfers.</span>
<span class="cm">- &#39;burst_len&#39; can not be greater than 256 (max: 256) according to AXI4 specification.</span>
<span class="cm">- &#39;burst_type&#39; is optional. The default value is 1 (incremental).</span>
<span class="cm">- &#39;transfer_size&#39; is optional. The default value is automatically set to the full size matching T_DATA.</span>
<span class="cm">  - The byte size per transfer equals to 2 to the power of transfer_size.</span>
<span class="cm">  - e.g., if T_DATA is of an ap_uint&lt;64&gt; or uint64 type, the default transfer_size is 3.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_write_req</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                     <span class="n">T_ADDR</span> <span class="n">byte_addr</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">burst_len</span><span class="p">,</span>
                     <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">burst_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">transfer_size</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">SIZE_MATCHING_T_DATA</span><span class="o">&gt;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Send the write data &#39;val&#39; for one write transfer.</span>
<span class="cm">- The function should be called after a write request is sent by &#39;axi_m_write_req&#39;.</span>
<span class="cm">- For a write request with &#39;burst_len&#39; number of transfers, this function</span>
<span class="cm">  should be called for &#39;burst_len&#39; number of times to send all write data.</span>
<span class="cm">  - &#39;strb&#39; acts as the byte-enable with each bit corresponds to a byte of the data.</span>
<span class="cm">  - &#39;last&#39; should be set to 1 if and only if the current function call</span>
<span class="cm">    corresponds to the last transfer of the current write request.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_write_data</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                      <span class="n">T_DATA</span> <span class="n">val</span><span class="p">,</span> <span class="n">T_WSTRB</span> <span class="n">strb</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">last</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Receive the response acknowledgement for the last write request from the slave.</span>
<span class="cm">- The function should be called after all write data are sent by &#39;axi_m_write_data&#39;.</span>
<span class="cm">- A return value of 0 means &#39;OK&#39;; otherwise indicates an error.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">axi_m_write_resp</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>The read and write operations are independent and therefore can be executed in
parallel at the same time.</p>
<p>Same as the AXI4 slave interface, this AXI4 master interface library only
supports the AXI4-lite protocol with additional support for bursting.</p>
<p>SW/HW Co-Simulation is supported for AXI master, but requires modeling the AXI
slave’s responses to the AXI master in software before the kernel is called. An
example of an AXI4 master interface tested with CoSim is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/axi_interface.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;hls/ap_int.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">simple_master</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">r_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">w_addr</span> <span class="o">=</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Request to read data in burst.</span>
            <span class="n">axi_m_read_req</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span>
                <span class="n">master</span><span class="p">,</span> <span class="n">r_addr</span><span class="p">,</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>

            <span class="c1">// Request to write data in burst.</span>
            <span class="n">axi_m_write_req</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span>
                <span class="n">master</span><span class="p">,</span> <span class="n">w_addr</span><span class="p">,</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Write back the data we read + 1.</span>
        <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">axi_m_read_data</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
        <span class="n">axi_m_write_data</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                               <span class="mh">0xFF</span><span class="p">,</span> <span class="n">is_last</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// After the last write, read the response code.</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">bresp</span> <span class="o">=</span> <span class="n">axi_m_write_resp</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span> <span class="n">axi_if</span><span class="p">(</span>
        <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>

    <span class="c1">// Prepare the data to be read by the AXI master.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RdDataSignals</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span> <span class="n">r_sig</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">resp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">axi_if</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">r_sig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Prepare the write response for the write from AXI master.</span>
    <span class="n">WrRespSignals</span> <span class="n">b_sig</span><span class="p">;</span>
    <span class="n">axi_if</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">b_sig</span><span class="p">);</span>

    <span class="c1">// Run the top-level function that will be synthesize to hardware.</span>
    <span class="n">simple_master</span><span class="p">(</span><span class="n">axi_if</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Clear the write and read request.</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">r_addr</span> <span class="o">=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">ar</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">addr</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">w_addr</span> <span class="o">=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">aw</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">addr</span><span class="p">;</span>

    <span class="c1">// Check that the read and write addresses were as expected.</span>
    <span class="n">failed</span> <span class="o">|=</span> <span class="n">r_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">failed</span> <span class="o">|=</span> <span class="n">w_addr</span> <span class="o">!=</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

    <span class="c1">// Read all of write data.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Check that write data is i + 1.</span>
        <span class="n">failed</span> <span class="o">|=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">w</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">data</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Now that all FIFOs have been cleared, the AXI interface could be prepared</span>
    <span class="c1">// for more calls to the kernel..</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">failed</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASS!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FAILED!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">failed</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="axi4-target-interface-vs-legacy-axi4-slave-interface">
<span id="axi-target-vs-axi-slave"></span><h3>AXI4 Target Interface vs Legacy AXI4 Slave Interface<a class="headerlink" href="#axi4-target-interface-vs-legacy-axi4-slave-interface" title="Permalink to this headline">¶</a></h3>
<p>The AXI4 target interface and the legacy AXI4 slave interface are similar features — implement memories (in the form of RAMs or registers) behind the interfaces, and allow an AXI4 initiator (or called AXI4 master/manager) to access the memories in a memory-mapped manner.
There are however some differences in their limitations and where the interface pragmas can be applied,</p>
<ul class="simple">
<li>The <code class="docutils literal notranslate"><span class="pre">axi_target</span></code> interface pragma can be applied to <a class="reference internal" href="#module-control-axi-target"><span class="std std-ref">module control</span></a>, <a class="reference internal" href="#scalar-arg-axi-target"><span class="std std-ref">scalar arguments</span></a> and <a class="reference internal" href="#pointer-arg-axi-target"><span class="std std-ref">pointer arguments</span></a>, but cannot be applied to global variables.
The legacy <code class="docutils literal notranslate"><span class="pre">axi_slave</span></code> interface pragma can only be applied to <a class="reference internal" href="#global-variable-axi-slave"><span class="std std-ref">at most one global struct variable</span></a> (all memories that need to be made accessible through the legacy AXI4 slave interface must be “wrapped” in the same struct variable).</li>
<li>Both interfaces support incremental burst transfer (fixed burst and wrapping burst are not supported).  For the AXI4 target interface, a burst transaction cannot access more than one argument. For the legacy AXI4 slave interface, a burst transaction can cover any continuous addresses within the address range of the interface.</li>
<li>The AXI4 target interface is only accessible when the HLS module is not running. The legacy AXI4 slave interface’s  <code class="docutils literal notranslate"><span class="pre">concurrent_access</span></code> option can allow the external logic to read/write the AXI4 slave interface while the SmartHLS module is running.</li>
<li>Byte-enable writes (via the WSTRB port) are supported by both interfaces, however the legacy AXI4 slave interface requires the write strobe to be aligned to the struct elements (see <a class="reference internal" href="#global-variable-axi-slave"><span class="std std-ref">Legacy AXI4 Slave Interface</span></a> for more details).</li>
<li>The legacy AXI4 slave interface ignores the AxSIZE signal and always assumes an AxSIZE value of 3 (8 bytes per transfer).  The AXI4 target interface supports any AxSIZE that is not bigger than 3 (because the data bus width is 64-bit, or 8-bytes wide).</li>
<li>When the AXI4 target interface is used, <a class="reference internal" href="#accelerator-driver"><span class="std std-ref">driver functions</span></a> are generated to allow convenient accesses from an attached processor. There is no driver functions for the legacy AXI4 slave interface.</li>
</ul>
</div>
</div>
<div class="section" id="driver-functions-for-axi4-target">
<span id="accelerator-driver"></span><h2>Driver Functions for AXI4 Target<a class="headerlink" href="#driver-functions-for-axi4-target" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS generates C++ driver functions that can be used to control the
generated hardware from an attached processor. This accelerator driver code can
be found in the <code class="docutils literal notranslate"><span class="pre">hls_output/accelerator_drivers</span></code> output directory.
The header file (<code class="docutils literal notranslate"><span class="pre">&lt;PROJ_NAME&gt;_accelerator_driver.h</span></code>) in the directory lists
the user-callable functions that can be used to control each HLS accelerator,
while the <code class="docutils literal notranslate"><span class="pre">&lt;PROJ_NAME&gt;_accelerator_driver.cpp</span></code> file implements the driver
functions.
The driver functions are generated for arguments and module control if they are
configured to use AXI4 target interface.
The following sections will explain different categories of driver functions.</p>
<div class="section" id="module-control-driver-functions">
<span id="module-control-driver"></span><h3>Module Control Driver Functions<a class="headerlink" href="#module-control-driver-functions" title="Permalink to this headline">¶</a></h3>
<p>When a top-level function is configured to use AXI4 target interface for module
control (see <a class="reference internal" href="#module-control-interface"><span class="std std-ref">Module Control Interface</span></a>), SmartHLS generates the
following driver functions,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Returns 1 if the HLS module is idle (or has finished the last invocation).</span>
<span class="kt">int</span> <span class="nf">MyTopFunc_is_idle</span><span class="p">();</span>

<span class="c1">// Starts the HLS module.  All other input arguments are expected to have been set when this function is called.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_start</span><span class="p">();</span>

<span class="c1">// A blocking function that waits for the completion of the HLS module, and returns the return value of the HLS module (if not void).</span>
<span class="n">RETURN_TYPE</span> <span class="nf">MyTopFunc_join</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="scalar-argument-driver-functions">
<span id="scalar-arg-driver"></span><h3>Scalar Argument Driver Functions<a class="headerlink" href="#scalar-argument-driver-functions" title="Permalink to this headline">¶</a></h3>
<p>When a scalar argument is configured to use AXI4 target interface (see
<a class="reference internal" href="#scalar-arg-interface"><span class="std std-ref">Scalar Argument</span></a>), SmartHLS generates the following driver functions,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sets the scalar argument &#39;MyScalarArg&#39; to &#39;val&#39;.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_write_MyScalarArg</span><span class="p">(</span><span class="n">TYPE</span> <span class="n">val</span><span class="p">);</span>

<span class="c1">// Retrieves the value of &#39;MyScalarArg&#39;, that was previously set by the write function above.</span>
<span class="n">TYPE</span> <span class="nf">MyTopFunc_read_MyScalarArg</span><span class="p">();</span>
</pre></div>
</div>
</div>
<div class="section" id="pointer-argument-driver-functions">
<span id="ptr-arg-driver"></span><h3>Pointer Argument Driver Functions<a class="headerlink" href="#pointer-argument-driver-functions" title="Permalink to this headline">¶</a></h3>
<p>For each pointer (including array, struct types) argument that is configured to
use AXI4 target interface (see <a class="reference internal" href="#pointer-arg-axi-target"><span class="std std-ref">AXI4 Target Interface</span></a>), the following
driver functions will be provided:</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// &#39;memcpy&#39; driver functions:</span>
<span class="c1">// The processor performs memory-mapped write/read operations (using the standard memcpy function) to copy data between the memory at &#39;MyPtrArg&#39; and the HLS accelerator.</span>
<span class="c1">// The total size to transfer is defined by the &#39;byte_size&#39; argument.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_memcpy_write_MyPtrArg</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">MyPtrArg</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">byte_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_memcpy_read_MyPtrArg</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">MyPtrArg</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">byte_size</span><span class="p">);</span>

<span class="c1">// &#39;dma&#39; driver functions:</span>
<span class="c1">// The processor offloads the data transfer to a DMA engine to move data between the memory at &#39;MyPtrArg&#39; and the HLS accelerator.</span>
<span class="c1">// The total size to transfer is defined by the &#39;byte_size&#39; argument.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_dma_write_MyPtrArg</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">MyPtrArg</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">byte_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_dma_read_MyPtrArg</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">MyPtrArg</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">byte_size</span><span class="p">);</span>
</pre></div>
</div>
<p>The DMA driver functions can use one of two different DMA engines depending on
the target FPGA family and HLS project settings.
Note that when the HLS project’s target flow is set to <code class="docutils literal notranslate"><span class="pre">Icicle_SoC</span></code> (see
<a class="reference internal" href="constraintsmanual.html#set-project"><span class="std std-ref">set_project</span></a>), SmartHLS by default uses the harden platform DMA (PDMA)
engine in the Microprocessor Sub-System (MSS).
In this case, the DMA driver functions are expected to run on a Linux Operating
System (see <a class="reference internal" href="icicle_setup.html#icicle-linux-image"><span class="std std-ref">Step 5: Flashing the Linux Image to the Board</span></a>), and the processor memory referenced by the
pointer argument (<code class="docutils literal notranslate"><span class="pre">MyPtrArg</span></code>) must be allocated by the <code class="docutils literal notranslate"><span class="pre">hls_malloc</span></code>
function (see <a class="reference internal" href="#allocation-library"><span class="std std-ref">Memory Allocation Library</span></a>).
On PolarFire<sup>®</sup> SoC devices, it is recommended to use the PDMA engine for data
transfer when the transfer size is equal to or bigger than 16KB, and use the memcpy driver
functions when the transfer size is smaller than 16KB.</p>
<p>When targeting other device families, SmartHLS assumes a soft
<a class="reference external" href="https://www.microsemi.com/existing-parts/parts/152556">CoreAXI4DMAController</a>
IP (implemented in FPGA Fabric) is connected with the processor memory and the
HLS accelerator’s AXI4 target interface.
In this case, the <code class="docutils literal notranslate"><span class="pre">DMA_BASE_ADDR</span></code> macro in the accelerator driver header file
(i.e., <code class="docutils literal notranslate"><span class="pre">hls_output/accelerator_drivers/&lt;PROJ_NAME&gt;_accelerator_driver.h</span></code>)
should be updated to the base address of the DMA IP’s AXI4-lite control
interface.</p>
</div>
<div class="section" id="axi4-initiator-argument-s-pointer-address-driver-functions">
<span id="axi-initiator-ptr-addr-driver"></span><h3>AXI4 Initiator Argument’s Pointer Address Driver Functions<a class="headerlink" href="#axi4-initiator-argument-s-pointer-address-driver-functions" title="Permalink to this headline">¶</a></h3>
<p>As explained in <a class="reference internal" href="#pointer-arg-axi-initiator"><span class="std std-ref">AXI4 Initiator Interface</span></a>, an argument using AXI4
initiator interface will have an associated interface for setting the base
pointer address.
The base pointer address is where the argument data can be found by the
accelerator.
Typically the pointer address is an address in the processor memory that
the accelerator will directly access via the AXI4 initiator interface.
When this pointer address interface is configured to AXI4 target, the driver
function below is generated for setting the pointer address:</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Sets pointer address for &#39;MyPtrArg&#39;.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_write_MyPtrArg_ptr_addr</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that when the HLS project’s target flow is set to <code class="docutils literal notranslate"><span class="pre">Icicle_SoC</span></code> (see
<a class="reference internal" href="constraintsmanual.html#set-project"><span class="std std-ref">set_project</span></a>), the driver is assumed to run on a Linux Operating System
(see <a class="reference internal" href="icicle_setup.html#icicle-linux-image"><span class="std std-ref">Step 5: Flashing the Linux Image to the Board</span></a>), and the processor memory referenced by the
pointer argument (<code class="docutils literal notranslate"><span class="pre">MyPtrArg</span></code>) must be allocated by the <code class="docutils literal notranslate"><span class="pre">hls_malloc</span></code>
function (see <a class="reference internal" href="#allocation-library"><span class="std std-ref">Memory Allocation Library</span></a>).</p>
</div>
<div class="section" id="top-level-driver-functions-1">
<span id="top-level-driver-functions"></span><h3>Top-level Driver Functions<a class="headerlink" href="#top-level-driver-functions-1" title="Permalink to this headline">¶</a></h3>
<p>When all interfaces of a HLS module are either AXI4 target or AXI4 initiator,
that means an attached processor can initialize/retrieve all input/output data
of the HLS module and control the HLS module’s execution.
Then SmartHLS will also generate the following driver functions to make it
convenient for replacing the original top-level function in a software program.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Initializes all input argument data, starts the HLS module, waits for its completion, and retrieves output argument data and return value.</span>
<span class="c1">// Can be used as a direct replacement to the original top-level function.</span>
<span class="c1">// Has the same arguments and return type as the top-level function.</span>
<span class="n">RETURN_TYPE</span> <span class="nf">MyTopFunc_hls_driver</span><span class="p">(...);</span>

<span class="c1">// Initializes all input argument data, starts the HLS module</span>
<span class="c1">// Can be used to start the HLS module and resume to execute other parts of the software while the HLS module is running, then later call the _join_and_read_output function below.</span>
<span class="c1">// The arguments are the input arguments of the top-level functions.</span>
<span class="kt">void</span> <span class="nf">MyTopFunc_write_input_and_start</span><span class="p">(...);</span>

<span class="c1">// Blocking function that waits for the HLS module to finish the execution, and retrieves output argument data and return value.</span>
<span class="c1">// The arguments are the output arguments of the top-level functions.</span>
<span class="n">RETURN_TYPE</span> <span class="nf">MyTopFunc_join_and_read_output</span><span class="p">(...);</span>
</pre></div>
</div>
<p>The above top-level driver functions use the individual argument or module
control drivers (as described in above sections) under the hood.</p>
<p>To make all interfaces accessible by an attached processor, one can use the
default interface pragma to set the default interface to AXI4 target for all
arguments and module control (see <a class="reference internal" href="pragmas.html#pragma-interface-default"><span class="std std-ref">Default All Interfaces to Use AXI4 Target</span></a>), and then add
pragmas for <code class="docutils literal notranslate"><span class="pre">axi_initiator</span></code> interface or to configure non-default options.</p>
<div class="section" id="top-level-driver-options-in-pointer-arguments-axi4-target-interface-pragma">
<span id="ptr-arg-pragma-options"></span><h4>Top-level Driver Options in Pointer Arguments’ AXI4 Target Interface Pragma<a class="headerlink" href="#top-level-driver-options-in-pointer-arguments-axi4-target-interface-pragma" title="Permalink to this headline">¶</a></h4>
<p>For a pointer argument, the top-level driver functions will use ‘memcpy’ or DMA
transfer functions based on the <code class="docutils literal notranslate"><span class="pre">dma(&lt;true|false&gt;)</span></code> option of the argument’s
interface pragma.
If the option is not specified, the top-level driver functions will use ‘memcpy’
transfer by default.</p>
<p>SmartHLS determines the input and/or output direction for a pointer argument
based on the read and write accesses of the pointer argument in the C++
implementation.
That is,</p>
<ul class="simple">
<li>If the pointer argument is only being read in the C++ code, then the direction
is input and the top-level driver functions will only transfer the data into
the HLS module’s corresponding buffer before starting the HLS module;</li>
<li>If the pointer argument is write-only, then its direction is output and the
top-level driver functions will only transfer the data back from the HLS
module’s corresponding buffer after the HLS module finishes execution;</li>
<li>If the pointer argument is both read and written by the C++ code, then its
direction is inout and data transfer happens before and after the HLS module
execution.</li>
</ul>
<p>However, there can be cases where the direction analysis is not accurate and
requires user intervention to specify a <code class="docutils literal notranslate"><span class="pre">requires_copy_in</span></code> option in the
interface pragma,</p>
<ul>
<li><p class="first">Case 1: the C++ implementation only writes to a pointer argument, but doesn’t
write to all elements (“partial update to a write-only memory”).</p>
<ul>
<li><p class="first">For example, say we have an <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">array[100]</span></code> argument configured to use
AXI4 target interface, and the C++ implementation never reads from the
array, and only writes to one element of the array (e.g., <code class="docutils literal notranslate"><span class="pre">array[k]</span></code>,
imagine <code class="docutils literal notranslate"><span class="pre">k</span></code> is another argument that changes between invocations).
SmartHLS will create a depth-100 buffer for the argument.</p>
</li>
<li><p class="first">Since the argument is write-only, by default SmartHLS considers the argument
as an “output” and the top-level drivers will not initialize the buffer by
transferring data from processor memory to the buffer before the HLS module
starts.
As only one element of the array is updated, the rest of the 99 elements are
left uninitialized in the buffer.
When HLS module finishes execution, the top-level drivers transfer all data
in buffer back to processor memory for the “output” argument.</p>
</li>
<li><p class="first">Now the problem is the 99 uninitialized elements are also copied and will
overwrite the correct-yet-supposedly-unchanged elements in the processor
memory.</p>
</li>
<li><p class="first">To avoid this issue, it is required to add a <code class="docutils literal notranslate"><span class="pre">requires_copy_in(true)</span></code>
option to the pointer argument’s AXI4 target interface pragma.
With this option specified, the top-level drivers will make sure to
initialize the buffer by copying data from processor memory, before starting
the HLS module’s execution. Here is an example pragma:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS interface argument(array) type(axi_target) requires_copy_in(true)</span>
</pre></div>
</div>
</li>
<li><p class="first">We will improve the direction analysis to detect such case in a future
release.</p>
</li>
</ul>
</li>
<li><p class="first">Case 2: the C++ implementation reads and writes to a pointer argument, but
only reads the elements that have first been written to.</p>
<ul>
<li><p class="first">For example, let’s consider this simple matrix multiple function:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">matrix_multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">in_A</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">K</span><span class="p">],</span> <span class="kt">int</span> <span class="n">in_B</span><span class="p">[</span><span class="n">K</span><span class="p">][</span><span class="n">N</span><span class="p">],</span> <span class="kt">int</span> <span class="n">out_C</span><span class="p">[</span><span class="n">M</span><span class="p">][</span><span class="n">N</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">out_C</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
                <span class="n">out_C</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_C</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">in_A</span><span class="p">[</span><span class="n">m</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">in_B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">n</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">The <code class="docutils literal notranslate"><span class="pre">out_C</span></code> argument is both read and written by the algorithm as part of
the accumulate operation.
By default SmartHLS will consider <code class="docutils literal notranslate"><span class="pre">out_C</span></code> as “inout” based on the read and
write accesses.
The top-level driver functions will therefore transfer data to/from the
corresponding buffer before and after HLS module execution.</p>
</li>
<li><p class="first">However, we can observe that all writes to <code class="docutils literal notranslate"><span class="pre">out_C[m][n]</span></code> happen after
<code class="docutils literal notranslate"><span class="pre">out_C[m][n]</span></code> have been first written with an initial value of 0.
This means the initial copy-in transfer to the buffer is not necessary.</p>
</li>
<li><p class="first">In this case, user can explicitly add the <code class="docutils literal notranslate"><span class="pre">requires_copy_in(false)</span></code>
option to the interface pragma, such that the top-level driver functions
will skip the copy-in transfer prior to HLS module’s execution:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS interface argument(out_C) type(axi_target) requires_copy_in(false)</span>
</pre></div>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="example-usage-of-the-driver-functions">
<h3>Example Usage of the Driver Functions<a class="headerlink" href="#example-usage-of-the-driver-functions" title="Permalink to this headline">¶</a></h3>
<p>Let’s use the C++ code below as the example input for SmartHLS to synthesize,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// Top-level function that is to be synthesized into a hardware accelerator.</span>
<span class="kt">int</span> <span class="nf">test_function</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
    <span class="cp">#pragma HLS function top</span>
    <span class="cp">#pragma HLS interface default type(axi_target)</span>
    <span class="c1">// Accelerator implementation</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// Original user code that calls the top-level function.</span>
<span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">output_array</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>We will show below several ways to use the driver functions to invoke the HLS
accelerator.</p>
<ul>
<li><p class="first">Invoke the HLS accelerator using a single top-level driver function that
replaces the original call of the software implementation:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="c1">// Invoke the hardware accelerator in a single (blocking) call.</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function_hls_driver</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">output_array</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">If the software runs on the Icicle kit with a Linux Operating System, and an
argument is configured to use DMA transfer in the top-level driver functions,
by specifying <code class="docutils literal notranslate"><span class="pre">dma(true)</span></code> option in the argument’s interface pragma, then
the argument needs to be allocated by a <code class="docutils literal notranslate"><span class="pre">hls_maloc</span></code> call:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/hls_alloc.h&quot;</span><span class="cp"></span>
<span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hls_malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hls_malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// Invoke the hardware accelerator in a single (blocking) call.</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function_hls_driver</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="n">output_array</span><span class="p">);</span>

<span class="n">hls_free</span><span class="p">(</span><span class="n">input_array</span><span class="p">);</span>
<span class="n">hls_free</span><span class="p">(</span><span class="n">output_array</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Invoke and join the HLS accelerator in two steps.
Each step is blocking, but other code can run between steps:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="c1">// Transfer input arguments and start the HLS accelerator.</span>
<span class="n">test_function_write_input_and_start</span><span class="p">(</span><span class="n">input_array</span><span class="p">);</span>

<span class="c1">// Execute other software code on the processor here while the HLS accelerator is running.</span>
<span class="p">...</span>

<span class="c1">// Later, poll for HLS accelerator finish and read output/return value</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function_join_and_read_output</span><span class="p">(</span><span class="n">output_array</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Use each input/output argument’s driver function to transfer input/output,
and use module control functions to start and check finish for the HLS
accelerator:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">...</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="c1">// Transfer input arguments, using memcpy transfer method for arrays.</span>
<span class="n">test_function_memcpy_write_input_array</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="c1">// Start the accelerator</span>
<span class="n">test_function_start</span><span class="p">();</span>

<span class="c1">// Execute other software code on the processor here while the HLS accelerator is running.</span>
<span class="p">...</span>

<span class="c1">// Poll for accelerator finish, read return value.</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function_join</span><span class="p">();</span>

<span class="c1">// Transfer output arguments, using memcpy transfer method for arrays.</span>
<span class="n">test_function_memcpy_read_output_array</span><span class="p">(</span><span class="n">output_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">Same as above, but uses DMA transfer instead of memcpy, and assume the
software runs on top of a Linux Operating System on the Icicle kit:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Use DMA to transfer array arguments, need to be in a space allocated by a hls_maloc call.</span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/hls_alloc.h&quot;</span><span class="cp"></span>
<span class="kt">uint8_t</span> <span class="n">input_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hls_malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<span class="kt">uint8_t</span> <span class="n">output_array</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">hls_malloc</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// Transfer input arguments, using DMA transfer method for arrays.</span>
<span class="n">test_function_dma_write_input_array</span><span class="p">(</span><span class="n">input_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

<span class="c1">// Start the accelerator</span>
<span class="n">test_function_start</span><span class="p">();</span>

<span class="c1">// Execute other software code on the processor here while the HLS accelerator is running.</span>
<span class="p">...</span>

<span class="c1">// Poll for accelerator finish, read return value</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_function_join</span><span class="p">();</span>

<span class="c1">// Transfer output arguments, using DMA transfer method for arrays.</span>
<span class="n">test_function_dma_read_output_array</span><span class="p">(</span><span class="n">output_array</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">...</span>

<span class="n">hls_free</span><span class="p">(</span><span class="n">input_array</span><span class="p">);</span>
<span class="n">hls_free</span><span class="p">(</span><span class="n">output_array</span><span class="p">);</span>
</pre></div>
</div>
</li>
</ul>
</div>
</div>
<div class="section" id="specifying-a-custom-test-bench">
<span id="custom-testbench"></span><h2>Specifying a Custom Test Bench<a class="headerlink" href="#specifying-a-custom-test-bench" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS allows one to use a custom test bench to simulate the hardware generated by SmartHLS.
When a top-level function other than <code class="docutils literal notranslate"><span class="pre">main</span></code> is specified by the user, there are two options for simulation:</p>
<ul class="simple">
<li>Use <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.</li>
<li>A custom test bench must be provided by the user.</li>
</ul>
<p>A custom test bench can be specified to SmartHLS via the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">Constraints</span></code> window:</p>
<a class="reference internal image-reference" href="_images/set_custom_test_bench.png"><img alt="_images/set_custom_test_bench.png" class="align-center" src="_images/set_custom_test_bench.png" style="width: 723.0px; height: 300.0px;" /></a>
<p>One must specify both the name of custom Verilog module as well as the name of the custom test bench file.
It can also be specified directly in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file as the following:</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nv">set_custom_test_bench_module</span> <span class="s2">&quot;testBenchModuleName&quot;</span>
<span class="nv">set_custom_test_bench_file</span> <span class="s2">&quot;testBenchFileName.v&quot;</span>
</pre></div>
</div>
<p>This constraint is also described in <a class="reference internal" href="constraintsmanual.html#set-custom-test-bench-module"><span class="std std-ref">set_custom_test_bench_module</span></a> and <a class="reference internal" href="constraintsmanual.html#set-custom-test-bench-file"><span class="std std-ref">set_custom_test_bench_file</span></a>.</p>
</div>
<div class="section" id="synthesize-hardware-to-fpga">
<h2>Synthesize Hardware to FPGA<a class="headerlink" href="#synthesize-hardware-to-fpga" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS can run Libero to report FPGA resource and timing information.
There are two options for <code class="docutils literal notranslate"><span class="pre">Synthesize</span> <span class="pre">Hardware</span> <span class="pre">to</span> <span class="pre">FPGA</span></code>:</p>
<blockquote>
<div><ol class="arabic simple">
<li>RTL synthesis only for resource results (faster runtime).</li>
<li>RTL synthesis, place and route, for resource and timing results (slower runtime).</li>
</ol>
</div></blockquote>
<p>The following synthesis settings are used by SmartHLS:</p>
<blockquote>
<div><ul class="simple">
<li>Enable Retiming: Yes</li>
<li>Map ROM components to: RAM</li>
<li>Additional options for Synplify: set_option -maxfan 30</li>
</ul>
</div></blockquote>
<p>The following place and route settings are used by SmartHLS:</p>
<blockquote>
<div><ul class="simple">
<li>High effort layout: Yes</li>
</ul>
</div></blockquote>
<p>The Libero project will use block flow (-block_mode 1) to compile the generated IP core in isolation.</p>
<p>For more details, see the following Tcl script that SmartHLS uses to run Libero synthesis, place and route:
<code class="docutils literal notranslate"><span class="pre">&lt;SMARTHLS_INSTALLATION_DIR&gt;\SmartHLS\examples\synthesize_microsemi.tcl</span></code></p>
</div>
<div class="section" id="soc-features-1">
<span id="soc-features"></span><h2>SoC Features<a class="headerlink" href="#soc-features-1" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS can generate a RISC-V processor/accelerator reference SoC, where it generates hardware accelerators and automatically integrates into Microprocessor Sub-System (MSS). The SoC features are currently limited to targeting the <a class="reference external" href="https://www.microchip.com/en-us/development-tool/MPFS-ICICLE-KIT-ES">PolarFire SoC Icicle Kit</a>, and are described in the following sections.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To use SmartHLS with the PolarFire<sup>®</sup> SoC Icicle Kit, certain setup steps are required. Specifically, variables <code class="docutils literal notranslate"><span class="pre">BOARD_IP</span></code> and <code class="docutils literal notranslate"><span class="pre">PROGRAMMER_ID</span></code> need to be
properly specified as environment variables (for command line projects) or as Makefile variable specified in makefile.user (for GUI projects), and the Icicle Kit must be properly configured. For more details on the setup steps, please see <a class="reference internal" href="icicle_setup.html#icicle-setup"><span class="std std-ref">Icicle Kit Setup Instructions</span></a>.</p>
</div>
<div class="section" id="soc-flow-overview">
<h3>SoC Flow Overview<a class="headerlink" href="#soc-flow-overview" title="Permalink to this headline">¶</a></h3>
<p>The high-level steps for SmartHLS to generate a RISC-V reference SoC is shown below.
It receives a C/C++ program as input, where user has specified one or more functions to accelerate in hardware with the pragma, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code>.
Clang, the frontend compiler, transforms the input program to call the generated software drivers functions. The software driver functions handle data transfers from DDR to hardware accelerators, invoke the hardware accelerators, and retrieve any computed results.
The transformed software and generated software driver functions form the software partition, which is compiled with the RISC-V compiler toolchain into a software binary to execute on the RISC-V MSS.
The hardware partition goes through a series of compiler optimizations that optimize the partition for hardware acceleration.
The hardware generation step generates hardware accelerators in Verilog.
It also generates Tcl scripts that contains commands for SmartDesign, which is run to integrate the hardware accelerators and any additional IPs to generate a complete SoC comprising the RISC-V MSS, interconnect, and hardware accelerators.</p>
<a class="reference internal image-reference" href="_images/SoC_flow_overview.png"><img alt="_images/SoC_flow_overview.png" src="_images/SoC_flow_overview.png" style="width: 1000.5px; height: 609.0px;" /></a>
</div>
<div class="section" id="soc-data-transfer-methods-1">
<span id="soc-data-transfer-methods"></span><h3>SoC Data Transfer Methods<a class="headerlink" href="#soc-data-transfer-methods-1" title="Permalink to this headline">¶</a></h3>
<p>For the RISC-V SoC on the PolarFire SoC Icicle Kit, main memory resides in off-chip DDR memory. For each pointer argument of an accelerator, data can be copied from DDR memory to accelerator’s on-chip memory buffer, or it can be accessed directly in DDR by the accelerator. Any access to DDR, whether data is copied or accessed directly, goes through the MSS data cache to maintain cache coherency.
There are three data transfer methods provided to transfer data between DDR memory and hardware accelerators.</p>
<p><strong>CPU Copy</strong>:
The RISC-V CPU in the MSS handles the data transfer between DDR and accelerator’s on-chip memory buffer.
This transfer method is available for pointer arguments specified with the <a class="reference internal" href="pragmas.html#pragma-interface-axi-target-argument"><span class="std std-ref">AXI4 target interface pragma</span></a> (e.g., <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">interface</span> <span class="pre">argument(&lt;ARGUMENT_NAME&gt;)</span> <span class="pre">type(axi_target)</span></code>).
The <code class="docutils literal notranslate"><span class="pre">memcpy_write</span></code> and <code class="docutils literal notranslate"><span class="pre">memcpy_read</span></code> driver functions are used to initiate the CPU Copy transfers in and out of the accelerator’s on-chip memory buffer (see <a class="reference internal" href="#ptr-arg-driver"><span class="std std-ref">Pointer Argument Driver Functions</span></a>).
The CPU copy method is used when the <code class="docutils literal notranslate"><span class="pre">dma</span></code> option of the AXI4 target interface pragma is unspecified or is set to false, where the <a class="reference internal" href="#top-level-driver-functions"><span class="std std-ref">Top-level Driver Functions</span></a> call the <code class="docutils literal notranslate"><span class="pre">memcpy_write</span></code> function for the RISC-V CPU to transfer argument data from DDR to accelerator’s on-chip memory buffer before accelerator starts execution (if data is used as an input to the accelerator), and call the <code class="docutils literal notranslate"><span class="pre">memcpy_read</span></code> function for the RISC-V CPU to copy data from accelerator’s on-chip memory buffer back to DDR after accelerator finishes execution (if data is used as an output from the accelerator).
If data is used as both input and output, both <code class="docutils literal notranslate"><span class="pre">memcpy_read</span></code> and <code class="docutils literal notranslate"><span class="pre">memcpy_write</span></code> are called (see <a class="reference internal" href="#ptr-arg-pragma-options"><span class="std std-ref">Top-level Driver Options in Pointer Arguments’ AXI4 Target Interface Pragma</span></a>).
The CPU Copy method is recommended for data transfer size of less than 16 KBs.
Since CPU is performing the data transfer, <code class="docutils literal notranslate"><span class="pre">hls_alloc</span></code> library does not need to be used to keep data in physically contiguous memory region.</p>
<p><strong>DMA Copy</strong>:
The hardened DMA engine (PDMA) in the MSS transfers the data between DDR and accelerator’s on-chip memory buffer in bursts to achieve high bandwidth data transfer.
As in the CPU Copy method, this transfer method is available for pointer arguments specified with the <a class="reference internal" href="pragmas.html#pragma-interface-axi-target-argument"><span class="std std-ref">AXI4 target interface pragma</span></a> and is used when the <code class="docutils literal notranslate"><span class="pre">dma</span></code> option is set to true (e.g., <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">interface</span> <span class="pre">argument(&lt;ARGUMENT_NAME&gt;)</span> <span class="pre">type(axi_target)</span> <span class="pre">dma(true)</span></code>).
The <code class="docutils literal notranslate"><span class="pre">dma_write</span></code> and <code class="docutils literal notranslate"><span class="pre">dma_read</span></code> driver functions are used to initiate DMA Copy transfers in and out of the accelerator’s on-chip memory buffer (see <a class="reference internal" href="#ptr-arg-driver"><span class="std std-ref">Pointer Argument Driver Functions</span></a>).
When the DMA Copy method is used, the <a class="reference internal" href="#top-level-driver-functions"><span class="std std-ref">Top-level Driver Functions</span></a> call the <code class="docutils literal notranslate"><span class="pre">dma_write</span></code> and <code class="docutils literal notranslate"><span class="pre">dma_read</span></code> functions to copy data in and out of the accelerator’s on-chip memory buffer depending on the argument’s direction (also see <a class="reference internal" href="#ptr-arg-pragma-options"><span class="std std-ref">Top-level Driver Options in Pointer Arguments’ AXI4 Target Interface Pragma</span></a>).
The DMA Copy method is recommended for data transfer size equal to or bigger than 16 KBs, as for small data tranfers, DMA Copy can be slower than CPU Copy.
To transfer data using DMA Copy, user must allocate data in physically contiguous regions with the <code class="docutils literal notranslate"><span class="pre">hls_malloc</span></code> function from the <code class="docutils literal notranslate"><span class="pre">hls_alloc</span></code> library (see <a class="reference internal" href="#allocation-library"><span class="std std-ref">Memory Allocation Library</span></a>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">For pointer arguments specified with AXI4 target interface pragma, both CPU and DMA Copy transfer methods can be used.
The generated accelerator architecture is the same for both transfer methods, with the difference being the driver functions that are used to perform the data tranfers.
Users can call the appropriate driver functions or simply change the <code class="docutils literal notranslate"><span class="pre">dma</span></code> option in the interface pragma to configure the transfer method used by the <a class="reference internal" href="#top-level-driver-functions"><span class="std std-ref">Top-level Driver Functions</span></a>.</p>
</div>
<p><strong>Accelerator Direct Access</strong>:
This method can only be used when an AXI4 Initiator interface is specified for a pointer argument with the <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">interface</span> <span class="pre">argument(&lt;ARGUMENT_NAME&gt;)</span> <span class="pre">type(axi_initiator)</span></code> pragma (see <a class="reference internal" href="pragmas.html#pragma-interface-axi-initiator-argument"><span class="std std-ref">AXI4 Initiator Interface for Pointer Argument</span></a>).
In this case, the accelerator will directly access DDR memory through MSS cache. This method has the advantage that no on-chip memory buffer is required, as the accelerator accesses data directly without it being copied, resulting in lower on-chip memory usage.
This method is recommended when data is not accessed frequently, as the latency for the accelerator to access MSS cache/DDR will be higher than accessing accelerator’s on-chip memory buffer, and is not recommended when large amounts of data needs to be accessed.</p>
<p>As described above, the accelerator’s architecture will be different depending on which data transfer method is being used. Using CPU Copy and DMA Copy will result in on-chip memory buffer being created for AXI Target interface to store the copied data, and using Accelerator Direct Access will not create on-chip memory buffor for AXI Initiator interface. For more details on the generated accelerator architecture, see <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a>.</p>
</div>
<div class="section" id="running-soc-features">
<h3>Running SoC Features<a class="headerlink" href="#running-soc-features" title="Permalink to this headline">¶</a></h3>
<div class="section" id="base-soc-project-programming-cross-compilation">
<h4>Base SoC Project Programming / Cross-Compilation<a class="headerlink" href="#base-soc-project-programming-cross-compilation" title="Permalink to this headline">¶</a></h4>
<p>SmartHLS comes with a pre-built bitstream for PolarFire SoC Icicle Kit, containing a base SoC design. The base SoC design can be programmed to a board in order to cross-compile and test user software
on Linux running on the board.
To program this base SoC, navigate to the SmartHLS tab, and select  <code class="docutils literal notranslate"><span class="pre">RISC-V</span> <span class="pre">SoC</span> <span class="pre">Features</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Base</span> <span class="pre">SoC</span> <span class="pre">with</span> <span class="pre">no</span> <span class="pre">SoC</span> <span class="pre">Accelerators</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Program</span> <span class="pre">board</span> <span class="pre">with</span> <span class="pre">prebuilt</span> <span class="pre">bitstream</span></code>.</p>
<img alt="_images/gui_base_project.png" src="_images/gui_base_project.png" />
<p>In the same sub-menu, there is an option to cross-compile the project software into a binary for RISC-V (<code class="docutils literal notranslate"><span class="pre">Cross-compile</span> <span class="pre">software</span> <span class="pre">for</span> <span class="pre">RISC-V</span></code>), as well as an option to move this binary to an attached
Icicle Kit and run it (<code class="docutils literal notranslate"><span class="pre">Run</span> <span class="pre">software</span> <span class="pre">without</span> <span class="pre">accelerators</span></code>). In order to run software on an attached Icicle Kit, some preliminary setup steps are required, see <a class="reference internal" href="icicle_setup.html#icicle-setup"><span class="std std-ref">Icicle Kit Setup Instructions</span></a>.</p>
</div>
<div class="section" id="reference-soc-generation-1">
<span id="reference-soc-generation"></span><h4>Reference SoC Generation<a class="headerlink" href="#reference-soc-generation-1" title="Permalink to this headline">¶</a></h4>
<p>SmartHLS is also capable of taking the hardware accelerators it generates, and integrating them with the Microprocessor Sub-System (MSS) on a PolarFire SoC FPGA (currently only supports
<a class="reference external" href="https://www.microchip.com/en-us/development-tool/MPFS-ICICLE-KIT-ES">PolarFire SoC Icicle Kit</a>) to create a reference SoC design in SmartDesign. This is done by taking the base SoC
project, adding hardware accelerators as SmartDesign HDL+ cores, and connecting the components using an AXI4 interconnect. To generate this reference SoC design, navigate to the SmartHLS tab, and select
<code class="docutils literal notranslate"><span class="pre">RISC-V</span> <span class="pre">SoC</span> <span class="pre">Features</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Reference</span> <span class="pre">SoC</span> <span class="pre">with</span> <span class="pre">HLS</span> <span class="pre">Accelerator(s)</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">Generate</span> <span class="pre">Libero</span> <span class="pre">Design</span></code>. For more information on the architecture of this reference SoC, see <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a>.</p>
<img alt="_images/gui_reference_soc.png" src="_images/gui_reference_soc.png" />
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In order for accelerators to be automatically integrated into a reference SoC, they must have only AXI4 Target and AXI4 Initiator hardware interfaces. This can be accomplished by specifying
the correct interface pragmas (see interface pragmas section in the <a class="reference internal" href="pragmas.html#pragmas"><span class="std std-ref">SmartHLS Pragmas Manual</span></a>). For more information on the accelerator hardware interface see <a class="reference internal" href="#rtl-interface"><span class="std std-ref">Top-Level RTL Interface</span></a>.</p>
</div>
</div>
<div class="section" id="running-the-reference-soc">
<h4>Running the Reference SoC<a class="headerlink" href="#running-the-reference-soc" title="Permalink to this headline">¶</a></h4>
<p>In the same sub-menu, there are also options to run synthesis and place and route for the reference SoC, which can be used to check timing and resource usage of each accelerator as well as the whole SoC.
There are also options to generate a bitstream and program it to an attached Icicle Kit. Finally, the <code class="docutils literal notranslate"><span class="pre">Run</span> <span class="pre">software</span> <span class="pre">with</span> <span class="pre">accelerators</span></code> option combines the input software with the generated accelerator drivers, and creates a software binary that can run on Linux in the Icicle MSS and drive the SmartHLS accelerators on the fabric.
In order to run software on an attached Icicle Kit, some preliminary steps are required, see <a class="reference internal" href="icicle_setup.html#icicle-setup"><span class="std std-ref">Icicle Kit Setup Instructions</span></a>.</p>
</div>
</div>
<div class="section" id="soc-profiler-1">
<span id="soc-profiler"></span><h3>SoC Profiler<a class="headerlink" href="#soc-profiler-1" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS includes a lightweight profiler that allows the measurement of the amount of time spent transferring data between the CPU and the generated hardware modules. Ideally we want to have a high computation-to-communication ratio to maximize the use of a hardware accelerator. In other words, minimize the amount of communication (time sending and receiving data), and maximize the amount of time the hardware modules are actively processing data.</p>
<p>The SmartHLS soc profiler allows a breakdown analysis of the application runtime to identify potential optimizations. For example, depending on the application, sometimes we can run concurrently multiple hardware modules instead of a sequential execution.  Another example is we can try to overlap communication and computation time to make more efficient use of hardware resources.</p>
<div class="section" id="soc-profiler-overview">
<h4>SoC Profiler Overview<a class="headerlink" href="#soc-profiler-overview" title="Permalink to this headline">¶</a></h4>
<p>In general, when profiling an application there are overheads in the form of storage (for profiling timestamp samples) and runtime caused by timestamp acquisition. SmartHLS tries to minimize this by instantiating a simple 48-bit cycle counter in the FPGA fabric to read the timestamps from and store them in CPU memory. In this context a <cite>timestamp sample</cite> is the value read from the 48-bit cycle counter at a point in time. Obtaining a timestamp this way is as fast as a memory-mapped register read to the cycle counter and the timestamp samples do not use on-chip memory for storage. SmartHLS also automatically instruments the autogenerated driver API functions to read the timestamps. The figure below shows these three aspects of the profiler architecture: the storage, the instrumented software API driver and the cycle counter. In this case foo() and bar() are the functions to be profiled after being compiled to hardware modules.</p>
<a class="reference internal image-reference" href="_images/soc_profiler-hw.drawio.png"><img alt="_images/soc_profiler-hw.drawio.png" class="align-center" src="_images/soc_profiler-hw.drawio.png" style="width: 441.0px; height: 252.0px;" /></a>
</div>
<div class="section" id="soc-profiling-process">
<h4>SoC Profiling process<a class="headerlink" href="#soc-profiling-process" title="Permalink to this headline">¶</a></h4>
<p>The profiling process is very simple, it does not require the user to manually
change the C++ code, just set a few configuration parameters for the profiler.
The process has 3 steps:</p>
<ol class="arabic simple">
<li>Enable hardware counter and software driver API instrumentation</li>
<li>Run the application</li>
<li>Collect and visualize the results</li>
</ol>
<p>The first step is to tell SmartHLS that we need the <cite>soc cycle counter</cite> hardware module to be instantiated as part of the SmartHLS subsystem and to instrument the API software driver to collect the timestamps.  This is done by adding the following line in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file.</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nv">set_parameter</span> SOC_PROFILER_COUNTER <span class="mi">1</span>
</pre></div>
</div>
<p>This is an example of the instrumented code added to the software API driver:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo_start</span><span class="p">()</span> <span class="p">{</span>
<span class="cp">#ifdef HLS_PROFILER_ENABLE</span>
    <span class="c1">// Add the &quot;start&quot; event to the profiler</span>
    <span class="n">foo_prof</span><span class="p">.</span><span class="n">timestamp_start</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="c1">// Run accelerator</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note that the timestamp collection only happens if the <cite>HLS_PROFLIER_ENABLED</cite>
constant is defined during the software compilation process.  This flag can be
defined in the <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> (or <code class="docutils literal notranslate"><span class="pre">Makefile.user</span></code> for IDE projects) like this:</p>
<div class="highlight-Makefile notranslate"><div class="highlight"><pre><span></span><span class="nv">USER_CXX_FLAG</span><span class="o">+=</span>-DHLS_PROFILER_ENABLE
<span class="nv">USER_CXX_FLAG</span><span class="o">+=</span>-DHLS_PROFILER_SAMPLES<span class="o">=</span><span class="m">500</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">HLS_PROFILER_SAMPLES</span></code> is an <cite>optional</cite> software compile parameter used to specify the maximum number of samples to store - in this example we store up to 500 samples. If not specified the default value is set to 100 samples. If the hardware module runs for more than the maximum number of samples it will not cause a buffer overflow,  the profiling would stop once the sample  is full and some sample data would be lost. When this happens a warning message will be printed to the standard output suggesting to increase the sample buffer capacity.</p>
<p>After an application with profiling enabled completes its execution on the FPGA board, the profiler will generate one <cite>.prof</cite> file per top level module in the SmartHLS project, plus one more <cite>.prof</cite> file for the <cite>main()</cite> function. These files follow this naming convention: <code class="docutils literal notranslate"><span class="pre">hls_&lt;functionName&gt;.prof</span></code>. All the  <code class="docutils literal notranslate"><span class="pre">*.prof</span></code> files must be copied from the board to the local host computer into the <code class="docutils literal notranslate"><span class="pre">hls_output/files</span></code> directory in order to analyze and visualize them. This copying will be done automatically if you use the <code class="docutils literal notranslate"><span class="pre">shls</span></code> command from the command line or the SmartHLS GUI to launch/run the application on the board, otherwise, those files will have to be copied over manually.</p>
</div>
<div class="section" id="compiling-and-running-the-profiled-application">
<h4>Compiling and running the profiled application<a class="headerlink" href="#compiling-and-running-the-profiled-application" title="Permalink to this headline">¶</a></h4>
<p>The second step is to compile the hardware and software, and then run the application on the board to collect the results. You can do this in the SmartHLS IDE by clicking <code class="docutils literal notranslate"><span class="pre">RISC-V</span> <span class="pre">SoC</span> <span class="pre">Features</span> <span class="pre">-&gt;</span> <span class="pre">Reference</span> <span class="pre">SoC</span> <span class="pre">with</span> <span class="pre">HLS</span> <span class="pre">Accelerator(s)</span> <span class="pre">-&gt;</span> <span class="pre">Run</span> <span class="pre">software</span> <span class="pre">with</span> <span class="pre">Accelerators</span></code>; or from the command line in a single command like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls soc_accel_proj_run
</pre></div>
</div>
<p>This will go through RTL generation, synthesis, place and route, FPGA programming, compiling software and running the application on the board. After this you should see the <cite>.prof</cite> files under <code class="docutils literal notranslate"><span class="pre">hls_output/files</span></code> on the host machine.</p>
<p>After the FPGA has been configured, and assuming there are no changes to the hardware, you can change the software part, compile it and rerun the executable without having to reprogram the FPGA. In the IDE, you can click the same <code class="docutils literal notranslate"><span class="pre">Run</span> <span class="pre">software</span> <span class="pre">with</span> <span class="pre">accelerators</span></code> button as above, skip the hardware part (i.e. compile software to hardware, generate SoC, place-and-route, program board etc), and run the software part (transform C++ source to invoke accelerator, and cross-compile software with accelerator drivers). You can also explicitly click the Cross-compile software with accelerator drivers button, and then Run software with accelrators (and skip all steps).  Alternatively, from command line, you could just run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls soc_sw_compile_accel
shls run_on_board
</pre></div>
</div>
<p>This will regenerate and copy again the <cite>*.prof</cite> files from the board to the host machine and visualize the results as described in the next section.</p>
</div>
<div class="section" id="visualizing-the-profiled-data">
<h4>Visualizing the profiled data<a class="headerlink" href="#visualizing-the-profiled-data" title="Permalink to this headline">¶</a></h4>
<p>Finally, the third step in the profiling process is to parse the generated .prof files and visualize them.  This can be done from IDE by clicking <code class="docutils literal notranslate"><span class="pre">RISC-V</span> <span class="pre">SoC</span> <span class="pre">Features</span> <span class="pre">-&gt;</span> <span class="pre">Reference</span> <span class="pre">SoC</span> <span class="pre">with</span> <span class="pre">HLS</span> <span class="pre">Accelerator(s)</span> <span class="pre">-&gt;</span> <span class="pre">Run</span> <span class="pre">SoC</span> <span class="pre">Profiler</span> <span class="pre">Viewer</span></code>; or from the command line just type:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls soc_profiler_view
</pre></div>
</div>
<p>This command will print on the terminal a table with the summary of the runtime execution per module displaying the number of samples captured (i.e. the number of times the hardware module was called) minimum, maximum, average and aggregate runtimes per hardware module. By default the units are in microseconds.  In this example, the table shows the profiling summary for a project with four hardware functions: hw_const_add(), hw_const_mult(), hw_sum(), and hw_delay(). A copy of this summary will be stored in a file under this directory: <code class="docutils literal notranslate"><span class="pre">hls_output/reports/hls_soc_profiler.summary.rpt</span></code>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Project: soc_profiler

---------------------------------
Statistics (units in [us]):


--------[ main ]--------
main start      : 0.14 us
main finish     : 32337.18 us
main Delta Time : 32337.04 us

--------[ hw_const_add ]--------
Number of samples: 10
+-------------+-------+--------+-------+-----------+
|             | min   | max    | avg   | aggregate |
+-------------+-------+--------+-------+-----------+
| Write       | 28.43 | 173.54 | 46.22 | 462.21    |
| Accelerator | 20.15 | 21.76  | 20.32 | 203.22    |
| Total       |       |        |       | 665.43    |
+-------------+-------+--------+-------+-----------+

--------[ hw_const_mult ]--------
Number of samples: 10
+-------------+-------+-------+-------+-----------+
|             | min   | max   | avg   | aggregate |
+-------------+-------+-------+-------+-----------+
| Write       | 3.72  | 10.02 | 4.56  | 45.63     |
| Accelerator | 3.23  | 3.58  | 3.32  | 33.18     |
| Read        | 24.47 | 55.26 | 28.68 | 286.76    |
| Total       |       |       |       | 365.57    |
+-------------+-------+-------+-------+-----------+

--------[ hw_delay ]--------
Number of samples: 100
+-------------+------+---------+-------+-----------+
|             | min  | max     | avg   | aggregate |
+-------------+------+---------+-------+-----------+
| Write       | 0.34 | 4.48    | 0.41  | 41.29     |
| Accelerator | 3.54 | 3000.98 | 33.54 | 3353.72   |
| Read        | 0.36 | 0.8     | 0.39  | 39.2      |
| Total       |      |         |       | 3434.21   |
+-------------+------+---------+-------+-----------+

--------[ hw_sum ]--------
Number of samples: 10
+-------------+-------+-------+-------+-----------+
|             | min   | max   | avg   | aggregate |
+-------------+-------+-------+-------+-----------+
| Write       | 3.2   | 10.26 | 4.12  | 41.16     |
| Accelerator | 17.97 | 18.26 | 18.02 | 180.25    |
| Read        | 0.36  | 0.93  | 0.45  | 4.49      |
| Total       |       |       |       | 225.9     |
+-------------+-------+-------+-------+-----------+
</pre></div>
</div>
<p>In this context, the word <code class="docutils literal notranslate"><span class="pre">Write</span></code> refers to the time that the CPU spent <cite>writing</cite> data to the hardware module. The word <code class="docutils literal notranslate"><span class="pre">Accelerator</span></code> (or <code class="docutils literal notranslate"><span class="pre">Acc</span></code> in the plot below) refers to the time the hardware module was active. And finally, the word <code class="docutils literal notranslate"><span class="pre">Read</span></code> refers to the time that the CPU spent reading data from the hardware module’s on-chip buffers.
The command <code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">soc_profiler_view</span></code> will also open up a GUI that shows a plot of the runtime. The GUI has a way to zoom-in to specific region of the plot.  Also, the mouse pointer can hover over specific bar on the plot and the corresponding annotated data will be displayed.</p>
<a class="reference internal image-reference" href="_images/soc_profiler-plot.drawio.png"><img alt="_images/soc_profiler-plot.drawio.png" class="align-center" src="_images/soc_profiler-plot.drawio.png" style="width: 802.0px; height: 1011.0px;" /></a>
<p>By default, the plot will display the timelines for all the hardware modules in the project by including all the <cite>*.prof</cite> files in the plot. However, a single timeline for a specific hardware module can be displayed using the <cite>SOC_PROFILER_FILENAME</cite> makefile variable and assign to it the specific <cite>.prof</cite> file to visualize. For example, to display only the time line for the hardware module <code class="docutils literal notranslate"><span class="pre">hw_const_sum()</span></code> you can type this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls soc_profiler_view  <span class="nv">SOC_PROFILER_FILENAME</span><span class="o">=</span>./hls_output/files/hls_hw_const_sum.prof
</pre></div>
</div>
<p>Note the <code class="docutils literal notranslate"><span class="pre">hls_</span></code> prefix in the filename. The plot will look like this:</p>
<a class="reference internal image-reference" href="_images/soc_profiler-single-top.png"><img alt="_images/soc_profiler-single-top.png" class="align-center" src="_images/soc_profiler-single-top.png" style="width: 1340.5px; height: 803.6px;" /></a>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently this feature to selectively show a single timeline is only available via the command line.</p>
</div>
<p>In some cases, such as in automated regression tests, an interactive GUI is not required or not even desired. The profiler can be run in non-interactive mode like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls soc_profiler_view <span class="nv">SOC_PROFILER_INTERACTIVE</span><span class="o">=</span><span class="m">0</span>
</pre></div>
</div>
<p>In this case the summary file is still generated and printed to the terminal but the GUI plot will not be displayed. Instead an image file with <cite>.png</cite> format will be generated under <code class="docutils literal notranslate"><span class="pre">hls_output/reports/hls_soc_profiler.png</span></code>.  Note that this non-interactive option is only available from the command line.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At the moment, the SoC Profiler only measures the time for arguments declared as <code class="docutils literal notranslate"><span class="pre">AXI</span> <span class="pre">Target</span></code>, with or without DMA.  Arguments defined as <code class="docutils literal notranslate"><span class="pre">AXI</span> <span class="pre">Initiator</span></code> will only show a small bar in the <cite>write</cite> timeline  representing the CPU passing the pointer address from which the hardware module will initiate read or write requests. The <code class="docutils literal notranslate"><span class="pre">AXI</span> <span class="pre">Initiator</span></code> transfer time is implicitly considered as part of the hardware module runtime (i.e. <cite>Acc</cite> timeline). In the example above, the <cite>hw_const_add()</cite> module has no <cite>read</cite> time. That is because the CPU is not reading the on-chip buffer, the hardware module itself is transferring the data back to the CPU memory directly and therefore the time consumed is considered as part of the module execution runtime.</p>
</div>
</div>
</div>
</div>
<div class="section" id="report-files">
<span id="smarthls-reports"></span><h2>Report Files<a class="headerlink" href="#report-files" title="Permalink to this headline">¶</a></h2>
<div class="section" id="smarthls-report">
<span id="shls-report"></span><h3>SmartHLS Report<a class="headerlink" href="#smarthls-report" title="Permalink to this headline">¶</a></h3>
<p>After compiling software to hardware, SmartHLS generates one summary report file
for each top-level function (<code class="docutils literal notranslate"><span class="pre">hls_output/reports/summary.hls.&lt;top_level&gt;.rpt</span></code>)
to show some insights about the generated RTL circuit, such as the top-level
module interface, scheduling information, memory usage, etc. The following will
explain each section of the report file.</p>
<div class="section" id="rtl-interface-section">
<h4>RTL Interface Section<a class="headerlink" href="#rtl-interface-section" title="Permalink to this headline">¶</a></h4>
<p>The RTL Interface section shows the interfaces used by the top-level module.
Below is an example of the RTL interface report table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+----------------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                      |
+-------------+--------------------+---------------------------------+------------------+------------------+
| C++ Name    | Interface Type     | Signal Name                     | Signal Bit-width | Signal Direction |
+-------------+--------------------+---------------------------------+------------------+------------------+
|             | Clock &amp; Reset      | clk (positive edge)             | 1                | input            |
|             |                    | reset (synchronous active high) | 1                | input            |
+-------------+--------------------+---------------------------------+------------------+------------------+
|             | Control            | finish                          | 1                | output           |
|             |                    | ready                           | 1                | output           |
|             |                    | start                           | 1                | input            |
+-------------+--------------------+---------------------------------+------------------+------------------+
| input_fifo  | Input AXI4 Stream  | input_fifo_ready                | 1                | output           |
|             |                    | input_fifo_valid                | 1                | input            |
|             |                    | input_fifo                      | 8                | input            |
+-------------+--------------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
<p>The table shows the interface for each top-level function argument (or global
variable accessed by both the SW testbench and the top-level function - see
<a class="reference internal" href="#ptr-arg-and-shared-gv"><span class="std std-ref">Shared Global Variable</span></a>).</p>
<blockquote>
<div><ul class="simple">
<li>The first column of the table shows the C++ source name of the argument or
global variable.</li>
<li>The second column shows the interface types used for this argument or
global variable.</li>
<li>The last three columns list the names, bit-widths, and directions for all
the signals that are included in the interface. For example, the AXI4 Stream
interface has three signals in this case, <cite>input_fifo</cite> for the 8-bit data,
with associated valid and ready signals.</li>
</ul>
</div></blockquote>
<p>Note that the <cite>Clock &amp; Reset</cite> and the <cite>Control</cite> interfaces are the standard
module control interfaces that are always used by any SmartHLS-generated module,
and hence there is no C++ name attached to them.</p>
<p>For more details about the RTL interface, please refer to <a class="reference internal" href="#rtl-interface"><span class="std std-ref">Top-Level RTL Interface</span></a>.</p>
<div class="section" id="axi4-initiator-target-interface-in-the-rtl-interface-report">
<span id="axi-initiator-target-intf-rpt"></span><h5>AXI4 Initiator/Target Interface in the RTL Interface Report<a class="headerlink" href="#axi4-initiator-target-interface-in-the-rtl-interface-report" title="Permalink to this headline">¶</a></h5>
<p>As described in <a class="reference internal" href="#rtl-interface"><span class="std std-ref">Top-Level RTL Interface</span></a>, AXI4 Initiator/Target can be used for many
different types of interfaces. For example, let’s say we have the following
top-level function:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#define SIZE 16

int top(int *arg1, int *arg2, int *arg3) {
#pragma HLS function top
#pragma HLS interface control          type(axi_target)
#pragma HLS interface argument(arg1)   type(axi_initiator) ptr_addr_interface(axi_target) num_elements(SIZE)
#pragma HLS interface argument(arg2)   type(axi_initiator) ptr_addr_interface(simple)     num_elements(SIZE)
#pragma HLS interface argument(arg3)   type(axi_target)                                   num_elements(SIZE)
    ...
}
</pre></div>
</div>
<p>The corresponding RTL interface report will be:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+------------------------------------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                                                    |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
| C++ Name | Interface Type                      | Signal Name                     | Signal Bit-width | Signal Direction |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
|          | Clock &amp; Reset                       | clk (positive edge)             | 1                | input            |
|          |                                     | reset (synchronous active high) | 1                | input            |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
|          | Control via AXI4 Target             | axi4target_*                    |                  |                  |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
| arg1     | AXI4 Initiator                      | axi4initiator_*                 |                  |                  |
|          | with ptr_addr_interface(axi_target) | axi4target_*                    |                  |                  |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
| arg2     | AXI4 Initiator                      | axi4initiator_*                 |                  |                  |
|          | with ptr_addr_interface(simple)     | arg2                            | 64               | input            |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
| arg3     | AXI4 Target                         | axi4target_*                    |                  |                  |
+----------+-------------------------------------+---------------------------------+------------------+------------------+
</pre></div>
</div>
<p>When the top-level module uses AXI4 Initiator/Target, it will have many
<code class="docutils literal notranslate"><span class="pre">axi4initiator_*</span></code>/<code class="docutils literal notranslate"><span class="pre">axi4target_*</span></code> ports respectively, with varying widths
and directions. As a result, the <code class="docutils literal notranslate"><span class="pre">Signal</span> <span class="pre">Bit-width</span></code> and the <code class="docutils literal notranslate"><span class="pre">Signal</span>
<span class="pre">Direction</span></code> columns for the ports are left blanked. These ports are commonly
used by all AXI4 Initiator/Target interfaces of the top-level module.</p>
<p>In the above example:</p>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="#module-control-axi-target"><span class="std std-ref">AXI4 Target for Module Control</span></a> is used. The <code class="docutils literal notranslate"><span class="pre">Signal</span> <span class="pre">Name</span></code> no longer
shows <code class="docutils literal notranslate"><span class="pre">finish</span></code>, <code class="docutils literal notranslate"><span class="pre">ready</span></code>, and <code class="docutils literal notranslate"><span class="pre">start</span></code> as in the case of
<a class="reference internal" href="#module-control-simple"><span class="std std-ref">Simple Module Control Interface</span></a>.</li>
<li><code class="docutils literal notranslate"><span class="pre">arg1</span></code> and <code class="docutils literal notranslate"><span class="pre">arg2</span></code> are <a class="reference internal" href="#pointer-arg-axi-initiator"><span class="std std-ref">AXI4 Initiator Interfaces for Pointer
Argument</span></a>, with the pointer address interface
being <code class="docutils literal notranslate"><span class="pre">axi_target</span></code> and <code class="docutils literal notranslate"><span class="pre">simple</span></code> respectively. These 2 arguments each
corresponds to 2 lines in the report, one for the AXI4 Initiator argument
itself and the other for the corresponding pointer address interface. Note
that for the case of <code class="docutils literal notranslate"><span class="pre">ptr_addr_interface(simple)</span></code>, the HLS module will
have a simple input port with the same name as the pointer argument (in this
example, the port is <code class="docutils literal notranslate"><span class="pre">arg2</span></code>) with a well-defined bit-width and direction
(<code class="docutils literal notranslate"><span class="pre">64</span></code> and <code class="docutils literal notranslate"><span class="pre">input</span></code> in this case).</li>
<li><code class="docutils literal notranslate"><span class="pre">arg3</span></code> is an <a class="reference internal" href="#pointer-arg-axi-target"><span class="std std-ref">AXI4 Target Interface for Pointer
Argument</span></a>, although an argument that’s
<a class="reference internal" href="#scalar-arg-axi-target"><span class="std std-ref">AXI4 Target for Scalar Argument</span></a> will also show a similar line.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="scheduling-result">
<h4>Scheduling Result<a class="headerlink" href="#scheduling-result" title="Permalink to this headline">¶</a></h4>
<p>The scheduling result section primarily shows the cycle latency of each basic
block inside each function.
A basic block is a collection of instructions that always run together.
Below is an example table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Basic Block Latencies:

+-------------------------------------------------------------------------------------------------+
| Function: sobel_filter (non-pipelined function)                                                 |
+-----------------------------------------------+---------------+---------------------------------+
| Basic Block                                   | Cycle Latency | Location in Source Code         |
+-----------------------------------------------+---------------+---------------------------------+
| entry                                         | 1             | sobel.c:9-10,24                 |
| for_cond1_preheader                           | 1             | sobel.c:24-25,28                |
| for_cond18_preheader                          | 2             | sobel.c:25,29,35                |
| for_cond18_preheader_cond_end43_2_2_crit_edge | 1             | sobel.c:25,35                   |
| for_inc75                                     | 1             | sobel.c:24                      |
| for_end77                                     | 1             | sobel.c:51                      |
| cond_false32_2_2                              | 6             | sobel.c:35,37                   |
| cond_end43_2_2                                | 4             | sobel.c:25,35,37,42-43,45-46,48 |
+-----------------------------------------------+---------------+---------------------------------+
</pre></div>
</div>
<p>SmartHLS’s <cite>Schedule Viewer</cite> is more helpful in this case to visualize the
scheduling and the control-flow between basic blocks.</p>
</div>
<div class="section" id="pipeline-result">
<h4>Pipeline Result<a class="headerlink" href="#pipeline-result" title="Permalink to this headline">¶</a></h4>
<p>The pipeline result section reports the initiation interval, pipeline length, iteration count, and latency for each pipelined loop or function.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+--------------------+---------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
| Label              | Function            | Basic Block | Location in Source Code        | Initiation Interval | Pipeline Length | Iteration Count | Latency |
+--------------------+---------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
| gaussian_loop      | gaussian_filter     | while_body  | line 63 of gaussian_filter.cpp | 1                   | 7               | n/a             | n/a     |
| loop_test_checker  | test_output_checker | for_body    | line 39 of test_util.cpp       | 1                   | 3               | 262144          | 262146  |
| loop_test_injector | test_input_injector | for_body    | line 19 of test_util.cpp       | 1                   | 2               | 262144          | 262145  |
+--------------------+---------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
</pre></div>
</div>
<p>The iteration count and latency may not be available for a pipelined function or a pipelined loop with non-deterministic loop bound.
Please refer to <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a> and <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a> for more details.
SmartHLS’s <cite>Schedule Viewer</cite> also gives more details about how individual instructions are scheduled inside each pipeline.</p>
</div>
<div class="section" id="memory-usage-1">
<span id="memory-usage"></span><h4>Memory Usage<a class="headerlink" href="#memory-usage-1" title="Permalink to this headline">¶</a></h4>
<p>The memory usage section lists the memories used by the generated circuit, grouped by the type of memory architecture.
Please refer to <a class="reference internal" href="hwarchitecture.html#mem-arch"><span class="std std-ref">Memory Architecture</span></a> section for more details about the memory architecture used by SmartHLS.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+-------------------------------------------------------------------------------------------------------------------------+
| Local Constant Memories                                                                                                 |
+-------+--------------------------------------------------------+------+-------------+------------+-------+--------------+
| Name  | Accessing Function(s)                                  | Type | Size [Bits] | Data Width | Depth | Read Latency |
+-------+--------------------------------------------------------+------+-------------+------------+-------+--------------+
| gauss | blackscholes_hw (concurrent access through an arbiter) | ROM  | 8192        | 32         | 256   | 1            |
+-------+--------------------------------------------------------+------+-------------+------------+-------+--------------+

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Shared Local Memories                                                                                                                                               |
+-------------+-------------------------------------------------------------------------------------+---------------+-------------+------------+-------+--------------+
| Name        | Accessing Function(s)                                                               | Type          | Size [Bits] | Data Width | Depth | Read Latency |
+-------------+-------------------------------------------------------------------------------------+---------------+-------------+------------+-------+--------------+
| bdata_0     | blackscholes_hw, option_pricing (concurrent access through an arbiter)              | Register      | 32          | 32         | 1     | 0            |
| bdata_1     | blackscholes_hw, option_pricing (concurrent access through an arbiter)              | Register      | 32          | 32         | 1     | 0            |
| idata_0     | mersenne_twister_init_hw, option_pricing (concurrent access through an arbiter)     | Register      | 1           | 1          | 1     | 0            |
| idata_1     | mersenne_twister_init_hw, option_pricing (concurrent access through an arbiter)     | Register      | 32          | 32         | 1     | 0            |
| init_fifo   | mersenne_twister_generate_hw, mersenne_twister_init_hw                              | FIFO (LUTRAM) | 64          | 32         | 2     | 1            |
| random_fifo | blackscholes_hw, mersenne_twister_generate_hw                                       | FIFO (LUTRAM) | 64          | 32         | 2     | 1            |
| tdata_0     | mersenne_twister_generate_hw, option_pricing (concurrent access through an arbiter) | Register      | 32          | 32         | 1     | 0            |
| tdata_1     | mersenne_twister_generate_hw, option_pricing (concurrent access through an arbiter) | Register      | 32          | 32         | 1     | 0            |
+-------------+-------------------------------------------------------------------------------------+---------------+-------------+------------+-------+--------------+

+-------------------------------------------------------------------------------------------------------------------------------+
| Aliased Memories                                                                                                              |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+--------------+
| Name                   | Memory Controller   | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth | Read Latency |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+--------------+
| foo_entry_local_array1 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     | 1            |
| foo_entry_local_array2 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     | 1            |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+--------------+

+---------------------------------------------------------------------------------------------------------+
| I/O Memories                                                                                            |
+--------+-----------------------+----------------------+-------------+------------+-------+--------------+
| Name   | Accessing Function(s) | Type                 | Size [Bits] | Data Width | Depth | Read Latency |
+--------+-----------------------+----------------------+-------------+------------+-------+--------------+
| rd_arr | kernel                | ROM                  | 0           | 16         | 0     | 1            |
| rd_reg | kernel                | Register (Read-Only) | 0           | 16         | 0     | 0            |
| wr_arr | kernel                | RAM                  | 0           | 16         | 0     | 1            |
| wr_reg | kernel                | Register             | 0           | 16         | 0     | 0            |
+--------+-----------------------+----------------------+-------------+------------+-------+--------------+
</pre></div>
</div>
<p>The example tables above show the accessing functions and the hardware implementation of each “memory” in the software.</p>
<blockquote>
<div><ul class="simple">
<li>The <cite>Type</cite> column shows how a memory is implemented in hardware, which could be in RAM, ROM (read-only), register or FIFO (only applicable to <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> type variables in C++).</li>
<li>The <cite>Size</cite> column reports the total size of the memory in bits, equals to <cite>Data Width</cite> * <cite>Depth</cite>.</li>
<li>The <cite>Data Width</cite> refers to the bit-width of the data ports of a RAM/FIFO, or the bit-width of a register.</li>
<li>The <cite>Depth</cite> field represents the depth of a RAM or FIFO, and it is always 1 for register.</li>
<li><cite>Aliased Memories</cite> have an additional column showing the name of the <cite>Memory Controller</cite> of which the memory is being placed behind.
So you can see which memories are aliasing and being put behind the same memory controller to support aliased memory accesses.</li>
<li><cite>I/O Memories</cite> have <cite>Size</cite> and <cite>Depth</cite> to be 0. This is because I/O interface memories are not instantiated inside the SmartHLS-generated circuit.</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="axi4-target-interface-address-map">
<span id="axi-target-addr-map"></span><h4>AXI4 Target Interface Address Map<a class="headerlink" href="#axi4-target-interface-address-map" title="Permalink to this headline">¶</a></h4>
<p>This section shows the memory-mapped address offsets, sizes, and directions of
all AXI4 Target interfaces. We will use the same example as in the
<a class="reference internal" href="#axi-initiator-target-intf-rpt"><span class="std std-ref">AXI4 Initiator/Target Interface in the RTL Interface Report</span></a> section to demonstrate:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>#define SIZE 16

int top(int *arg1, int *arg2, int *arg3) {
#pragma HLS function top
#pragma HLS interface control          type(axi_target)
#pragma HLS interface argument(arg1)   type(axi_initiator) ptr_addr_interface(axi_target) num_elements(SIZE)
#pragma HLS interface argument(arg2)   type(axi_initiator) ptr_addr_interface(simple)     num_elements(SIZE)
#pragma HLS interface argument(arg3)   type(axi_target)                                   num_elements(SIZE)
    ...
}
</pre></div>
</div>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>====== 5. AXI4 Target Interface Address Map ======

Compatibility of HLS accelerator with reference SoC features: No.
SoC feature is only supported for PolarFire SoC Icicle Kit, and all accelerator interfaces need to be either axi_target or axi_initiator:
  - The interfaces of the following argument(s), global variable(s), and/or module control are not axi_target or axi_initiator:
    arg2 (pointer address interface).

+-----------------------------------------------------------------------------+
| Accelerator Function: top (Address Space Range: 0x80)                       |
+---------------------------------+----------------+--------------+-----------+
| Argument                        | Address Offset | Size [Bytes] | Direction |
+---------------------------------+----------------+--------------+-----------+
| Return Value                    | 0x00           | 8            | output    |
| Module Control                  | 0x08           | 4            | inout     |
| arg1 (pointer address register) | 0x10           | 4            | input**   |
| arg3                            | 0x40           | 64*          | output    |
+---------------------------------+----------------+--------------+-----------+

* On PolarFire SoC devices, it is recommended to use the PDMA engine for data transfer when the transfer size is bigger than 16KB, and use the memcpy driver functions when the transfer size is smaller than 16KB.
See memcpy and dma transfer driver functions in hls_output/accelerator_drivers/vector_add_soc_accelerator_driver.[h|cpp]

** The base pointer address of axi_initiator interface argument is an input to the accelerator. The actual direction of the argument can be different, depending on the read/write accesses through the pointer (or array/struct) argument in the C++ implementation.
</pre></div>
</div>
<p>Firstly, this section prints whether the top-level module is compatible with the
SmartHLS-generated reference SoC (see <a class="reference internal" href="#soc-features-1">SoC Features</a>). For a top-level module
to be compatible and thus can be integrated into the reference SoC, it needs to
satisfy the following conditions:</p>
<blockquote>
<div><ul class="simple">
<li>The project has to be an <code class="docutils literal notranslate"><span class="pre">Icicle_SoC</span></code> project (see <a class="reference internal" href="constraintsmanual.html#set-project"><span class="std std-ref">set_project</span></a> in
the <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a>).</li>
<li>All interfaces of the top-level has to be either <code class="docutils literal notranslate"><span class="pre">type(axi_target)</span></code>, or
<code class="docutils literal notranslate"><span class="pre">type(axi_initiator)</span> <span class="pre">ptr_addr_interface(axi_target)</span></code>. This includes the
module control. This section will print out all the SoC incompatible
interfaces. In this example, since <code class="docutils literal notranslate"><span class="pre">arg2</span></code> has a simple pointer address
interface, it is incompatible with the reference SoC.</li>
</ul>
</div></blockquote>
<p>If all interfaces are SoC-compatible, the report will print the default base
address of the top-level module in the reference SoC instead e.g.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>====== 5. AXI4 Target Interface Address Map ======

Compatibility of HLS accelerator with reference SoC features: Yes.
Default base address in reference SoC: 0x70000000.
</pre></div>
</div>
<p>Secondly, this section prints the table containing the memory-mapped address
offset, size, and direction of all arguments using AXI4 Target.</p>
<blockquote>
<div><ul class="simple">
<li>In this example, since <code class="docutils literal notranslate"><span class="pre">top()</span></code> has an <code class="docutils literal notranslate"><span class="pre">int</span></code> return type which is
non-void, the table will show a row for <code class="docutils literal notranslate"><span class="pre">Return</span> <span class="pre">Value</span></code>, which is always
at offset 0x0, of size 8, and with <code class="docutils literal notranslate"><span class="pre">output</span></code> direction. For top-level
functions that have <code class="docutils literal notranslate"><span class="pre">void</span></code> return type, there will be no <code class="docutils literal notranslate"><span class="pre">Return</span> <span class="pre">Value</span></code>
row in the table.</li>
<li>Since the Module Control uses AXI4 Target, there will be a row for <code class="docutils literal notranslate"><span class="pre">Module</span>
<span class="pre">Control</span></code> which is always at offset 0x8 (regardless of whether the return
type is <code class="docutils literal notranslate"><span class="pre">void</span></code> or not), of size 4, and with <code class="docutils literal notranslate"><span class="pre">inout</span></code> direction. For
top-level functions that have simple module control, there will be no
<code class="docutils literal notranslate"><span class="pre">Module</span> <span class="pre">Control</span></code> row in the table.</li>
<li><code class="docutils literal notranslate"><span class="pre">arg1</span></code> is <code class="docutils literal notranslate"><span class="pre">type(axi_initiator)</span> <span class="pre">ptr_addr_interface(axi_target)</span></code>, so there
will be a row for the AXI4 Target pointer address register.</li>
<li><code class="docutils literal notranslate"><span class="pre">arg2</span></code> is <code class="docutils literal notranslate"><span class="pre">type(axi_initiator)</span> <span class="pre">ptr_addr_interface(simple)</span></code>, so there
will NOT be a row for it in this table because it doesn’t use AXI4 Target
pointer address register.</li>
<li><code class="docutils literal notranslate"><span class="pre">arg3</span></code> is <code class="docutils literal notranslate"><span class="pre">type(axi_target)</span></code> so there will be a row for the
corresponding register/on-chip buffer.</li>
<li>Any arguments with other interface types will not appear in this table since
they do not use AXI4 Target.</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="simulation-and-rtl-synthesis-place-route-report">
<h3>Simulation and RTL Synthesis, Place &amp; Route Report<a class="headerlink" href="#simulation-and-rtl-synthesis-place-route-report" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS also generates a summary report (<code class="docutils literal notranslate"><span class="pre">hls_output/reports/summary.results.rpt</span></code>) to show
the results of simulation and RTL synthesis + Place &amp; Route.
Below is an example report:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>====== 1. Simulation Cycle Latency ======

Number of calls:        6,105
Cycle latency:        6,134
SW/HW co-simulation: PASS

====== 2. Timing Result ======

+--------------+---------------+-------------+-------------+----------+-------------+
| Clock Domain | Target Period | Target Fmax | Worst Slack | Period   | Fmax        |
+--------------+---------------+-------------+-------------+----------+-------------+
| clk          | 10.000 ns     | 100.000 MHz | 5.775 ns    | 4.225 ns | 236.686 MHz |
+--------------+---------------+-------------+-------------+----------+-------------+

The reported Fmax is for the HLS core in isolation (from Libero&#39;s post-place-and-route timing analysis).
When the HLS core is integrated into a larger system, the system Fmax may be lower depending on the critical path of the system.

====== 3. Resource Usage ======

+--------------------------+----------+--------+------------+
| Resource Type            | Used     | Total  | Percentage |
+--------------------------+----------+--------+------------+
| Fabric + Interface 4LUT* | 488 + 72 | 108600 | 0.52       |
| Fabric + Interface DFF*  | 397 + 72 | 108600 | 0.43       |
| I/O Register             | 0        | 852    | 0.00       |
| User I/O                 | 0        | 284    | 0.00       |
| uSRAM                    | 0        | 1008   | 0.00       |
| LSRAM                    | 2        | 352    | 0.57       |
| Math                     | 0        | 336    | 0.00       |
+--------------------------+----------+--------+------------+

* Interface 4LUTs and DFFs are occupied due to the uses of LSRAM, Math, and uSRAM.
  Number of interface 4LUTs/DFFs = (36 * #.LSRAM) + (36 * #.Math) + (12 * #.uSRAM) = (36 * 2) + (36 * 0) + (12 * 0) = 72.
</pre></div>
</div>
<p>The first section shows the result of <cite>SW/HW co-simulation</cite>, including the
number of calls of the top-level function, the total cycle latency for running
the whole simulation, and whether the SW/HW co-simulation has passed.</p>
<p>Note that when <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a> is used, the auto-generated RTL
testbench for SW/HW co-simulation can inject a new set of inputs to the
top-level module without waiting for the previous “function calls” to finish.
And because of this overlapped execution, you could see the average cycle per
call being close to the reported initiation interval of the pipelined function.
For instance, the example report above is from a pipelined function with an
initiation interval of 1, and we can see that the average cycle per call is
very close to 1 (6,134/6,105).</p>
</div>
<div class="section" id="logic-level-distribution-1">
<span id="logic-level-distribution"></span><h3>Logic Level Distribution<a class="headerlink" href="#logic-level-distribution-1" title="Permalink to this headline">¶</a></h3>
<p>The number of levels of logic (or logic levels) in a design is an indication of
how much combinatorial logic (e.g. LUTs, carry-chains) there is between registers
(Flip-Flops). The more pipelined the design is, the lower the number of logic
levels will be and higher frequencies may be achieved. However, more registers
will be required. In general, having lower logic levels is a good practice
specially when a design needs to run at higher frequencies.</p>
<p>Different algorithm implementations, HLS #pragmas or even project settings will
impact the number of logic levels differently. A logic level distribution plot
can help you visualize the impact of those options and assess any tradeoffs.
Considering the number of levels of logic early in the design flow allows easier
modifications upfront rather than in later stages of the design during the more
time-consuming place &amp; route and timing closure processes.</p>
<p>The logic level distribution histogram can easily be generated from the IDE by
clicking on <code class="docutils literal notranslate"><span class="pre">SmartHLS</span> <span class="pre">-&gt;</span> <span class="pre">Plot</span> <span class="pre">Logic</span> <span class="pre">Level</span> <span class="pre">Distribution</span></code>; or from the command
line by just typing this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls logic_level_histogram
</pre></div>
</div>
<p>This command will run RTL synthesis first, which is required before generating the
logic level histogram. After synthesis this command will generate a timing analysis
report from which the logic levels are extracted. As an example, for Part1 of the
<a class="reference external" href="https://www.microsemi.com/document-portal/doc_download/1245532-legup-hls-tutorial">SmartHLS Sobel Tutorial</a>
the histogram looks like this:</p>
<a class="reference internal image-reference" href="_images/sobel_part1_logic_level_histogram.png"><img alt="_images/sobel_part1_logic_level_histogram.png" class="align-center" src="_images/sobel_part1_logic_level_histogram.png" style="width: 628.0px; height: 476.0px;" /></a>
<dl class="docutils">
<dt>Two files are generated under the <code class="docutils literal notranslate"><span class="pre">hls_output/reports/</span></code> directory:</dt>
<dd><ul class="first last simple">
<li><code class="docutils literal notranslate"><span class="pre">logic_level_hist.ta.hist</span></code> - it is a plain text file that contains the raw
histogram data. First column is the logic level, the second column is the
number of paths in that level.</li>
<li><code class="docutils literal notranslate"><span class="pre">logic_level_hist.ta.png</span></code> - the plot file in <code class="docutils literal notranslate"><span class="pre">.png</span></code> format.</li>
</ul>
</dd>
</dl>
<p>The plot shows a gradient from green (left) to red (right) indicating that it
would be better for Place &amp; Route and timing purposes to have as many paths
towards the left much as possible and minimize those with higher logic levels.</p>
<p>The next two sections show the timing and resource usage results, parsed from
Libero’s report files after running RTL Synthesis and Place &amp; Route.
The target period is what you set in <a class="reference internal" href="#smarthls-constraints"><span class="std std-ref">SmartHLS Constraints</span></a>. If the <cite>Clock
Period</cite> is not set, SmartHLS uses a default clock period for the target FPGA
family (see the table in <a class="reference internal" href="#smarthls-constraints"><span class="std std-ref">SmartHLS Constraints</span></a>).</p>
</div>
</div>
<div class="section" id="schedule-viewer-1">
<span id="schedule-viewer"></span><h2>Schedule Viewer<a class="headerlink" href="#schedule-viewer-1" title="Permalink to this headline">¶</a></h2>
<p>The Schedule Viewer shows information on how the top-level function was scheduled in hardware by SmartHLS.
This includes information on the flow of control between different functions and blocks of execution,
as well as the cycle by cycle schedule of the operations in hardware.</p>
<p>The Schedule Viewer can be launched by clicking the “Launch Schedule Viewer” button in the SmartHLS IDE.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Toolbar.png"><img alt="_images/Schedule_Viewer_Toolbar.png" class="align-center" src="_images/Schedule_Viewer_Toolbar.png" style="width: 349.0px; height: 30.0px;" /></a>
<p>Alternatively, if using the Linux commandline, you can run the Schedule Viewer command.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ shls scheduleviewer
</pre></div>
</div>
<p>The Schedule Viewer has the Explorer tab and four views: the Call Graph, Control Flow Graph, Schedule Chart and Pipeline Viewer.
The Explorer tab lets you navigate between the functions and blocks within the design.
The Call Graph contains the directed graph of which software functions are called by which other software functions within the top-level function.
The Control Flow Graph shows the control flow of execution between the blocks within each function for if/else conditionals and loops.
The Schedule Chart and Pipeline Viewer shows the scheduling of instructions within a block or a pipeline on a cycle-by-cycle basis.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer.png"><img alt="_images/Schedule_Viewer.png" class="align-center" src="_images/Schedule_Viewer.png" style="width: 681.6px; height: 520.8px;" /></a>
<div class="section" id="background-llvm-internal-representation-used-by-smarthls">
<h3>Background: LLVM Internal Representation used by SmartHLS<a class="headerlink" href="#background-llvm-internal-representation-used-by-smarthls" title="Permalink to this headline">¶</a></h3>
<p>The instructions displayed in the Schedule Viewer are from the LLVM compiler that SmartHLS is built on.
These assembly-like instructions are called <a class="reference external" href="https://llvm.org/docs/LangRef.html">LLVM intermediate representation (IR)</a>.
Some understanding of the LLVM IR is beneficial when using the Schedule Viewer.</p>
<p>For example, given the 32-bit code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">5</span>
</pre></div>
</div>
<p>This C++ code could be represented as instructions in LLVM IR as:</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
<span class="nv">%result</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="m">5</span>
</pre></div>
</div>
<p>In LLVM IR, intermediate variables are prefixed with a “%”.
Each operation (add/sub) includes the bitwidth “i32” indicating 32-bit integer.
The add operands are %a + %b and the result is stored in a temporary 32-bit variable %0.
The subtract operands are %0 – 5 and the result is stored in the variable %result.</p>
<p>Basic blocks are also important concepts in LLVM IR.
A basic block is a group of instructions that always run together with a single entry point at the beginning and a single exit point at the end.
A basic block in LLVM IR always has a label at the beginning and a branching instruction at the end (<code class="docutils literal notranslate"><span class="pre">br</span></code>, <code class="docutils literal notranslate"><span class="pre">ret</span></code>, etc.).
Control flow occurs between basic blocks.</p>
<p>Here the <code class="docutils literal notranslate"><span class="pre">body.0</span></code> basic block performs some operations and then branches unconditionally to another basic block labeled <code class="docutils literal notranslate"><span class="pre">body.1</span></code>.</p>
<div class="highlight-llvm notranslate"><div class="highlight"><pre><span></span><span class="nl">body.0:</span>
  <span class="nv nv-Anonymous">%0</span> <span class="p">=</span> <span class="k">add</span> <span class="k">i32</span> <span class="nv">%a</span><span class="p">,</span> <span class="nv">%b</span>
  <span class="nv">%result</span> <span class="p">=</span> <span class="k">sub</span> <span class="k">i32</span> <span class="nv nv-Anonymous">%0</span><span class="p">,</span> <span class="m">5</span>
  <span class="k">br</span> <span class="k">label</span> <span class="nv">%body.1</span>
</pre></div>
</div>
<p>All of the basic blocks and instructions shown in the Scheduler Viewer are directly from the LLVM IR optimized by SmartHLS before being compiled into Verilog.</p>
</div>
<div class="section" id="call-graph">
<h3>Call Graph<a class="headerlink" href="#call-graph" title="Permalink to this headline">¶</a></h3>
<p>When you open the Scheduler Viewer, the default view is of the Call Graph.
You can also click on the “Call Graph” tab at the top.
The Call Graph shows the top-level function and all of the sub-functions that are called.</p>
<p>For example the following code has a function <code class="docutils literal notranslate"><span class="pre">main</span></code> which calls <code class="docutils literal notranslate"><span class="pre">top_level</span></code> which in turn calls
<code class="docutils literal notranslate"><span class="pre">helper_func_0</span></code> and <code class="docutils literal notranslate"><span class="pre">helper_func_1</span></code>.
The <code class="docutils literal notranslate"><span class="pre">noinline</span></code> attributes makes sure that SmartHLS does not inline these small functions into the
main function body, making sure we can see them in the Call Graph.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">helper_func_0</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gv</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">helper_func_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gv</span> <span class="o">-=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">top_level</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">helper_func_0</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">helper_func_1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">top_level</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will generate the Call Graph shown below.
The Call Graph shows that <code class="docutils literal notranslate"><span class="pre">main</span></code> calls <code class="docutils literal notranslate"><span class="pre">top_level</span></code>, which in turn calls <code class="docutils literal notranslate"><span class="pre">helper_func_0</span></code> and <code class="docutils literal notranslate"><span class="pre">helper_function_1</span></code>.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Call_Graph.png"><img alt="_images/Schedule_Viewer_Call_Graph.png" class="align-center" src="_images/Schedule_Viewer_Call_Graph.png" style="width: 681.6px; height: 520.8px;" /></a>
</div>
<div class="section" id="control-flow-graph">
<h3>Control Flow Graph<a class="headerlink" href="#control-flow-graph" title="Permalink to this headline">¶</a></h3>
<p>The Control Flow Graph can be brought up by clicking on any function in the Explorer tab.
The Control Flow Graph shows the connections between basic blocks and shows which basic blocks can branch to which other basic blocks.
Each basic block in graph is showed with the corresponding source location consists of the filename and line numbers.
The cycle latency of the basic block is also showed in the graph.</p>
<p>For example the following code has an if/else statement and then a for-loop in the else body.
This has multiple code blocks and branches to different sections of the code.</p>
<div class="highlight-c notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span></span><span class="k">volatile</span> <span class="kt">int</span> <span class="n">gv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#define N 1000</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gv</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">gv</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This Control Flow Graph shows the two paths of the if statement on the right and the else statement on the left, and the for-loop in the left middle bubbles.
Control flow is represented by an arrow, where a basic block will only branch into another basic block that it points to.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Control_Flow_Graph.png"><img alt="_images/Schedule_Viewer_Control_Flow_Graph.png" class="align-center" src="_images/Schedule_Viewer_Control_Flow_Graph.png" style="width: 777.6px; height: 602.4px;" /></a>
</div>
<div class="section" id="schedule-chart">
<h3>Schedule Chart<a class="headerlink" href="#schedule-chart" title="Permalink to this headline">¶</a></h3>
<p>If you click on a non-pipelined block, the Schedule Chart will open.
This shows the scheduling of instructions within a block on a cycle-by-cycle basis.</p>
<p>For the following example, two multiplies are made then added and stored to a variable.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">mult1</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">coeff1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mult2</span> <span class="o">=</span> <span class="n">coeff2</span> <span class="o">*</span> <span class="n">coeff2</span><span class="p">;</span>
<span class="n">gv</span> <span class="o">=</span> <span class="n">mult1</span> <span class="o">+</span> <span class="n">mult2</span><span class="p">;</span>
</pre></div>
</div>
<p>In the Schedule Chart, we can see the instructions that these lines of code turn into and the cycles they are scheduled for.
For example, we can see the add is scheduled for cycle 4 and takes 1 cycle.
You can mouse over the scheduled instructions in the Schedule Chart and the selected instruction will be highlighted in yellow.
Instructions that the highlighted instruction depend on will be outlined in red and the instructions that depend on the highlighted instruction will be outlined in orange.
Here the add depends on the two multiplies highlighted in red. The store highlighted in orange depends on this add.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Schedule_Chart.png"><img alt="_images/Schedule_Viewer_Schedule_Chart.png" class="align-center" src="_images/Schedule_Viewer_Schedule_Chart.png" style="width: 699.3px; height: 444.5px;" /></a>
</div>
<div class="section" id="pipeline-viewer">
<h3>Pipeline Viewer<a class="headerlink" href="#pipeline-viewer" title="Permalink to this headline">¶</a></h3>
<p>If you click on a pipelined block, the Pipeline Viewer will open.
This shows the scheduling of instructions within a pipelined block on a cycle-by-cycle basis.</p>
<p>For the following example a value is loaded an array, added to a value, then it is stored back into the array.
This is done repeatedly in a loop and the loop is pipelined.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeff1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the Pipeline Viewer, we find the name and initiation interval (II) for the pipeline at the top.
The column headings in the first row show the clock cycle and pipeline stages for each column.
The remaining rows show the instructions that run in the pipeline at each stage.
The left-most column indicates the loop iteration for the instructions in the row starting from Iteration 0. For function pipelines, Iteration 0 corresponds to the first input.
If you hold your mouse over an instruction you will see more details about the operation type.
In the pipeline viewer, the right-most column highlighted in a thick black box shows the behavior of the pipeline in steady state.
The last row shown in the pipeline viewer (Iteration 1) is the first iteration of the pipeline in steady state.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Pipeline_Viewer.png"><img alt="_images/Schedule_Viewer_Pipeline_Viewer.png" class="align-center" src="_images/Schedule_Viewer_Pipeline_Viewer.png" style="width: 697.9px; height: 444.5px;" /></a>
</div>
</div>
<div class="section" id="instantiating-smarthls-ip-core-in-libero-smartdesign">
<span id="smartdesign"></span><h2>Instantiating SmartHLS IP Core in Libero SmartDesign<a class="headerlink" href="#instantiating-smarthls-ip-core-in-libero-smartdesign" title="Permalink to this headline">¶</a></h2>
<p>After we use SmartHLS to design a hardware IP component, we will want to
instantiate the component into Libero SmartDesign and integrate this core into
our larger system. When SmartHLS generates the hardware, SmartHLS will also
generate (under <code class="docutils literal notranslate"><span class="pre">hls_output/scripts</span></code> directory) a root <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code>
script and one <code class="docutils literal notranslate"><span class="pre">create_hdl_plus_&lt;top_level&gt;_top.tcl</span></code> script for each top-level
function in your C++ design. These scripts can be used to easily instantiate the
SmartHLS-generated IP core(s) into Libero SmartDesign. For example, let’s say we
have a design with 3 top-level functions <code class="docutils literal notranslate"><span class="pre">foo</span></code>, <code class="docutils literal notranslate"><span class="pre">bar</span></code>, and <code class="docutils literal notranslate"><span class="pre">baz</span></code>. The root
<code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> is used to source all top-level specific HDL+ scripts:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">create_hdl_plus_foo_top.tcl</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">create_hdl_plus_bar_top.tcl</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">create_hdl_plus_baz_top.tcl</span></code></li>
</ul>
</div></blockquote>
<p>If you want to instantiate all 3 SmartHLS-generated IP cores in Libero
SmartDesign, you can run the root <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code>. Otherwise, if you
only want to instantiate a single IP core of a particular top-level e.g.
<code class="docutils literal notranslate"><span class="pre">foo</span></code>, you can run just run the <code class="docutils literal notranslate"><span class="pre">create_hdl_plus_foo_top.tcl</span></code>.</p>
<a class="reference internal image-reference" href="_images/create_hdl_plus.drawio.png"><img alt="_images/create_hdl_plus.drawio.png" class="align-center" src="_images/create_hdl_plus.drawio.png" style="width: 273.0px; height: 151.0px;" /></a>
<p>Now, let’s consider a simple example with only one top-level <code class="docutils literal notranslate"><span class="pre">sobel_filter()</span></code>
to demonstrate how you can run the tcl script. Firstly, when SmartHLS finishes
generating the hardware, you will see the log message in the console which
includes the full path to the root <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Generating HDL+ Tcl script to be imported in SmartDesign: C:\Users\&lt;username&gt;\hls_workspace\sobel_part3\create_hdl_plus.tcl.
</pre></div>
</div>
<p>Now we can use Libero to open a Libero project, create a new SmartDesign, and
give the newly created SmartDesign a suitable name. Alternatively, we can also
open an existing SmartDesign.</p>
<a class="reference internal image-reference" href="_images/create_SmartDesign_in_Libero.png"><img alt="_images/create_SmartDesign_in_Libero.png" class="align-center" src="_images/create_SmartDesign_in_Libero.png" style="width: 275.0px; height: 97.0px;" /></a>
<p>We now go to the Libero <code class="docutils literal notranslate"><span class="pre">Project</span></code> menu and select <code class="docutils literal notranslate"><span class="pre">Execute</span> <span class="pre">Script</span></code> and give
the path to the generated <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> script as shown in the figures
below. Then click <code class="docutils literal notranslate"><span class="pre">Run</span></code>. Running the Tcl script will add the
SmartHLS-generated HDL+ component (<code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> in this example), all
required Verilog files, memory initialization files, and other dependencies to
the Libero project. Alternatively, because this design only has 1 top-level,
running the top-level specific <code class="docutils literal notranslate"><span class="pre">create_hdl_plus_sobel_filter_top.tcl</span></code> will
achieve the same effect.</p>
<a class="reference internal image-reference" href="_images/projects_execute_script.png"><img alt="_images/projects_execute_script.png" class="align-center" src="_images/projects_execute_script.png" style="width: 260.0px; height: 325.0px;" /></a>
<a class="reference internal image-reference" href="_images/execute_script.png"><img alt="_images/execute_script.png" class="align-center" src="_images/execute_script.png" style="width: 605.0px; height: 153.0px;" /></a>
<p>As shown in the figures below, we can now instantiate the component in
SmartDesign by right-clicking on the HDL+ component (<code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> in
this example) in the <code class="docutils literal notranslate"><span class="pre">Design</span> <span class="pre">Hiearchy</span></code> panel on the left and selecting
<code class="docutils literal notranslate"><span class="pre">Instantiate</span> <span class="pre">in</span> <span class="pre">system</span></code>. In the SmartDesign system we will now see the new IP
component (<code class="docutils literal notranslate"><span class="pre">sobel_filter_top_0</span></code> in this example).</p>
<a class="reference internal image-reference" href="_images/instantiate_in_system.png"><img alt="_images/instantiate_in_system.png" class="align-center" src="_images/instantiate_in_system.png" style="width: 393.0px; height: 190.0px;" /></a>
<a class="reference internal image-reference" href="_images/new_IP_component.png"><img alt="_images/new_IP_component.png" class="align-center" src="_images/new_IP_component.png" style="width: 335.0px; height: 199.0px;" /></a>
<p>The generated <code class="docutils literal notranslate"><span class="pre">create_hdl_plus_sobel_filter_top.tcl</span></code> script will automatically
group ports as AXI4 Master, AXI4 Slave or AXI4 Stream interfaces if they match
the corresponding AXI4 specifications. In this example, since the
<code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> IP component used SmartHLS FIFOs as top-level arguments
and they match AXI4 Stream specifications, SmartHLS has automatically grouped
the <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> data/ready/valid ports as AXI4 Stream
interfaces.</p>
<p>Similarly, if your top-level uses either AXI4 Initiator or AXI4 Target
interfaces, the script will group all AXI4 Initiator signals
<code class="docutils literal notranslate"><span class="pre">axi4initiator_*</span></code> into a bus, and all AXI4 Target signals <code class="docutils literal notranslate"><span class="pre">axi4target_*</span></code>
into a bus, if applicable.</p>
<p>(For more details about the different types of AXI4 interfaces, please refer to
<a class="reference internal" href="#rtl-interface"><span class="std std-ref">Top-Level RTL Interface</span></a>.)</p>
<p>We also have the option to expose the sub-signals under the AXI4 bus. This will
allow us to connect individual ports instead of the entire bus. To do this,
right click on the AXI4 bus on the SmartHLS-generated IP component and choose
<code class="docutils literal notranslate"><span class="pre">Show/Hide</span> <span class="pre">BIF</span> <span class="pre">Pins</span></code>. Then choose the sub-signals as appropriate. For example,
in the figures below, if we choose all 3 sub-signals of the AXI4 Stream
interface and press OK, we will see the 3 corresponding ports in the IP
component: <code class="docutils literal notranslate"><span class="pre">output_fifo_ready</span></code> as an input, and <code class="docutils literal notranslate"><span class="pre">output_fifo[7:0]</span></code> and
<code class="docutils literal notranslate"><span class="pre">output_fifo_axi4stream</span></code> as the outputs.</p>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals1.png"><img alt="_images/AXI4_Stream_subsignals1.png" class="align-center" src="_images/AXI4_Stream_subsignals1.png" style="width: 241.0px; height: 173.0px;" /></a>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals2.png"><img alt="_images/AXI4_Stream_subsignals2.png" class="align-center" src="_images/AXI4_Stream_subsignals2.png" style="width: 190.0px; height: 159.0px;" /></a>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals3.png"><img alt="_images/AXI4_Stream_subsignals3.png" class="align-center" src="_images/AXI4_Stream_subsignals3.png" style="width: 202.0px; height: 115.0px;" /></a>
</div>
<div class="section" id="hardware-integration-of-smarthls-modules-into-soc-smartdesigns">
<span id="soc-hw-integration"></span><h2>Hardware Integration of SmartHLS modules into SoC SmartDesigns<a class="headerlink" href="#hardware-integration-of-smarthls-modules-into-soc-smartdesigns" title="Permalink to this headline">¶</a></h2>
<p>As described before in <a class="reference internal" href="#smartdesign"><span class="std std-ref">Instantiating SmartHLS IP Core in Libero SmartDesign</span></a>, HDL+ cores can be created for each
module generated by SmartHLS. However, there is still a need to connect those
cores to the rest of the system.</p>
<p>SmartHLS simplifies hardware/software design partition and exploration by making
it easy to add or remove functions (verilog/VHDL modules), or to
split a large function into smaller ones to improve timing and modularity. However,
this flexibility moves the focus to system-level integration because it produces
a very dynamic address mapping and decoding while exploring options and
architectures. It is often necessary to connect (or disconnect) a variable number
of modules into a larger project including their corresponding reset, clock and
AXI interface signals for each module.</p>
<p>Integration greatly depends on the overall system architecture and is usually
performed manually by a system architect. However, under certain assumptions
integration of all the generated SmartHLS cores can be done automatically.</p>
<p>On the hardware side, the automated integration process is performed by a TCL
script called <code class="docutils literal notranslate"><span class="pre">hls_ouput/scripts/shls_integrate_accels.tcl</span></code>, which performs
the following steps:</p>
<ol class="arabic simple">
<li>Call the create_hdl_plus.tcl script (as described in <a class="reference internal" href="#smartdesign"><span class="std std-ref">Instantiating SmartHLS IP Core in Libero SmartDesign</span></a>)</li>
<li>Create the HLS subsystem:<ol class="loweralpha">
<li>Instantiate the HLS AXI Interconnect and configure the address decoding</li>
<li>Connect the created HDL+ cores in step 1 to the HLS AXI interconnect</li>
<li>Connect the reset and clock signals</li>
<li>Connect the HLS AXI Interconnect to the upstream AXI interface</li>
</ol>
</li>
</ol>
<p>As mentioned in the <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a>, SmartHLS uses the <a class="reference external" href="https://github.com/polarfire-soc/icicle-kit-reference-design/">Icicle Kit Reference
Design</a> featuring
a PolarFire<sup>®</sup> SoC Microprocessor Sub-System (MSS) to which the generated
SmartHLS IP modules are automatically attached to via AXI interconnects.</p>
</div>
<div class="section" id="user-defined-smartdesigns-1">
<span id="user-defined-smartdesigns"></span><h2>User-defined SmartDesigns<a class="headerlink" href="#user-defined-smartdesigns-1" title="Permalink to this headline">¶</a></h2>
<p>The automatic integration of SmartHLS cores can also be applied to user-defined
SmartDesigns, not just the Icicle Kit Reference Design included with SmartHLS as
long as some integration parameters are specified as shown in the following image:</p>
<a class="reference internal image-reference" href="_images/hls_subsystem_parameters.png"><img alt="_images/hls_subsystem_parameters.png" class="align-center" src="_images/hls_subsystem_parameters.png" style="width: 1011.08px; height: 542.57px;" /></a>
<p>This image shows the integration parameters (underlined) that are used by
SmartHLS to automate the integration of three hardware modules, in this example:
foo(), bar() and baz(). These parameters have default values based on the
<em>Icicle_SoC</em> reference design included in SmartHLS but can be overridden as
necessary in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file to adapt to user-defined designs.</p>
<p>The following table further describes the integration parameters:</p>
<span id="soc-integration-parameters"></span><table border="1" class="docutils" id="table-1">
<caption><span class="caption-text">SoC integration parameters</span><a class="headerlink" href="#table-1" title="Permalink to this table">¶</a></caption>
<colgroup>
<col width="14%" />
<col width="14%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Parameter name</th>
<th class="head">Default value</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SOC_BD_NAME</td>
<td>FIC_0_PERIPHERALS</td>
<td>The name of the SmartDesign project into which
the SmartHLS IP modules will be integrated.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_DMA_ENGINE</td>
<td>HARD_DMA</td>
<td><p class="first">Determines the type of DMA engine to use.</p>
<p>HARD_DMA: will use the DMA available in the PolarFire SoC MSS. This implies that
the CPUs to be used are the RISC-V U54 application cores in the MSS.</p>
<p class="last">SOFT_DMA: will automatically instantiate a DMA engine on the FPGA fabric and
be connected to the SmartHLS AXI interconnect along with the SmartHLS IP modules.
Currently this option is not enabled, but will be in a future release.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_AXI_INITIATOR</td>
<td>AXI2AXI_TO_HLS:AXI4_MASTER</td>
<td>Identifies the
downstream AXI interface to use. This is used for
register control and any data write and read transfers initiated by the CPU
down to the SmartHLS IP modules.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_AXI_TARGET</td>
<td>AXI2AXI_FROM_HLS:AXI4_SLAVE</td>
<td>Identifies the upstream
AXI interface to use.  This is used for write and read transfer requests
issued by the SmartHLS IP modules targeting the CPU memory.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_RESET</td>
<td>ARESETN</td>
<td><p class="first">Identifies the reset
signal to be used.</p>
<p class="last">NOTE: reset polarity must be active high.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_CLOCK</td>
<td>ACLK</td>
<td>Identifies the clock to use for
the SmartHLS IP modules. Currently, the same clock is used for all modules.</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_FABRIC_BASE_ADDRESS</td>
<td>0x70000000</td>
<td><p class="first">This is the base address of a memory
window in the CPU memory address space that is reserved for all SmartHLS modules
instantiated on the FPGA fabric. Control registers and on-chip memory buffers
are allocated and mapped from this memory window. This address is also used to
configure the HLS AXI interconnect to allow AXI transactions to move downstream
from the CPU towards the SmartHLS IP modules.</p>
<p class="last">Note that the value is a hexadecimal value and the ‘0x’ prefix must be included.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_FABRIC_SIZE</td>
<td>0x400000</td>
<td><p class="first">Determines the size of the memory
window used for mapping control registers and on-chip buffers for <em>ALL</em> modules
in a given SmartHLS project instantiated on the fabric. The size can be larger
than what a specific function may need. For example, a 4MB memory window could
be reserved but the IP module may only use half ot if, leaving the other
half for future use. Reserving a larger window does not mean more on-chip memory
will be used.</p>
<p class="last">NOTE: the size is a hexadecimal value and the ‘0x’ prefix must be included.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_CPU_MEM_BASE_ADDRESS</td>
<td>0x80000000</td>
<td><p class="first">This base address identifies the
beginning of a memory window in the CPU physical memory address space that the
SmartHLS IP modules can use when they are AXI Initiators. This address is used
to configure the HLS AXI interconnect and allow transactions to move upstream
towards the CPU’s memory.</p>
<p class="last">NOTE: the size is a hexadecimal value and the ‘0x’ prefix must be included.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_CPU_MEM_SIZE</td>
<td>0x60000000</td>
<td><p class="first">This is size of the CPU memory window used
when the SmartHLS IP modules act as AXI initiators.</p>
<p class="last">NOTE: the size is a hexadecimal value and the ‘0x’ prefix must be included.</p>
</td>
</tr>
<tr class="row-odd"><td>&#160;</td>
<td>&#160;</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>SOC_POLL_DELAY</td>
<td>0</td>
<td>Controls how often the hardware driver polls the
modules to check for completion. The value is in microseconds.</td>
</tr>
</tbody>
</table>
<p>Once the SmartHLS IP modules have been generated, for example after running the
command <code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">hw</span></code> from the terminal, the generated RTL code for all modules
can be integrated by sourcing the <code class="docutils literal notranslate"><span class="pre">shls_integrate_accels.tcl</span></code> script.
This can be done from Libero’s GUI or sourced from a user TCL script:</p>
<a class="reference internal image-reference" href="_images/integration_scripts.drawio.png"><img alt="_images/integration_scripts.drawio.png" class="align-center" src="_images/integration_scripts.drawio.png" style="width: 501.0px; height: 261.0px;" /></a>
<p>The <code class="docutils literal notranslate"><span class="pre">shls_integrate_accels.tcl</span></code> can also be called from the command line. For
example, a user can create a script like this:</p>
<p>user_script.tcl:</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nv">open_project</span> <span class="o">-</span>file path<span class="o">/</span>to<span class="o">/</span>my_project.prjx
<span class="nb">source</span> path<span class="o">/</span>to<span class="o">/</span>hls<span class="o">/</span>project<span class="o">/</span>hls_output<span class="o">/</span>scripts<span class="o">/</span>shls_integrate_accels.tcl
<span class="nv">close_project</span> <span class="o">-</span>save <span class="mi">1</span>
</pre></div>
</div>
<p>Then on the terminal:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$&gt; libero script:user_script.tcl
</pre></div>
</div>
<p>This will integrate all the SmartHLS IP modules into the user-defined project.
After this, the system can be synthesized and run through place and route.</p>
</div>
<div class="section" id="smarthls-output-files">
<span id="smarthls-outputs"></span><h2>SmartHLS Output Files<a class="headerlink" href="#smarthls-output-files" title="Permalink to this headline">¶</a></h2>
<p>After compiling software to hardware, SmartHLS produces multiple output files. This section will describe the location and purpose for each one.</p>
<div class="section" id="verilog-files">
<h3>Verilog Files<a class="headerlink" href="#verilog-files" title="Permalink to this headline">¶</a></h3>
<p>The generated hardware module(s) are produced in the sub-directory <code class="docutils literal notranslate"><span class="pre">hls_output/rtl</span></code>. By default, each top-level module, along with all its child modules, will be printed to a separate Verilog file (<code class="docutils literal notranslate"><span class="pre">&lt;Project</span> <span class="pre">Name&gt;_&lt;Top</span> <span class="pre">Level</span> <span class="pre">Name&gt;.v</span></code>). If it is desired to print all Verilog into a single file (<code class="docutils literal notranslate"><span class="pre">&lt;Project</span> <span class="pre">Name&gt;.v</span></code>), users can configure the <a class="reference internal" href="constraintsmanual.html#single-hdl-output-file"><span class="std std-ref">SINGLE_HDL_OUTPUT_FILE</span></a> parameter.</p>
</div>
<div class="section" id="vhdl-wrapper-files-1">
<span id="vhdl-wrapper-files"></span><h3>VHDL Wrapper Files<a class="headerlink" href="#vhdl-wrapper-files-1" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS produces VHDL wrapper files which contain a top-level VHDL entity that wraps a corresponding Verilog top-level module. By default, there will be a single VHDL file for each Verilog top-level module (<code class="docutils literal notranslate"><span class="pre">&lt;Project</span> <span class="pre">Name&gt;_&lt;Top</span> <span class="pre">Level</span> <span class="pre">name&gt;.vhd</span></code>). If it is desired to print all VHDL into a single file (<code class="docutils literal notranslate"><span class="pre">&lt;Project</span> <span class="pre">Name&gt;.vhd</span></code>), users can configure the <a class="reference internal" href="constraintsmanual.html#single-hdl-output-file"><span class="std std-ref">SINGLE_HDL_OUTPUT_FILE</span></a> parameter.</p>
</div>
<div class="section" id="reports">
<h3>Reports<a class="headerlink" href="#reports" title="Permalink to this headline">¶</a></h3>
<p>Multiple report files are produced in the sub-directory <code class="docutils literal notranslate"><span class="pre">hls_output/reports</span></code>. For more information on these reports please see <a class="reference internal" href="#report-files">Report Files</a>.</p>
</div>
<div class="section" id="scripts">
<h3>Scripts<a class="headerlink" href="#scripts" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS produces multiple TCL scripts in the sub-directory <code class="docutils literal notranslate"><span class="pre">hls_outputs/scripts</span></code>. These scripts can be passed to Libero to automate the process of integrating SmartHLS accelerators with user designs.
There are four types of scripts produced:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">create_hdl_plus_&lt;top_level&gt;_top.tcl</span></code>: For each top-level function, SmartHLS generates a Tcl script that can be called by Libero to create an HDL+ component containing the accelerator module of that top-level function. The HDL+ core can then be instantiated in SmartDesign and connected to the rest of the user’s design.</li>
<li><code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code>: This script invokes creates HDL+ cores for all accelerators by sourcing each <code class="docutils literal notranslate"><span class="pre">create_hdl_plus_&lt;top_level&gt;_top.tcl</span></code> script.</li>
<li><code class="docutils literal notranslate"><span class="pre">hierarchy.tcl</span></code>: This script can be invoked by ModelSim, and will automatically add relevant signals to the waveform viewer, used for debugging in simulation.</li>
<li><code class="docutils literal notranslate"><span class="pre">shls_integrate_accels.tcl</span></code>: This script invokes the <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> script and then connects the generated HDL+ modules to the <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a>. It can be used as a reference for how the user can integrate generated hardware in their own SmartDesign project.</li>
</ul>
<p>For more information on using these scripts to integrate SmartHLS accelerators with existing designs, please see <a class="reference internal" href="#soc-hw-integration"><span class="std std-ref">Hardware Integration of SmartHLS modules into SoC SmartDesigns</span></a>.</p>
</div>
<div class="section" id="accelerator-driver-code">
<h3>Accelerator Driver Code<a class="headerlink" href="#accelerator-driver-code" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS produces C++ code that the can be used to control the generated hardware from an attached processor in an SoC design. This accelerator driver code can be found in the sub-directory <code class="docutils literal notranslate"><span class="pre">hls_output/accelerator_drivers</span></code>.
In the header file in that directory, there is a set of user-callable functions that can be used to control each accelerator. For a description of the accelerator driver functions, see <a class="reference internal" href="#accelerator-driver"><span class="std std-ref">Driver Functions for AXI4 Target</span></a>.</p>
</div>
<div class="section" id="reference-soc-design">
<h3>Reference SoC Design<a class="headerlink" href="#reference-soc-design" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS can optionally generate a reference SoC design inside the <cite>hls_output/soc</cite> directory, containing a RISCV processor and the generated accelerators. For more details on this reference design, please see <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a>.</p>
</div>
</div>
<div class="section" id="smarthls-command-line-interface">
<span id="cmdline"></span><h2>SmartHLS Command Line Interface<a class="headerlink" href="#smarthls-command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>In addition to the SmartHLS IDE, there is also a command line tool (<code class="docutils literal notranslate"><span class="pre">shls</span></code>) available to call
SmartHLS from a terminal, or from a user script for the purposes of automation.</p>
<div class="section" id="launch-cygwin-terminal-on-windows">
<span id="windows-cmdline"></span><h3>Launch Cygwin terminal on Windows<a class="headerlink" href="#launch-cygwin-terminal-on-windows" title="Permalink to this headline">¶</a></h3>
<p>Windows users can launch the terminal by opening <code class="docutils literal notranslate"><span class="pre">&lt;SMARTHLS_INSTALLATION_DIR&gt;/cygwin64/Cygwin.bat</span></code>.
Users can access their file directory on their computer by using <code class="docutils literal notranslate"><span class="pre">/cygdrive/&lt;drive</span> <span class="pre">letter&gt;/&lt;path&gt;</span></code>
as the prefix.
For example, to go to <code class="docutils literal notranslate"><span class="pre">C:\Microchip\SmartHLS-2023.1</span></code>, enter <code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">/cygdrive/c/Microchip/SmartHLS-2023.1</span></code>.</p>
</div>
<div class="section" id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Permalink to this headline">¶</a></h3>
<p>To run SmartHLS from the command line, your <code class="docutils literal notranslate"><span class="pre">PATH</span></code> environment variable should contain the paths to:</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">shls</span></code>: SmartHLS executable.</li>
<li><code class="docutils literal notranslate"><span class="pre">vsim</span></code>: Modelsim’s executable for HW simulation and SW/HW co-simulation.</li>
<li><code class="docutils literal notranslate"><span class="pre">libero</span></code>: Libero’s executable for synthesis and Place &amp; Route.</li>
</ul>
</div></blockquote>
<p>Here’s an example that you can adapt to your system:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>&lt;SMARTHLS_INSTALLATION_DIR&gt;/SmartHLS/bin:<span class="nv">$PATH</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>&lt;LIBERO_SOC_INSTALLATION_DIR&gt;/ModelSimPro/modeltech/bin:<span class="nv">$PATH</span>
<span class="c1"># Libero executable path is different on Linux, export PATH=&lt;LIBERO_SOC_INSTALLATION_DIR&gt;/Libero/bin:$PATH</span>
<span class="c1"># On Windows, use the path below:</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span>&lt;LIBERO_SOC_INSTALLATION_DIR&gt;/Designer/bin:<span class="nv">$PATH</span>
</pre></div>
</div>
<p>SmartHLS comes with a bash script to provide autocompletion when using the command line on a Linux terminal.
It can be sourced like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nb">source</span> &lt;SMARTHLS_INSTALLATION_DIR&gt;/SmartHLS/examples/scripts/utils/autocomplete/bash_autocomplete.sh
</pre></div>
</div>
<p>After that you can start typing <code class="docutils literal notranslate"><span class="pre">shls</span></code> plus a space, then hit the <code class="docutils literal notranslate"><span class="pre">&lt;TAB&gt;</span></code> key and a list of available commands
will be displayed. If you continue typing the command and hit the <code class="docutils literal notranslate"><span class="pre">&lt;TAB&gt;</span></code> key again the command will be autocompleted.</p>
</div>
<div class="section" id="commands">
<h3>Commands<a class="headerlink" href="#commands" title="Permalink to this headline">¶</a></h3>
<p>Here is the list of available commands:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls <span class="o">[</span>-h<span class="o">]</span> &lt;cmd&gt;
</pre></div>
</div>
<p>Where <code class="docutils literal notranslate"><span class="pre">&lt;cmd&gt;</span></code> can be one of:</p>
<dl class="docutils">
<dt>init</dt>
<dd><p class="first">Create a new SmartHLS project by generating a <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> and a <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file.</p>
<ul class="last">
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">Makefile</span></code> - this file has the following variables</p>
<blockquote>
<div><ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">SRCS</span></code>: This variable should list all the source files (<code class="docutils literal notranslate"><span class="pre">.cpp</span></code> or <code class="docutils literal notranslate"><span class="pre">.c</span></code>).
Header files should not be added to <code class="docutils literal notranslate"><span class="pre">SRCS</span></code>, but should be properly included by the source files.
<code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">init</span></code> will automatically add the file names for the existing source files in the current directory.
If source files are created after <code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">init</span></code>, please update <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">SRCS</span> <span class="pre">=</span> <span class="pre">foo.cpp</span> <span class="pre">bar.cpp</span></code>).</li>
<li><code class="docutils literal notranslate"><span class="pre">NAME</span></code>: This variable stands for the project name, e.g., <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">MY_PROJECT</span></code>.  The default
project name is the current directory name when <code class="docutils literal notranslate"><span class="pre">NAME</span></code> is not specified in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</li>
<li><code class="docutils literal notranslate"><span class="pre">PROGRAM_ARGUMENTS</span></code>: This variable can be used to specify the arguments for the main() function,
which can be used for the software testbench (i.e., <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">main(int</span> <span class="pre">argc,</span> <span class="pre">char</span> <span class="pre">*argv[])</span></code>).
Here is an example: <code class="docutils literal notranslate"><span class="pre">PROGRAM_ARGUMENTS</span> <span class="pre">=</span> <span class="pre">input_file.bmp</span> <span class="pre">golden_output_file.bmp</span></code>.
More details can be found in <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.</li>
</ul>
<p><strong>NOTE</strong>: the above variables should be specified before the last line in <code class="docutils literal notranslate"><span class="pre">Makefile:</span> <span class="pre">include</span> <span class="pre">$(LEVEL)/Makefile.common</span></code>.</p>
</div></blockquote>
</li>
<li><p class="first"><code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> - this file contains the project’s configuration settings. Project parameters and constraints can be specified in this file as necessary. Please refer to the <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a> page.</p>
</li>
</ul>
</dd>
<dt>-g</dt>
<dd>Launch SmartHLS IDE from command line.</dd>
<dt>sw</dt>
<dd>Compile and run the program in software on your host machine.  The compilation step is skipped if no change is detected in source/header files, <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> and <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code>.</dd>
<dt>sw_compile</dt>
<dd>Compile the program in software, the output is an executable file (<code class="docutils literal notranslate"><span class="pre">hls_output/.hls/&lt;NAME&gt;.sw_binary</span></code>).</dd>
<dt>sw_run</dt>
<dd>Run the compiled executable (<code class="docutils literal notranslate"><span class="pre">hls_output/.hls/&lt;NAME&gt;.sw_binary</span></code>) on your host machine.</dd>
<dt>hw (default)</dt>
<dd>Compile the software to hardware, the output is a set of Verilog HDL file (the HLS-generated IP core is in <code class="docutils literal notranslate"><span class="pre">hls_output/rtl/&lt;NAME&gt;.v</span></code>, with additional RTL IP sub-modules named <code class="docutils literal notranslate"><span class="pre">hls_output/rtl/&lt;NAME&gt;_*.v</span></code>).</dd>
<dt>cosim</dt>
<dd>Run <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a> to verify the generated circuit.</dd>
<dt>cosim_wave</dt>
<dd>Same as <code class="docutils literal notranslate"><span class="pre">cosim</span></code> but with ModelSim waveform.</dd>
<dt>sim</dt>
<dd>Simulate the generated hardware in ModelSim (for an input software that has no top-level function specified, which is uncommon).</dd>
<dt>wave</dt>
<dd>Same as above but with ModelSim waveform.</dd>
<dt>fpga</dt>
<dd>Synthesize the generated hardware to target FPGA. This runs RTL synthesis and place-and-route for resource and timing results.</dd>
<dt>rtl_synth</dt>
<dd>Run RTL synthesis for resource results. This will take less time than <strong>fpga</strong>.</dd>
<dt>scheduleviewer</dt>
<dd>Show the scheduler viewer.</dd>
<dt>logic_level_histogram</dt>
<dd>Generates a plot of the logic levels distribution of the synthesized design based on the timing analysis report.</dd>
<dt>clean</dt>
<dd>Delete files generated by SmartHLS.</dd>
<dt>soc_*</dt>
<dd>SoC-specific commands are prefixed with “soc_” and are outlined in the table below:</dd>
</dl>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Command</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><cite>soc_base_proj_program</cite></td>
<td>Programs a pre-built base project bitstream to an attached Icicle Kit.</td>
</tr>
<tr class="row-odd"><td><cite>soc_sw_compile_no_accel</cite></td>
<td>Cross-compiles user software (with no accelerators) to a binary targeting the RISC-V processor on PolarFire SoC.</td>
</tr>
<tr class="row-even"><td><cite>soc_base_proj_run</cite></td>
<td>Moves the RISC-V binary generated by <cite>soc_sw_compile_no_accel</cite> to an Icicle Kit on the network and runs the binary on the Icicle kit.
Requires the BOARD_IP environment variable to be set.</td>
</tr>
<tr class="row-odd"><td><cite>soc_accel_proj_generate</cite></td>
<td>Generates a reference SoC Libero/SmartDesign project, containing an MSS connected to SmartHLS-generated hardware accelerators.
Please see <a class="reference internal" href="hwarchitecture.html#reference-soc-arch"><span class="std std-ref">SmartHLS Reference SoC</span></a> for more information.</td>
</tr>
<tr class="row-even"><td><cite>soc_accel_proj_rtl_synth</cite></td>
<td>Runs RTL synthesis on the generated reference SoC project. Reports resource utilization (see <a class="reference internal" href="#report-files">Report Files</a>).</td>
</tr>
<tr class="row-odd"><td><cite>soc_accel_proj_pnr</cite></td>
<td>Runs place and route on the generated reference SoC project. Reports resource utilization and timing result (see <a class="reference internal" href="#report-files">Report Files</a>).</td>
</tr>
<tr class="row-even"><td><cite>soc_accel_proj_program</cite></td>
<td>Programs the generated reference SoC project to an attached Icicle Kit. Requires PROGRAMMER_ID environment variable to be set.</td>
</tr>
<tr class="row-odd"><td><cite>soc_sw_compile_accel</cite></td>
<td>Transforms user software by replacing top-level function calls with calls to the <a class="reference internal" href="#top-level-driver-functions"><span class="std std-ref">hardware accelerator driver functions</span></a>,
and cross-compiles the transformed software to a binary targeting the RISC-V processor on PolarFire SoC.</td>
</tr>
<tr class="row-even"><td><cite>soc_accel_proj_run</cite></td>
<td>Moves the RISC-V binary generated by <cite>soc_sw_compile_accel</cite> to an Icicle Kit on the network and runs the binary on the Icicle kit.
Requires the BOARD_IP environment variable to be set.</td>
</tr>
<tr class="row-odd"><td><cite>soc_profiler_view</cite></td>
<td>Displays a runtime plot and prints a summary table of the profiling data gathered during runtime execution for each accelerator in the project.</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="software-macros">
<span id="sw-macro"></span><h2>Software Macros<a class="headerlink" href="#software-macros" title="Permalink to this headline">¶</a></h2>
<div class="section" id="synthesis-macro-1">
<span id="synthesis-macro"></span><h3><code class="docutils literal notranslate"><span class="pre">__SYNTHESIS__</span></code> Macro<a class="headerlink" href="#synthesis-macro-1" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">__SYNTHESIS__</span></code> macro is defined in SmartHLS during synthesis. This provides a convenient way to exclude non-synthesizable code without removing/commenting the code itself. In the folling example, the assertion header and statement are ignored during synthesis:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __SYNTHESIS__</span>
<span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="kt">int</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>

<span class="cp">#ifndef __SYNTHESIS__</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">return</span> <span class="n">A</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">While the <code class="docutils literal notranslate"><span class="pre">__SYNTHESIS__</span></code> macro is useful to exclude debugging and system calls, it can change the results between the software and the synthesized Verilog if the excluded code changes the functionality. This can introduce errors or unexpected behaviour in simulation / co-simulation. Use the <code class="docutils literal notranslate"><span class="pre">__SYNTHESIS__</span></code> macro carefully and make sure it does not change the functionality.</p>
</div>
</div>
<div class="section" id="has-accelerator-macro">
<h3><code class="docutils literal notranslate"><span class="pre">HAS_ACCELERATOR</span></code> Macro<a class="headerlink" href="#has-accelerator-macro" title="Permalink to this headline">¶</a></h3>
<p>For SoC projects where different code needs to be called depending on if hardware accelerators are used, the <code class="docutils literal notranslate"><span class="pre">HAS_ACCELERATOR</span></code> macro can be used. For example, SoC accelerators using DMA transfer
need their argument buffers to be initialized using <code class="docutils literal notranslate"><span class="pre">hls_alloc</span></code> (see <a class="reference internal" href="#memory-allocation-library">Memory Allocation Library</a>), where as when the function is not accelerated (the software version is run), a simple <code class="docutils literal notranslate"><span class="pre">malloc</span></code> will suffice.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef HAS_ACCELERATOR</span>
<span class="c1">// Set up a hardware-specific buffer</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="n">hls_alloc</span><span class="p">(...);</span>
<span class="p">...</span>
<span class="cp">#else</span>
<span class="c1">// Set up a software-specific buffer</span>
<span class="kt">int</span> <span class="o">*</span> <span class="n">InputBuffer</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(...);</span>
<span class="p">...</span>
<span class="cp">#endif</span>

<span class="n">accelearted_function</span><span class="p">(</span><span class="n">InputBuffer</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="cosim-early-exit-macro">
<h3><code class="docutils literal notranslate"><span class="pre">COSIM_EARLY_EXIT</span></code> Macro<a class="headerlink" href="#cosim-early-exit-macro" title="Permalink to this headline">¶</a></h3>
<p>For projects that invoke accelerated functions many times, Co-Simulation can take a long time due to simulating each accelerated function call. The <code class="docutils literal notranslate"><span class="pre">COSIM_EARLY_EXIT</span></code> macro can be used
to trigger an early exit for Co-Simulation only. For example, in the following code, Co-Simulation will only run the accelerator 10 times, while running in software or SoC-specific features will
run the accelerator 100 times.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef COSIM_EARLY_EXIT</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
        <span class="c1">// Call the accelerated function</span>
        <span class="n">accelerated_function</span><span class="p">(...);</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="makefile-variables">
<span id="makefile"></span><h2>Makefile Variables<a class="headerlink" href="#makefile-variables" title="Permalink to this headline">¶</a></h2>
<p>There are several Makefile variables that the compiler flow uses to compile the program. The description of each of them are listed below:</p>
<table border="1" class="docutils">
<colgroup>
<col width="14%" />
<col width="86%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><div class="first last line-block">
<div class="line">Variable</div>
<div class="line"><br /></div>
</div>
</th>
<th class="head"><div class="first last line-block">
<div class="line">Description</div>
<div class="line"><br /></div>
</div>
</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><div class="first last line-block">
<div class="line">SRCS</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">The <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> variable in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code> should list all the source files (<code class="docutils literal notranslate"><span class="pre">.cpp</span></code> or <code class="docutils literal notranslate"><span class="pre">.c</span></code>).</div>
<div class="line">Header files should not be added to <code class="docutils literal notranslate"><span class="pre">SRCS</span></code>, but should be properly included by the source files.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">init</span></code> will automatically add the file names for the existing source files in the current directory.</div>
<div class="line">If source files are created after <code class="docutils literal notranslate"><span class="pre">shls</span> <span class="pre">init</span></code>, please update <code class="docutils literal notranslate"><span class="pre">SRCS</span></code> (e.g., <code class="docutils literal notranslate"><span class="pre">SRCS</span> <span class="pre">=</span> <span class="pre">foo.cpp</span> <span class="pre">bar.cpp</span></code>).</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">NAME</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">The <code class="docutils literal notranslate"><span class="pre">NAME</span></code> variable stands for the project name, e.g., <code class="docutils literal notranslate"><span class="pre">NAME</span> <span class="pre">=</span> <span class="pre">MY_PROJECT</span></code>.</div>
<div class="line">The default project name is the current directory name when <code class="docutils literal notranslate"><span class="pre">NAME</span></code> is not specified in <code class="docutils literal notranslate"><span class="pre">Makefile</span></code>.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">BOARD_PATH</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Specify the path where the test will be run on board. The default is <code class="docutils literal notranslate"><span class="pre">/home/root/</span></code>.</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">BOARD_PATH</span></code> is always prefixed by <code class="docutils literal notranslate"><span class="pre">/home/root/</span></code> as programs are run as root on the board.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">PROGRAM_ARGUMENTS</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">PROGRAM_ARGUMENTS</span></code> can be used to specify the arguments of the software testbench (i.e., <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">main(int</span> <span class="pre">argc,</span> <span class="pre">char</span> <span class="pre">*argv[])</span></code>).</div>
<div class="line">Here is an example: <code class="docutils literal notranslate"><span class="pre">PROGRAM_ARGUMENTS</span> <span class="pre">=</span> <span class="pre">input_file.bmp</span> <span class="pre">golden_output_file.bmp</span></code>. More details can be found in <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">NUM_LIBERO_PnR_PASSES</div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Defines the maximum number of Place and Route passes to go through in order to meet the timing requirement.</div>
<div class="line"><br /></div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">INPUT_FILES_RISCV</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Specifies the input files to the program to be copied to the development board, separated by a space.</div>
<div class="line">The path used for the files should be based on the path on the development local machine.</div>
<div class="line">For example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">INPUT_FILES_RISCV</span> <span class="pre">=</span> <span class="pre">lane3.avi</span> <span class="pre">lane3_golden.txt`</span></code></div>
<div class="line">This will copy <code class="docutils literal notranslate"><span class="pre">lane3.avi</span></code> and <code class="docutils literal notranslate"><span class="pre">lane3_golden.txt</span></code> from the project folder to the Icicle board before running the program on board.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">OUTPUT_FILES_RISCV</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Specifies the output files of the program ran on the development board, separated by a space.</div>
<div class="line">The path used for the files should be based on the path on the development board.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">OUTPUT_FILES_RISCV</span> <span class="pre">=</span> <span class="pre">output.avi</span> <span class="pre">output.txt</span></code> will copy <code class="docutils literal notranslate"><span class="pre">output.avi</span></code> and <code class="docutils literal notranslate"><span class="pre">output.txt</span></code></div>
<div class="line">This will copy <code class="docutils literal notranslate"><span class="pre">output.avi</span></code> and <code class="docutils literal notranslate"><span class="pre">output.txt</span></code> from the the Icicle board to the project folder after running the program on board.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">USER_CXX_FLAG</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Additional flags used for compilation such as <code class="docutils literal notranslate"><span class="pre">-I</span></code>.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_CXX_FLAG</span> <span class="pre">=</span> <span class="pre">-I$(OPENCV_PATH)/include/opencv4</span></code></div>
<div class="line">The above compiler option will be added to all the compile command to include the OpenCV include directory.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">USER_CXX_FLAG_RISCV</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Additional flags used for compilation such as <code class="docutils literal notranslate"><span class="pre">-I</span></code>.</div>
<div class="line">USER_CXX_FLAG_RISCV is defaulted to USER_CXX_FLAG. Defining USER_CXX_FLAG_RISCV will override the default, including when it is defined but empty.</div>
<div class="line">User can define this flag for adding specific flags for compiling the binary running on the on-board RISCV processor.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_CXX_FLAG_RISCV</span> <span class="pre">=</span> <span class="pre">-I$(OPENCV_PATH)/include/opencv4</span></code></div>
<div class="line">The above compiler option will added to all the compile command to include the OpenCV include directory.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">USER_LINK_FLAG</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Flags for linking dynamic libraries such as <code class="docutils literal notranslate"><span class="pre">-L</span></code> and <code class="docutils literal notranslate"><span class="pre">-l</span></code>.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_LINK_FLAG</span> <span class="pre">=</span> <span class="pre">-L$(FFMPEG_PATH)/lib</span> <span class="pre">-lavcodec</span></code></div>
<div class="line">The above compiler option will link FFMPEG’s avcodec library.</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">USER_LINK_FLAG_RISCV</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Flags for linking dynamic libraries such as <code class="docutils literal notranslate"><span class="pre">-L</span></code> and <code class="docutils literal notranslate"><span class="pre">-l</span></code>.</div>
<div class="line">USER_LINK_FLAG_RISCV is defaulted to USER_LINK_FLAG. Defining USER_LINK_FLAG_RISCV will override the default, including when it is defined but empty.</div>
<div class="line">User can define this flag for adding specific flags for linking the binary running on the on-board RISCV processor.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_LINK_FLAG_RISCV</span> <span class="pre">=</span> <span class="pre">-L$(FFMPEG_PATH)/lib</span> <span class="pre">-lavcodec</span></code></div>
<div class="line">The above compiler option will link FFMPEG’s avcodec library for the RISCV processor.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="first last line-block">
<div class="line">USER_ENV_VARS</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Set the enviromnent variable used for running the program on development host.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_ENV_VARS</span> <span class="pre">=</span> <span class="pre">LD_LIBRARY_PATH=$(OPENCV_PATH)/lib</span></code></div>
<div class="line">The above compiler option will set <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> to <code class="docutils literal notranslate"><span class="pre">$(OPENCV_PATH)/lib</span></code> when running the program.</div>
<div class="line">On Cygwin, users should specify <code class="docutils literal notranslate"><span class="pre">PATH</span></code> instead of <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> for linking libraries, like so:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_ENV_VARS</span> <span class="pre">=</span> <span class="pre">PATH=$(OPENCV_PATH)/bin</span></code></div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="first last line-block">
<div class="line">USER_ENV_VARS_RISCV</div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</td>
<td><div class="first last line-block">
<div class="line">Set the enviromnent variable used for running the program on RISCV on the development board.</div>
<div class="line">USER_ENV_VARS_RISCV is defaulted to USER_ENV_VARS. Defining USER_ENV_VARS_RISCV will override the default, including when it is defined but empty.</div>
<div class="line">Example:</div>
<div class="line"><code class="docutils literal notranslate"><span class="pre">USER_ENV_VARS_RISCV</span> <span class="pre">=</span> <span class="pre">LD_LIBRARY_PATH=$(OPENCV_PATH)/lib</span></code></div>
<div class="line">The above compiler option will set <code class="docutils literal notranslate"><span class="pre">LD_LIBRARY_PATH</span></code> to <code class="docutils literal notranslate"><span class="pre">$(OPENCV_PATH)/lib</span></code> when running the program.</div>
</div>
</td>
</tr>
</tbody>
</table>
<div class="section" id="makefile-example-1">
<span id="makefile-example"></span><h3>Makefile Example<a class="headerlink" href="#makefile-example-1" title="Permalink to this headline">¶</a></h3>
<p>The example below shows how to define some of the above Makefile variables.</p>
<p>For IDE projects, you should create a new <code class="docutils literal notranslate"><span class="pre">Makefile.user</span></code> file and put your custom Makefile settings there (any changes in the <code class="docutils literal notranslate"><span class="pre">makefile</span></code> of an IDE project will be overwritten).</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># Path to place files on the Icicle kit, relative to root home dir.</span>
BOARD_PATH:<span class="o">=</span>tests/lane-detection-shls

<span class="c1"># To pass timing for this project, we require more PnR passes</span>
NUM_LIBERO_PnR_PASSES :<span class="o">=</span> <span class="m">10</span>

<span class="c1"># Extra defines to include shared opencv/ffmpeg libraries below:</span>
OPENCV_PATH_RISCV :<span class="o">=</span> <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/opencv4.5.4-riscv_64-linux
FFMPEG_PATH_RISCV :<span class="o">=</span> <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/ffmpeg4.4-riscv_64-linux

ifeq <span class="o">(</span><span class="k">$(</span>shell uname -o<span class="k">)</span>, Cygwin<span class="o">)</span>
<span class="c1"># Use cygpath to locate the actual location in Windows</span>
OPENCV_PATH :<span class="o">=</span> <span class="k">$(</span>shell cygpath -t mixed <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/opencv4.5.4-x86_64-cygwin<span class="k">)</span>
FFMPEG_PATH :<span class="o">=</span> <span class="k">$(</span>shell cygpath -t mixed <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/ffmpeg4.4-x86_64-cygwin<span class="k">)</span>
<span class="k">else</span>
OPENCV_PATH :<span class="o">=</span> <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/opencv4.5.4-x86_64-linux
FFMPEG_PATH :<span class="o">=</span> <span class="k">$(</span>LEGUP_ROOT_DIR<span class="k">)</span>/precompiled_sw_libraries/ffmpeg4.4-x86_64-linux
endif

<span class="c1">###########################################################################################</span>
<span class="c1"># User Define variables</span>

<span class="c1"># Specify input and optput files to copy to and from the board.</span>
<span class="c1"># INPUT_FILES_RISCV should use host paths.</span>
<span class="c1"># OUTPUT_FILES should use on-board paths.</span>
INPUT_FILES_RISCV :<span class="o">=</span> lane3.avi lane3_golden.txt
OUTPUT_FILES_RISCV :<span class="o">=</span> outputlane3.avi lane3_lane_distances.txt

<span class="c1"># Secify input arguments</span>
PROGRAM_ARGUMENTS :<span class="o">=</span> lane3.avi lane3_golden.txt

<span class="c1"># Additional flags used for compilation, such as -I</span>
<span class="nv">USER_CXX_FLAG</span> <span class="o">+=</span> -I<span class="k">$(</span>OPENCV_PATH<span class="k">)</span>/include/opencv4 -fexceptions <span class="se">\</span>
                 -Wno-sign-compare -Wno-unused-function        <span class="se">\</span>
                 -Wno-unused-variable

<span class="c1"># Flags for additional link libraries such as -L and -l</span>
<span class="c1"># This variable is for running on local host machine (i.e., x86 target).</span>
<span class="c1"># -B/usr/lib/x86_64-linux-gnu specifies which library to reference</span>
<span class="c1"># when your platform has cross platform compilation capability</span>
<span class="c1"># Specify opencv and ffmpeg libs.</span>
<span class="nv">USER_LINK_FLAG</span> <span class="o">+=</span> -B/usr/lib/x86_64-linux-gnu <span class="se">\</span>
                  -L<span class="k">$(</span>OPENCV_PATH<span class="k">)</span>/lib <span class="se">\</span>
                  -lopencv_videoio -lopencv_core -lopencv_imgcodecs -lopencv_imgproc <span class="se">\</span>
                  -L<span class="k">$(</span>FFMPEG_PATH<span class="k">)</span>/lib <span class="se">\</span>
                  -lavcodec -lavformat -lavutil -lswscale -lswresample <span class="se">\</span>
                  -Wl,-rpath,<span class="k">$(</span>FFMPEG_PATH<span class="k">)</span>/lib

<span class="c1"># Flags for additional link libraries such as -L and -l for</span>
<span class="c1"># This variable is for running on the SOC.</span>
<span class="c1"># Include opencv and ffmpeg libs in the cross compiler linker.</span>
<span class="nv">USER_LINK_FLAG_RISCV</span> <span class="o">=</span> -L<span class="k">$(</span>OPENCV_PATH_RISCV<span class="k">)</span>/lib <span class="se">\</span>
                       -lopencv_videoio -lopencv_core -lopencv_imgcodecs -lopencv_imgproc -latomic <span class="se">\</span>
                       -L<span class="k">$(</span>FFMPEG_PATH_RISCV<span class="k">)</span>/lib <span class="se">\</span>
                       -lavcodec -lavformat -lavutil -lswscale -lswresample <span class="se">\</span>
                       -Wl,-rpath-link,<span class="k">$(</span>FFMPEG_PATH_RISCV<span class="k">)</span>/lib

<span class="c1"># Additional user-defined environment variables that user might need to run their program</span>
<span class="c1"># This variable is for running on local host machine</span>
ifeq <span class="o">(</span><span class="k">$(</span>shell uname -o<span class="k">)</span>, Cygwin<span class="o">)</span>
<span class="c1"># Use semicolons as PATH separator on Windows</span>
USER_ENV_VARS :<span class="o">=</span> <span class="nv">PATH</span><span class="o">=</span><span class="k">$(</span>OPENCV_PATH<span class="k">)</span>/bin<span class="p">;</span><span class="k">$(</span>FFMPEG_PATH<span class="k">)</span>/bin<span class="p">;</span><span class="k">$(</span>shell cygpath -t mixed /usr/x86_64-w64-mingw32/sys-root/mingw/bin<span class="k">)</span><span class="p">;</span><span class="nv">$$</span>PATH
<span class="k">else</span>
USER_ENV_VARS :<span class="o">=</span> <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="k">$(</span>OPENCV_PATH<span class="k">)</span>/lib:<span class="k">$(</span>FFMPEG_PATH<span class="k">)</span>/lib
endif

<span class="c1"># Additional user-defined environment variables that user might need to run their program</span>
<span class="c1"># This variable is for running on the SOC</span>
<span class="c1"># LD_LIBRARY_PATH is needed for dynamically linking OpenCV</span>
USER_ENV_VARS_RISCV :<span class="o">=</span> <span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span>/home/root/shls_sw_dependencies/opencv4.5.4-riscv_64-linux/lib:/home/root/shls_sw_dependencies/ffmpeg4.4-riscv_64-linux/lib

<span class="c1"># The IP adddress of the ethernet-cable-connected Icicle kit.</span>
BOARD_IP ?<span class="o">=</span> <span class="m">192</span>.168.X.X

<span class="c1"># The programmer ID for programming the Icicle kit.</span>
PROGRAMMER_ID ?<span class="o">=</span> 445F3438
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
<!-- Amandeep.Talwar: Moved the footer code to layout.html to resolve conflict with the Microchip template -->
</footer>

        </div>
      </div>
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

  
<footer _ngcontent-hes-c23=""><div _ngcontent-hes-c23="" class="social-icons">
<a _ngcontent-hes-c23="" href="https://github.com/MicrochipTech/" target="_top">
<div _ngcontent-hes-c23="" class="facebook"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="fa-github-square" class="svg-inline--fa fa-github-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path
     fill="currentColor"
     d="m 151.375,357.33334 q 1.16667,-2 -0.875,-4.33334 -2.625,-2.33334 -4.08333,-0.66666 -1.16667,2 0.875,4.33332 2.625,2.33334 4.08333,0.66668 z m -8.16667,-13.66668 q -1.45833,-2.33332 -3.5,-1.33332 -1.75,1.33332 0,4 2.04167,2.66666 3.5,1.66666 1.75,-1.33334 0,-4.33334 z M 131.25,330.33334 Q 131.83333,329 129.79167,327.66666 127.75,327 127.45833,328.33334 126.58333,330 128.625,331 q 2.33333,0.66666 2.625,-0.66666 z M 137.375,338 q 0.58333,-0.33334 0.4375,-1.5 -0.14583,-1.16666 -1.02083,-1.83334 -1.75,-2.33332 -2.91667,-1 -1.16667,1.33334 0.29167,3.66668 1.75,2 3.20833,0.66666 z m 25.08333,25 q 0.58334,-2.33334 -2.625,-3.66666 -2.625,-1 -3.79166,1.33332 -0.58334,2.33334 2.625,3.66668 2.625,1 3.79166,-1.33334 z m 12.25,1 q 0,-2.66666 -3.5,-2.66666 -2.91666,0 -2.91666,2.66666 0,2.66666 3.20833,2.66666 3.20833,0 3.20833,-2.66666 z m 11.375,-2.33334 Q 185.5,359.33334 182.29167,360 q -3.20834,0.66666 -2.625,3 0.58333,2.66666 3.5,2 2.91666,-0.66666 2.91666,-3.33334 z M 373.33333,256 q 0,-70.66666 -43.75,-120.66666 Q 285.83333,85.333334 224,85.333334 q -61.83333,0 -105.58333,50.000006 -43.750003,50 -43.750003,120.66666 0,55.66666 28.583333,100.16666 28.58333,44.5 73.5,61.83334 5.25,1 7.72917,-1.66666 2.47916,-2.66668 2.47916,-6.66668 0,-17.33332 -0.29166,-31.66666 -1.75,0.33334 -4.52084,0.83334 -2.77083,0.5 -10.35416,0.66666 -7.58334,0.16666 -14,-1.33334 -6.41667,-1.5 -12.6875,-6.66666 Q 138.83333,366.33334 136.5,357.66666 129.79167,338 119.875,333 q -0.58333,-0.33334 -1.3125,-1.16666 L 116.22917,329.16666 114.1875,326 l 1.16667,-2.5 5.6875,-1.16666 q 1.75,0 4.375,0.66666 2.625,0.66666 8.75,5.16666 6.125,4.5 9.625,11.83334 4.66666,9.33334 10.9375,14 6.27083,4.66666 12.6875,4.66666 6.41666,0 11.08333,-1.16666 4.66667,-1.16666 8.75,-3.16666 2.04167,-15.66668 9.625,-23 -14.29167,-2 -25.08333,-6.16668 Q 161,321 150.5,312.16666 140,303.33334 134.3125,286.83334 128.625,270.33334 128.625,247 q 0,-26.33334 15.45833,-45.66666 -7,-20.66668 1.45834,-45.33334 5.54166,-2 15.89583,2.5 10.35417,4.5 17.64583,9.83334 l 7.58334,5.33332 Q 203.58333,168 224,168 q 20.41667,0 37.33333,5.66666 3.20834,-2.33332 8.3125,-6 Q 274.75,164 285.83333,159 q 11.08334,-5 16.625,-3 8.45834,24.66666 1.45834,45.33334 Q 319.375,220.66666 319.375,247 q 0,19 -4.08333,33.5 -4.08334,14.5 -10.35417,23.33334 -6.27083,8.83332 -15.60417,14.83332 -9.33333,6 -18.22916,8.66668 -8.89584,2.66666 -19.97917,4 10.20833,10.33332 10.20833,31.66666 0,13.33334 -0.14583,29.66666 -0.14583,16.33334 -0.14583,17 0,4 2.47916,6.66668 Q 266,419 271.25,418 316.16667,400.66666 344.75,356.16666 373.33333,311.66666 373.33333,256 Z M 448,96 v 320 q 0,39.66666 -24.64583,67.83334 Q 398.70833,512 364,512 H 84 Q 49.291667,512 24.645833,483.83334 0,455.66666 0,416 V 96 Q 0,56.333334 24.645833,28.166666 49.291667,0 84,0 H 364 Q 398.70833,0 423.35417,28.166666 448,56.333334 448,96 Z"/></svg></fa-icon></div>
</a>



<a _ngcontent-hes-c23="" href="https://www.facebook.com/pages/Microchip-Technology-Inc/20320981741" target="_top">
<div _ngcontent-hes-c23="" class="facebook"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="facebook-square" class="svg-inline--fa fa-facebook-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z"></path></svg></fa-icon></div></a>
<a _ngcontent-hes-c23="" href="https://google.com/+MicrochipTech" target="_top"><div _ngcontent-hes-c23="" class="google"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="google-plus-square" class="svg-inline--fa fa-google-plus-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM164 356c-55.3 0-100-44.7-100-100s44.7-100 100-100c27 0 49.5 9.8 67 26.2l-27.1 26.1c-7.4-7.1-20.3-15.4-39.8-15.4-34.1 0-61.9 28.2-61.9 63.2 0 34.9 27.8 63.2 61.9 63.2 39.6 0 54.4-28.5 56.8-43.1H164v-34.4h94.4c1 5 1.6 10.1 1.6 16.6 0 57.1-38.3 97.6-96 97.6zm220-81.8h-29v29h-29.2v-29h-29V245h29v-29H355v29h29v29.2z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.linkedin.com/company/microchip-technology" target="_top"><div _ngcontent-hes-c23="" class="linkedin"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://twitter.com/MicrochipTech" target="_top"><div _ngcontent-hes-c23="" class="twitter"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter-square" class="svg-inline--fa fa-twitter-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.youtube.com/user/MicrochipTechnology" target="_top"><div _ngcontent-hes-c23="" class="youtube"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="youtube-square" class="svg-inline--fa fa-youtube-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M186.8 202.1l95.2 54.1-95.2 54.1V202.1zM448 80v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48zm-42 176.3s0-59.6-7.6-88.2c-4.2-15.8-16.5-28.2-32.2-32.4C337.9 128 224 128 224 128s-113.9 0-142.2 7.7c-15.7 4.2-28 16.6-32.2 32.4-7.6 28.5-7.6 88.2-7.6 88.2s0 59.6 7.6 88.2c4.2 15.8 16.5 27.7 32.2 31.9C110.1 384 224 384 224 384s113.9 0 142.2-7.7c15.7-4.2 28-16.1 32.2-31.9 7.6-28.5 7.6-88.1 7.6-88.1z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.microchip.com/rss/" target="_top"><div _ngcontent-hes-c23="" class="rss"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss-square" class="svg-inline--fa fa-rss-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"></path></svg></fa-icon></div></a></div><div _ngcontent-hes-c23="" id="mchip-overlay" onclick="off()" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; background-color: rgba(0,0,0,.3); display: none;"><div _ngcontent-hes-c23="" style="position: relative; width: 100%; height: 100%;"></div></div><div _ngcontent-hes-c23="" class="links"><nav _ngcontent-hes-c23=""><a _ngcontent-hes-c23="" href="https://www.microchip.com/products/" target="_top">Products</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/technology/" target="_top">Applications</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/technology/" target="_top">Design</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/training/" target="_top">Training</a><a _ngcontent-hes-c23="" href="https://www.microchipdirect.com/" target="_top">Sample</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/aboutus/" target="_top">About</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/contactus/" target="_top">Contact</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/legal/" target="_top">Legal</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/about-us/legal-information/privacy-policy" target="_top">Privacy Policy</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/investors/" target="_top">Investors</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/careers/" target="_top">Careers</a><a _ngcontent-hes-c23="" href="https://support.microchip.com/" target="_top">Support</a></nav><p _ngcontent-hes-c23="" class="links">©Copyright 2021 Microchip Technology Inc. All rights reserved.</p></div></footer>

<!-- Adds the "Ask a question" link beside every section header (h1/h2/h3/h4 tag) -->
<script>
function link(headingTitle) {
	var pageName = "userguide.rst.txt".replace(/\.txt/g,'');
	var title = document.title;
	var source = encodeURIComponent(
		window.location.href.split('#')[0]
		+'#'+headingTitle.toLowerCase().replace(/ /g,'-'));
	var newuri = "https://microchipsupport.force.com/s/newcase?\
		pub_guid=SmartHLS-Documentation&\
		pub_lang=en-US&\
		pub_type=UserGuide&\
		bu=fpga&\
		tech_support_link=NA&\
		source="+source+"&\
		cover_title=SmartHLS 2023.1 documentation&\
		pub_ver=2023.1&\
		revision_letter=2023.1&\
		title="+headingTitle+"&\
		tpc_guid="+pageName;
	return "&nbsp; <a class=\"reference external\" \
		style=\"font-size:60%\" href=\"" + newuri + " \
		\" target=_blank>Ask a question</a>";
}

$(document).ready(function(){
	$("h1").each(function(i) {
		<!-- id="booktitle" is ignored since the <h1> at the top of the page	-->
		<!-- 	(currently "SmartHLS - v2022.2") does not need the link.	-->
		<!-- Furthermore, appending the link to the "booktitle" header will	-->
		<!--	cover up the search bar, rendering it unusuable.		-->
		if (this.id != "booktitle") $(this).append(link($(this)[0].firstChild.textContent));
	});
	$("h2").each(function(i) {
		$(this).append(link($(this)[0].firstChild.textContent));
	});
	$("h3").each(function(i) {
		$(this).append(link($(this)[0].firstChild.textContent));
	});
	$("h4").each(function(i) {
		$(this).append(link($(this)[0].firstChild.textContent));
	});
});
</script>

</body>
</html>