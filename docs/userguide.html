

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Header information-->
    <meta name="Language" content="en">
	<meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  
  <title>1. User Guide &mdash; SmartHLS 2021.2 documentation</title>
  
<!-- Header information-->
<style type="text/css">svg:not(:root).svg-inline--fa {
  overflow: visible;
}

.svg-inline--fa {
  display: inline-block;
  font-size: inherit;
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.225em;
}
.svg-inline--fa.fa-w-1 {
  width: 0.0625em;
}
.svg-inline--fa.fa-w-2 {
  width: 0.125em;
}
.svg-inline--fa.fa-w-3 {
  width: 0.1875em;
}
.svg-inline--fa.fa-w-4 {
  width: 0.25em;
}
.svg-inline--fa.fa-w-5 {
  width: 0.3125em;
}
.svg-inline--fa.fa-w-6 {
  width: 0.375em;
}
.svg-inline--fa.fa-w-7 {
  width: 0.4375em;
}
.svg-inline--fa.fa-w-8 {
  width: 0.5em;
}
.svg-inline--fa.fa-w-9 {
  width: 0.5625em;
}
.svg-inline--fa.fa-w-10 {
  width: 0.625em;
}
.svg-inline--fa.fa-w-11 {
  width: 0.6875em;
}
.svg-inline--fa.fa-w-12 {
  width: 0.75em;
}
.svg-inline--fa.fa-w-13 {
  width: 0.8125em;
}
.svg-inline--fa.fa-w-14 {
  width: 0.875em;
}
.svg-inline--fa.fa-w-15 {
  width: 0.9375em;
}
.svg-inline--fa.fa-w-16 {
  width: 1em;
}
.svg-inline--fa.fa-w-17 {
  width: 1.0625em;
}
.svg-inline--fa.fa-w-18 {
  width: 1.125em;
}
.svg-inline--fa.fa-w-19 {
  width: 1.1875em;
}
.svg-inline--fa.fa-w-20 {
  width: 1.25em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-border {
  height: 1.5em;
}
.svg-inline--fa.fa-li {
  width: 2em;
}
.svg-inline--fa.fa-fw {
  width: 1.25em;
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: #ff253a;
  border-radius: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  color: #fff;
  height: 1.5em;
  line-height: 1;
  max-width: 5em;
  min-width: 1.5em;
  overflow: hidden;
  padding: 0.25em;
  right: 0;
  text-overflow: ellipsis;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: 0;
  right: 0;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: 0;
  left: 0;
  right: auto;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  right: 0;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: 0;
  right: auto;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-lg {
  font-size: 1.3333333333em;
  line-height: 0.75em;
  vertical-align: -0.0667em;
}

.fa-xs {
  font-size: 0.75em;
}

.fa-sm {
  font-size: 0.875em;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: 2.5em;
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: -2em;
  position: absolute;
  text-align: center;
  width: 2em;
  line-height: inherit;
}

.fa-border {
  border: solid 0.08em #eee;
  border-radius: 0.1em;
  padding: 0.2em 0.25em 0.15em;
}

.fa-pull-left {
  float: left;
}

.fa-pull-right {
  float: right;
}

.fa.fa-pull-left,
.fas.fa-pull-left,
.far.fa-pull-left,
.fal.fa-pull-left,
.fab.fa-pull-left {
  margin-right: 0.3em;
}
.fa.fa-pull-right,
.fas.fa-pull-right,
.far.fa-pull-right,
.fal.fa-pull-right,
.fab.fa-pull-right {
  margin-left: 0.3em;
}

.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
          animation: fa-spin 2s infinite linear;
}

.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
          animation: fa-spin 1s infinite steps(8);
}

@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}

@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical,
:root .fa-flip-both {
  -webkit-filter: none;
          filter: none;
}

.fa-stack {
  display: inline-block;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: #fff;
}

.sr-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

.sr-only-focusable:active, .sr-only-focusable:focus {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse {
  color: #fff;
}

@media screen and (max-width: 768px)
.booktitle #booktitle{
display:none;
}
</style>
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet" type="text/css">
	<script src="https://kit.fontawesome.com/d3dd8c60ed.js"></script>
  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/common-ui-all.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/header-footer.min.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/pro.min.css" media="all" />
<link rel="stylesheet" href="_static/css/styles.e92b8b50b164f4a2ce2c.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="2. Optimization Guide" href="optimizationguide.html" />
    <link rel="prev" title="2. Release Notes" href="releasenotes.html" /> 
</head>

<body class="wy-body-for-nav">

		<div class="mchp-ghp"/>
		<div class="root responsivegrid">
								<noindex>
								<header _ngcontent-hes-c23="" style="background: white;"><div _ngcontent-hes-c23="" id="container" style="background: white;
"><div _ngcontent-hes-c23="" id="mc_header_container"><div _ngcontent-hes-c23="" id="mc_header_logo" class="float-left"><a _ngcontent-hes-c23="" href="https://www.microchip.com"><img _ngcontent-hes-c23="" file="Microchip_logo.png" src="_static/css/Microchip_logo.png"></a></div><div _ngcontent-hes-c23="" class="text-center tablet-hide mobile-hide"><h1 id="booktitle" class="booktitle" style="margin-top:10px;display:block;"> 
								          
											<span style="padding-top:15px;display:block;">SmartHLS  - v2021.2  </span>

										  </h1>
								
								</div></div></div><section _ngcontent-hes-c23="" class="separator"></section></header>	
								</noindex>		

		</div>
   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
		
          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
         
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">1. Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="releasenotes.html">2. Release Notes</a></li>
</ul>
<p class="caption"><span class="caption-text">Working with SmartHLS</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. User Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction-to-high-level-synthesis">1.1. Introduction to High-Level Synthesis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#instruction-level-parallelism">1.1.1. Instruction-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loop-level-parallelism">1.1.2. Loop-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#thread-level-parallelism">1.1.3. Thread-level Parallelism</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-flow-streaming-parallelism">1.1.4. Data Flow (Streaming) Parallelism</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-overview">1.2. SmartHLS Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-pragmas">1.3. SmartHLS Pragmas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-constraints">1.4. SmartHLS Constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-the-top-level-function">1.5. Specifying the Top-level Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#sw-hw-co-simulation">1.6. SW/HW Co-Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#loop-pipelining">1.7. Loop Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multi-threading-with-smarthls-threads">1.8. Multi-threading with SmartHLS Threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="#supported-smarthls-thread-apis">1.9. Supported SmartHLS Thread APIs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-flow-parallelism-with-smarthls-threads">1.10. Data Flow Parallelism with SmartHLS Threads</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#further-throughput-enhancement-with-loop-pipelining">1.10.1. Further Throughput Enhancement with Loop Pipelining</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#function-pipelining">1.11. Function Pipelining</a></li>
<li class="toctree-l2"><a class="reference internal" href="#memory-partitioning">1.12. Memory Partitioning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#access-based-memory-partitioning">1.12.1. Access-Based Memory Partitioning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#user-specified-memory-partitioning">1.12.2. User-Specified Memory Partitioning</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#complete-partitioning">1.12.2.1. Complete Partitioning</a></li>
<li class="toctree-l4"><a class="reference internal" href="#struct-fields-partitioning">1.12.2.2. Struct-Fields Partitioning</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-c-c-library">1.13. SmartHLS C/C++ Library</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#streaming-library">1.13.1. Streaming Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#streaming-library-blocking-behaviour">1.13.1.1. Streaming Library - Blocking Behaviour</a></li>
<li class="toctree-l4"><a class="reference internal" href="#streaming-library-non-blocking-behaviour">1.13.1.2. Streaming Library - Non-Blocking Behaviour</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-data-types-library">1.13.2. C++ Arbitrary Precision Data Types Library</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-integer-library">1.13.3. C++ Arbitrary Precision Integer Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printing-arbitrary-precision-integers">1.13.3.1. Printing Arbitrary Precision integers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-arbitrary-precision-integers">1.13.3.2. Initializing Arbitrary Precision integers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-arbitrary-precision-integer-arithmetic">1.13.3.3. C++ Arbitrary Precision Integer Arithmetic</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-arbitrary-precision-integer-explicit-conversions">1.13.3.4. C++ Arbitrary Precision Integer Explicit Conversions</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-bit-level-operations">1.13.4. C++ Arbitrary Precision Bit-level Operations</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#selecting-and-assigning-to-a-range-of-bits">1.13.4.1. Selecting and Assigning to a Range of Bits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bit-concatenation">1.13.4.2. Bit Concatenation</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-arbitrary-precision-fixed-point-library">1.13.5. C++ Arbitrary Precision Fixed Point Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#printing-ap-u-fixpt-types">1.13.5.1. Printing ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#initializing-ap-u-fixpt-types">1.13.5.2. Initializing ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#arithmetic-with-ap-u-fixpt-types">1.13.5.3. Arithmetic With ap_[u]fixpt Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-conversions-of-ap-u-fixpt">1.13.5.4. Explicit Conversions of ap_[u]fixpt</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point">1.13.6. Supported Operations in ap_[u]int, ap_[u]fixpt, and floating-point</a></li>
<li class="toctree-l3"><a class="reference internal" href="#image-processing-library">1.13.7. Image Processing Library</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#line-buffer">1.13.7.1. Line Buffer</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-numerics-library-math-h-in-c-cmath-in-c">1.13.8. C Numerics Library (math.h in C / &lt;cmath&gt; in C++)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#top-level-rtl-interface">1.14. Top-Level RTL Interface</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-control-interface">1.14.1. Module Control Interface</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#timing-diagram-no-pipeline-functions">1.14.1.1. Timing Diagram (No Pipeline Functions)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#timing-diagram-pipeline-functions">1.14.1.2. Timing Diagram (Pipeline Functions)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#scalar-argument">1.14.2. Scalar Argument</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pointer-argument-and-shared-global-variable">1.14.3. Pointer Argument and Shared Global Variable</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#memory-type">1.14.3.1. Memory Type</a></li>
<li class="toctree-l4"><a class="reference internal" href="#axi4-slave-type">1.14.3.2. AXI4 Slave Type</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#hls-fifo-argument">1.14.4. hls::FIFO Argument</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#implementing-a-custom-axi4-master-slave-using-hls-fifo">1.14.4.1. Implementing A Custom AXI4 Master/Slave Using hls::FIFO</a></li>
<li class="toctree-l4"><a class="reference internal" href="#c-library-for-custom-axi-master-interface">1.14.4.2. C++ Library for Custom AXI Master Interface</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#specifying-a-custom-test-bench">1.15. Specifying a Custom Test Bench</a></li>
<li class="toctree-l2"><a class="reference internal" href="#report-files">1.16. Report Files</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#smarthls-report">1.16.1. SmartHLS Report</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rtl-interface-section">1.16.1.1. RTL Interface Section</a></li>
<li class="toctree-l4"><a class="reference internal" href="#scheduling-result">1.16.1.2. Scheduling Result</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pipeline-result">1.16.1.3. Pipeline Result</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-usage">1.16.1.4. Memory Usage</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulation-and-rtl-synthesis-place-route-report">1.16.2. Simulation and RTL Synthesis, Place &amp; Route Report</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#schedule-viewer">1.17. Schedule Viewer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#background-llvm-internal-representation-used-by-smarthls">1.17.1. Background: LLVM Internal Representation used by SmartHLS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#call-graph">1.17.2. Call Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#control-flow-graph">1.17.3. Control Flow Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#schedule-chart">1.17.4. Schedule Chart</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline-viewer">1.17.5. Pipeline Viewer</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#instantiating-smarthls-ip-core-in-libero-smartdesign">1.18. Instantiating SmartHLS IP Core in Libero SmartDesign</a></li>
<li class="toctree-l2"><a class="reference internal" href="#smarthls-command-line-interface">1.19. SmartHLS Command Line Interface</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="optimizationguide.html">2. Optimization Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="hwarchitecture.html">3. Hardware Architecture</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional References</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="pragmas.html">1. SmartHLS Pragmas Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="constraintsmanual.html">2. Constraints Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="license_setup.html">3. Setup Smart HLS License</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">4. Frequently Asked Questions</a></li>
</ul>
<p class="caption"><span class="caption-text">SmartHLS Examples</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/MicrochipTech/fpga-hls-examples">GitHub Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">Versions</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://microchiptech.github.io/fpga-hls-docs">Main (2021.2)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://microchiptech.github.io/fpga-hls-docs/2021.1.2">2021.1.2</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SmartHLS</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li><span class="section-number">1. </span>User Guide</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <section id="user-guide">
<span id="userguide"></span><h1><span class="section-number">1. </span>User Guide<a class="headerlink" href="#user-guide" title="Permalink to this headline">¶</a></h1>
<section id="introduction-to-high-level-synthesis">
<h2><span class="section-number">1.1. </span>Introduction to High-Level Synthesis<a class="headerlink" href="#introduction-to-high-level-synthesis" title="Permalink to this headline">¶</a></h2>
<p>High-level synthesis (HLS) refers to the synthesis of a hardware circuit from a software program specified in a high-level language, where the hardware circuit performs the same functionality as the software program.  For SmartHLS, the input is a C/C++-language program, and the output is a circuit specification in the Verilog hardware description language.  The SmartHLS-generated Verilog can be given to Libero to be programmed on a Microchip FPGA. The underlying motivation for HLS is to raise the level of abstraction for hardware design, by allowing software methodologies to be used to design hardware.  This can help to shorten design cycles, improve design productivity and reduce time-to-market.</p>
<p>While a detailed knowledge of HLS is not required to use SmartHLS, it is worthwhile to highlight the key steps involved in converting software to hardware. The four main steps involved in HLS are allocation, scheduling, binding, and RTL generation, which runs one after another (i.e., binding runs after scheduling is done).</p>
<ul class="simple">
<li><p>Allocation: The allocation step defines the constraints on the generated hardware, including the number of hardware resources of a given type that may be used (e.g. how many divider units may be used, the number of RAM ports, etc.), as well as the target clock period for the hardware, and other user-supplied constraints.</p></li>
<li><p>Scheduling: Software programs are written without any notion of a clock or finite state machine (FSM). The scheduling step of HLS bridges this gap, by assigning the computations in the software to occur in specific clock cycles in hardware. With the user-provided target clock period constraint (e.g. 10 ns), scheduling will assign operations into clock cycles such that the operations in each cycle does not exceed the target clock period, in order to meet the user constraint. In addition, the scheduling step will ensure that the data-dependencies between the operations are met.</p></li>
<li><p>Binding: While a software program may contain an arbitrary number of operations of a given type (e.g. multiplications), the hardware may contain only a limited number of units capable of performing such a computation.  The binding step of HLS is to associate (bind) each computation in the software with a specific unit in the hardware.</p></li>
<li><p>RTL generation: Using the analysis from the previous steps, the final step of HLS is to generate a description of the circuit in a hardware description language (Verilog).</p></li>
</ul>
<p>Executing computations in hardware brings speed and energy advantages over performing the same computations in software running on a processor.  The underlying reason for this is that the hardware is dedicated to the computational work being performed, whereas a processor is generic and has the inherent overheads of fetching/decoding instructions, loading/storing from/to memory, etc.  Further acceleration is possible by exploiting hardware parallelism, where computations can concurrently.  With SmartHLS, one can exploit four styles of hardware parallelism, which are instruction-level, loop-level, thread-level, and function-level parallelism.</p>
<section id="instruction-level-parallelism">
<h3><span class="section-number">1.1.1. </span>Instruction-level Parallelism<a class="headerlink" href="#instruction-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>Instruction-level parallelism refers to the ability to concurrently execute computations for instructions concurrently by analyzing data dependencies.  Computations that do not depend on each other can be executed at the same time.  Consider the following code snippet which performs three addition operations.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="nv">z</span> <span class="o">=</span> a + b<span class="p">;</span>
<span class="nv">x</span> <span class="o">=</span> c + d<span class="p">;</span>
<span class="nv">q</span> <span class="o">=</span> z + x<span class="p">;</span>
...
</pre></div>
</div>
<p>Observe that the first and second additions do not depend on one another.  These additions can therefore be executed concurrently, as long as there are two adder units available in the hardware.  SmartHLS automatically analyzes the dependencies between computations in the software to exploit instruction-level parallelism in the generated hardware. The user does not need to do anything. In the above example, the third addition operation depends on the results of the first two, and hence, its execution cannot be done in parallel with the others. Instruction-level parallelism is referred to as fine-grained parallelism, as concurrency is achieved at a fine-grained level (instruction-level) of granularity.</p>
</section>
<section id="loop-level-parallelism">
<h3><span class="section-number">1.1.2. </span>Loop-level Parallelism<a class="headerlink" href="#loop-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>In software, the majority of runtime can be spent on loops, where loop iterations execute sequentially.  That is, loop iteration <em>i</em> needs to finish before iteration <em>i + 1</em> can start. With SmartHLS, it is possible to overlap the execution of a loop iteration with another iterations using a technique called <em>loop pipelining</em> (see <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>). Now, imagine a loop with <em>N</em> iterations, where each iteration takes 100 clock cycles to complete.  In software, this loop would take <em>100N</em> clock cycles to execute. With loop pipelining in hardware, the idea is to execute a portion of a loop iteration <em>i</em> and then commence executing iteration <em>i + 1</em> even before iteration <em>i</em> is complete. If loop pipelining can commence a new loop iteration <em>every</em> clock cycles, then the total number of clock cycles required to execute the entire loop be <em>N + (N-1)</em> cycles – a significant reduction relative to <em>100N</em>. The (N-1) cycles is because each successive loop iteration start 1 cycle after the previous iteration, hence the last loop starts after (N-1) cycles.</p>
<p>A user can specify a loop to be pipelined with the use of the loop pipeline pragma. By default, a loop is not pipelined automatically.</p>
</section>
<section id="thread-level-parallelism">
<h3><span class="section-number">1.1.3. </span>Thread-level Parallelism<a class="headerlink" href="#thread-level-parallelism" title="Permalink to this headline">¶</a></h3>
<p>Modern CPUs have multiple cores that can be used to concurrently execute multiple threads in software. Threads are widely used in C/C++, where, parallelism is realized at the granularity of entire C/C++ functions.  Hence thread-level parallelism is referred to as coarse-grained parallelism since one or more functions execute in parallel.  SmartHLS supports hardware synthesis of <code class="docutils literal notranslate"><span class="pre">hls::threads</span></code>, where concurrently executing threads in software are synthesized into concurrently executing hardware units (see <a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading with SmartHLS Threads</span></a>).  This allows a software developer to take advantage of spatial parallelism in hardware using a familiar parallel programming paradigm in software.  Moreover, the parallel execution behaviour of threads can be debugged in software, it is considerably easier than debugging in hardware.</p>
<p>In a multi-threaded software program, synchronization between the threads can be important, with the most commonly used synchronization constructs being mutexes and barriers. SmartHLS supports the synthesis of mutexes and barriers into hardware.</p>
</section>
<section id="data-flow-streaming-parallelism">
<h3><span class="section-number">1.1.4. </span>Data Flow (Streaming) Parallelism<a class="headerlink" href="#data-flow-streaming-parallelism" title="Permalink to this headline">¶</a></h3>
<p>The second style of coarse-grained parallelism is referred to as <em>data flow</em> parallelism.  This form of parallelism arises frequently in <em>streaming</em> applications, and are commonly used for video/audio processing, machine learning, and computational finance.  In such applications, there is a stream of input data that is fed into the application at regular intervals.  For example, in an audio processing application, a digital audio sample may be given to the circuit every clock cycle.  In streaming applications, a succession of computational tasks is executed on the stream of input data, producing a stream of output data.  For example, the first task may be to filter the input audio to remove high-frequency components.  Subsequently, a second task may receive the filtered audio, and boost the bass low-frequency components.  Observe that, in such a scenario, the two tasks may be overlapped with one another.  Input samples are continuously received by the first task and given to the second task.</p>
<p>SmartHLS provides a way for a developer to specify data flow parallelism through the use of function pipelining (see <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a>) and/or threads (see <a class="reference internal" href="#data-flow-parallelism-with-pthreads"><span class="std std-ref">Data Flow Parallelism with SmartHLS Threads</span></a>) with SmartHLS’s FIFO library (see <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a>) used to connect the streaming modules.</p>
</section>
</section>
<section id="smarthls-overview">
<h2><span class="section-number">1.2. </span>SmartHLS Overview<a class="headerlink" href="#smarthls-overview" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS accepts a C/C++ software program as input and automatically generates hardware described in Verilog HDL (hardware description language) that can be programmed onto a Microchip FPGA.
The generated hardware can be imported as an HDL+ component into SmartDesign with a Tcl script that is also generated by SmartHLS.</p>
<img alt="_images/smarthls_flow.png" src="_images/smarthls_flow.png" />
<p>In a software program, user first needs to specify a top-level function (during project creation in the SmartHLS IDE or in the source code with our pragma, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span> <span class="pre">&lt;function_name&gt;</span></code> ). Please refer to the <a class="reference internal" href="#custom-top-level"><span class="std std-ref">Specifying the Top-level Function</span></a> section for more details specifying the top-level function.</p>
<p>Then the following button, <code class="docutils literal notranslate"><span class="pre">Compile</span> <span class="pre">Software</span> <span class="pre">to</span> <span class="pre">Hardware</span></code> can be clicked to compile software to hardware:</p>
<a class="reference internal image-reference" href="_images/icon_hardware_flow.png"><img alt="_images/icon_hardware_flow.png" class="align-center" src="_images/icon_hardware_flow.png" style="width: 195.0px; height: 39.0px;" /></a>
<p>This will compile the top-level function and all of its descendant functions into hardware.
The rest of the program (outside the top-level function) is considered as the software testbench, to give inputs into the top-level function and verify outputs from the top-level function (and its descendants).
The software testbench is used to automatically generate the RTL testbench and stimulus for <a class="reference internal" href="#sw-hw-co-simulation">SW/HW Co-Simulation</a>.</p>
</section>
<section id="smarthls-pragmas">
<span id="id1"></span><h2><span class="section-number">1.3. </span>SmartHLS Pragmas<a class="headerlink" href="#smarthls-pragmas" title="Permalink to this headline">¶</a></h2>
<p>Pragmas can be applied to the software code by the user to apply HLS optimization techniques and/or guide the compiler for hardware generation.
They are applied directly on the applicable software construct (i.e., function, loop, argument, array) to specify a certain optimization for them. For example, to apply pipelining on a loop:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>For more details on the supported pragmas, please refer to <a class="reference internal" href="pragmas.html#pragmas"><span class="std std-ref">SmartHLS Pragmas Manual</span></a>.
For more details on loop pipelining, please refer to <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>.</p>
</section>
<section id="smarthls-constraints">
<span id="id2"></span><h2><span class="section-number">1.4. </span>SmartHLS Constraints<a class="headerlink" href="#smarthls-constraints" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS also supports user constraints to guide hardware generation.
Whereas pragmas are applied directly on the source code for optimizations that are specific and local to the software construct that it is being applied on (function, loop, memory, argument, etc),
constraints are used for settings that will be globally applied to the entire program (i.e., setting the target FPGA, target clock period).
Each project specifies its constraints in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file in the project directory.
This file is automatically generated by the SmartHLS IDE. To modify the constraints, click the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">Constraints</span></code> button:</p>
<a class="reference internal image-reference" href="_images/icon_constraints.png"><img alt="_images/icon_constraints.png" class="align-center" src="_images/icon_constraints.png" style="width: 174.75px; height: 48.0px;" /></a>
<p>The following window will open:</p>
<a class="reference internal image-reference" href="_images/empty_constraint_setting_window.png"><img alt="_images/empty_constraint_setting_window.png" class="align-center" src="_images/empty_constraint_setting_window.png" style="width: 600.0px; height: 380.25px;" /></a>
<p>You can add, edit, or remove constraints from this window.
Select a constraint type from the first drop-down menu. If you want more information about
a constraint, click the Help button, which will open the corresponding <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a> page.</p>
<p>An important constraint is the target clock period (shown as <code class="docutils literal notranslate"><span class="pre">Set</span> <span class="pre">target</span> <span class="pre">clock</span> <span class="pre">period</span></code> in the drop-down menu).
With this constraint, SmartHLS schedules the operations of a program to meet the specified clock period.
When this constraint is not given, SmartHLS uses the default clock period for each device, as shown below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12%" />
<col style="width: 27%" />
<col style="width: 33%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>FPGA Vendor</p></th>
<th class="head"><p>Device</p></th>
<th class="head"><p>Default Clock Frequency (MHz)</p></th>
<th class="head"><p>Default Clock Period (ns)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Microsemi</p></td>
<td><p>PolarFire</p></td>
<td><p>100</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>Microsemi</p></td>
<td><p>SmartFusion2</p></td>
<td><p>100</p></td>
<td><p>10</p></td>
</tr>
</tbody>
</table>
<p>Details of all SmartHLS constraints are given in the <a class="reference internal" href="constraintsmanual.html#constraints"><span class="std std-ref">Constraints Manual</span></a>.</p>
</section>
<section id="specifying-the-top-level-function">
<span id="custom-top-level"></span><h2><span class="section-number">1.5. </span>Specifying the Top-level Function<a class="headerlink" href="#specifying-the-top-level-function" title="Permalink to this headline">¶</a></h2>
<p>When compiling software to hardware with SmartHLS, you must specify the top-level function for your program.
Then SmartHLS will compile the specified top-level function and all of its descendant functions to hardware.
The remainder of the program (i.e., parent functions of the top-level function, typically the <code class="docutils literal notranslate"><span class="pre">main</span></code> function)
becomes a software testbench that is used for <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.
If there are multiple functions to be compiled to hardware, you should create a wrapper function that calls all of the
desired functions.
There are two ways to specify the top-level function.
The first way is to specify it during project creation in the SmartHLS IDE, as shown below.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/top_level_project_creation.png"><img alt="_images/top_level_project_creation.png" class="align-center" src="_images/top_level_project_creation.png" style="width: 408.8px; height: 394.40000000000003px;" /></a>
</div></blockquote>
<p>This will save the top-level function constraint into the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code>. After creating the project, if you open up the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">Constraints</span></code> window, the top-level function should show there.</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/top_level_constraints_dialog.png"><img alt="_images/top_level_constraints_dialog.png" class="align-center" src="_images/top_level_constraints_dialog.png" style="width: 707.4px; height: 442.8px;" /></a>
</div></blockquote>
<p>You can edit or remove the function from this window.</p>
<p>Alternatively, the top-level function can also be specified with the pragma, <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code>, directly on the source code, below the function prototype, as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">top</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="cp">#pragma HLS function top</span>
   <span class="p">...</span>
   <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Please note that you <em>cannot</em> specify the top-level function using both the pragma and in project creation/HLS Constraints window.
If you have specified the top-level function during project creation, you should not specify it again with the pragma.
If you want to use the pragma, you should leave the <cite>Top-Level Function</cite> box empty during project creation or remove the specified top-level function in the HLS Constraints window.</p>
</div>
</section>
<section id="sw-hw-co-simulation">
<span id="sw-hw-cosimulation"></span><h2><span class="section-number">1.6. </span>SW/HW Co-Simulation<a class="headerlink" href="#sw-hw-co-simulation" title="Permalink to this headline">¶</a></h2>
<p>The circuit generated by SmartHLS should be functionally equivalent to the input software.
Users should not modify the generated Verilog, as it is overwritten every time SmartHLS runs.</p>
<p>SW/HW co-simulation can be used to verify that the generated hardware produces the same outputs for the same inputs as software.
With SW/HW co-simulation, user does not have to write their own RTL testbench, as it is automatically generated.
If user already has their own custom RTL testbench, one can optionally choose their custom RTL testbench (<a class="reference internal" href="#custom-testbench"><span class="std std-ref">Specifying a Custom Test Bench</span></a>) and not use SW/HW co-simulation.</p>
<p>To use SW/HW co-simulation, the input software program will be composed of two parts,</p>
<ul class="simple">
<li><p>A top-level function (and its descendant functions) to be synthesized to hardware by SmartHLS,</p></li>
<li><p>A C/C++ testbench (the parent functions of the top-level function, typically <code class="docutils literal notranslate"><span class="pre">main()</span></code>) that invokes the top-level function with test inputs and verifies outputs.</p></li>
</ul>
<p>SW/HW co-simulation consists of the following automated steps:</p>
<ol class="arabic simple">
<li><p>SmartHLS runs your software program and saves all the inputs passed to the top-level function.</p></li>
<li><p>SmartHLS automatically creates an RTL testbench that reads in the inputs from step 1 and passes them into the SmartHLS-generated hardware module.</p></li>
<li><p>ModelSim simulates the testbench and saves the SmartHLS-generated module outputs.</p></li>
<li><p>SmartHLS runs your software program again, but uses the simulation outputs as the output of your top-level function.</p></li>
</ol>
<p>You should write your C/C++ testbench such that the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function returns a 0 when all outputs from the top-level function are as expected and otherwise return a non-zero value. We use this return value to determine whether the SW/HW co-simulation has passed.
In step 1, we verify that the program returns 0.
In step 4, we run the program using the outputs from simulation and if the SmartHLS-generated circuit matches the C program then <code class="docutils literal notranslate"><span class="pre">main()</span></code> should still return 0.</p>
<p>If the C/C++ program matches the RTL simulation then you should see: <code class="docutils literal notranslate"><span class="pre">SW/HW</span> <span class="pre">co-simulation:</span> <span class="pre">PASS</span></code></p>
<p>For any values that are shared between software testbench and hardware functions (top-level and descendants), you can either pass in as arguments into the top-level function, or if it is a global variable, it can be directly accessed without being passed in as an argument.
Any variables that are accessed by both software testbench and hardware functions will create an interface at the top-level module.
For example, if there is an array that is initialized in the software testbench and is used as an input to the hardware function, you may pass the array as an argument into the top-level function, which will create a memory interface for the array in the hardware core generated by SmartHLS.
Arguments into the top-level function can be constants, pointers, arrays, and FIFO data types.
The top-level function can also have a return value.
Please refer to the included example in the SmartHLS IDE, <code class="docutils literal notranslate"><span class="pre">C++</span> <span class="pre">Canny</span> <span class="pre">Edge</span> <span class="pre">Detection</span> <span class="pre">(SW/HW</span> <span class="pre">Co-Simulation)</span></code>, as a reference.</p>
<p>If a top-level argument is coming from a dynamically allocated array (e.g., malloc), the size of the array (in bytes) must be specified with our <code class="docutils literal notranslate"><span class="pre">interface</span></code> pragma (e.g., <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">interface</span> <span class="pre">argument(&lt;arg_name&gt;)</span> <span class="pre">depth(&lt;int&gt;)</span></code>).
Please see the <a class="reference internal" href="pragmas_docs/interface_memory_argument.html#pragma-interface-memory-argument"><span class="std std-ref">Configure Argument as Memory Interface</span></a> for more details. The sizes of arrays that are statically allocated do not need to be specified with the pragma, as SmartHLS will automatically determine them.</p>
<p>For debugging purposes, SmartHLS converts any C <code class="docutils literal notranslate"><span class="pre">printf</span></code>
statements into Verilog <code class="docutils literal notranslate"><span class="pre">$write</span></code> statements so that values printed during
software execution will also be printed during hardware simulation. This
allows easy verification of the correctness of the hardware circuit.  Verilog
<code class="docutils literal notranslate"><span class="pre">$write</span></code> statements are unsynthesizable and will not affect the final FPGA
hardware.</p>
<p>To specify the arguements to be passed to the software testbench (i.e., <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">main(int</span> <span class="pre">argc,</span> <span class="pre">char</span> <span class="pre">*argv[])</span></code>), a Makefile argument <code class="docutils literal notranslate"><span class="pre">MAIN_INPUT_ARGS</span></code> can be defined in a <code class="docutils literal notranslate"><span class="pre">makefile.user</span></code> file (you need to create the file in the SmartHLS project folder).
For example, if a software testbench takes in two arguments, an input BMP file and a golden output BMP file, you would specify the following in the <code class="docutils literal notranslate"><span class="pre">makefile.user</span></code> file,</p>
<blockquote>
<div><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">MAIN_INPUT_ARGS</span> <span class="o">=</span> <span class="n">input_file</span><span class="p">.</span><span class="n">bmp</span> <span class="n">golden_output_file</span><span class="p">.</span><span class="n">bmp</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Limitations:</p>
<ul class="simple">
<li><p>When function pipelining is used, the top-level function cannot have array
interfaces (array arguments or global arrays that are accessed from both SW
testbench and HW functions).</p></li>
<li><p>When multi-threading is used (<a class="reference internal" href="#pthreads-multithreading"><span class="std std-ref">Multi-threading with SmartHLS Threads</span></a>), Co-Simulation
can only support the case when all threads are joined in the functions where
the threads are forked.  Free-running threads (that are continuously running
and never joined) are not supported by SW/HW Co-Simulation.</p></li>
</ul>
</div>
</section>
<section id="loop-pipelining">
<span id="id3"></span><h2><span class="section-number">1.7. </span>Loop Pipelining<a class="headerlink" href="#loop-pipelining" title="Permalink to this headline">¶</a></h2>
<p>Loop pipelining is an optimization that can automatically extract
loop-level parallelism to create an efficient hardware pipeline.
It allows executing multiple loop iterations concurrently on the same pipelined hardware.</p>
<p>To use loop pipelining, the user needs to specify the loop pipeline pragma above the applicable loop:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span>
<span class="p">}</span>
</pre></div>
</div>
<p>An important concept in loop pipelining is the <em>initiation interval (II)</em>, which is
the cycle interval between starting successive iterations of the loop.
The best performance and hardware utilization is achieved when II=1, which means
that successive iterations of the loop can begin every clock cycle.
A pipelined loop with an II=2 means that successive iterations of the loop
can begin every two clock cycles, corresponding to half of the throughput of an II=1 loop.</p>
<p>By default, SmartHLS always attempts to create a pipeline with an II=1.
However, this is not possible in some cases due to resource constraints or
cross-iteration dependencies. Please refer to <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> on more examples and details on loop pipelining.
When II=1 cannot be met, SmartHLS’s pipeline scheduling algorithm will try to find the smallest possible II
that satisfies the constraints and dependencies.</p>
</section>
<section id="multi-threading-with-smarthls-threads">
<span id="pthreads-multithreading"></span><h2><span class="section-number">1.8. </span>Multi-threading with SmartHLS Threads<a class="headerlink" href="#multi-threading-with-smarthls-threads" title="Permalink to this headline">¶</a></h2>
<p>In an FPGA hardware system, the same module can be instantiated multiple times to exploit spatial parallelism, where all module instances execute in parallel to achieve higher throughput.
SmartHLS allows easily inferring such parallelism with the use of SmartHLS Threads which is a simplified API of <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> commonly used in software.
Parallelism described in software with SmartHLS threads is automatically compiled to parallel hardware with SmartHLS.
Each thread in software becomes an independent module that concurrently executes in hardware.</p>
<p>For example, the code snippet below creates <code class="docutils literal notranslate"><span class="pre">N</span></code> threads running the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> function in software.
SmartHLS will correspondingly create <code class="docutils literal notranslate"><span class="pre">N</span></code> hardware instances all implementing the <code class="docutils literal notranslate"><span class="pre">Foo</span></code> function, and parallelize their executions.
SmartHLS also supports mutex and barrier APIs so that synchronization between threads can be specified using locks and barriers.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">Foo</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">arg</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kr">thread</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Foo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>SmartHLS supports <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> APIs, which are listed below in
<a class="reference internal" href="#supported-parallel-apis"><span class="std std-ref">Supported SmartHLS Thread APIs</span></a>.</p>
<p>Note that for a <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> kernel, SmartHLS will automatically inline any of its descendant functions.
The inlining cannot be overridden with the <code class="docutils literal notranslate"><span class="pre">noinline</span></code> pragma (see <a class="reference internal" href="pragmas.html#pragmas"><span class="std std-ref">SmartHLS Pragmas Manual</span></a>).</p>
</section>
<section id="supported-smarthls-thread-apis">
<span id="supported-parallel-apis"></span><h2><span class="section-number">1.9. </span>Supported SmartHLS Thread APIs<a class="headerlink" href="#supported-smarthls-thread-apis" title="Permalink to this headline">¶</a></h2>
<p>You can use SmartHLS thread library by including the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/thread.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The thread library is provided as a C++ template class.
The template argument of <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;T&gt;</span></code> object specifies the return type <code class="docutils literal notranslate"><span class="pre">T</span></code> of the threaded function.
For example, <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;int&gt;</span></code> is a thread that can invoke a function with <code class="docutils literal notranslate"><span class="pre">int</span></code> return type,
and <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;void&gt;</span></code> is a thread that can invoke a function that returns <code class="docutils literal notranslate"><span class="pre">void</span></code>.</p>
<p>To start the parallel execution of a function, we will pass the function and
function call arguments to the constructor of a new thread instance,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// f1 is a function that we would like to execute concurrently.</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>

<span class="c1">// Create a new thread &#39;t1&#39; with the function &#39;f1&#39; and argument &#39;m&#39;.</span>
<span class="c1">// - &lt;void&gt; corresponds to the return type of &#39;f1&#39;.</span>
<span class="c1">// - Argument &#39;m&#39; corresponds to the parameter &#39;a&#39; of &#39;f1&#39;.</span>
<span class="c1">// - In software, this line creates a parallel thread to run the f1 function.</span>
<span class="c1">// - In hardware, this line means a dedicated hardware module for f1 should</span>
<span class="c1">// be created for this specific thread call, and the dedicated hardware</span>
<span class="c1">// module will start the execution right here.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>


<span class="c1">// Another way to create a parallel thread:</span>
<span class="kt">int</span> <span class="nf">f2</span><span class="p">();</span>                     <span class="c1">// f2 has no argument and the return type is &lt;int&gt;.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span><span class="p">;</span>        <span class="c1">// Create a thread &#39;t2&#39; instance first.</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>  <span class="c1">// Assign &#39;t2&#39; later with the function and arguments.</span>
</pre></div>
</div>
<p>The code below shows how to join a thread (i.e., wait for the thread
completion), and optionally retrieve a non-void return value.
Note that joining a thread will block the execution until the threaded function finishes.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">t1</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>
<span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// The program will block here until thread &#39;t1&#39; finishes running &#39;f1&#39;.</span>

<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>  <span class="c1">// The program will wait for t2 to finish and retrieve the return value.</span>
</pre></div>
</div>
<p>If you have used <code class="docutils literal notranslate"><span class="pre">std::thread</span></code>, you may know passing an argument by reference requires a <code class="docutils literal notranslate"><span class="pre">std::ref</span></code> wrapper around the argument.
Similarly, <code class="docutils literal notranslate"><span class="pre">hls::ref</span></code> is used to wrap the passed-in by reference argument when the <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> is created:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>SmartHLS threads differs from <code class="docutils literal notranslate"><span class="pre">std::thread</span></code> in a few aspects:</p>
<ul class="simple">
<li><p>SmartHLS threads support retrieving the return value from the threaded function (this functionality is only supported using <code class="docutils literal notranslate"><span class="pre">std::future</span></code> in the standard threading library).</p></li>
<li><p>SmartHLS threads use templates to specify the return type of the threaded function.</p></li>
<li><p>SmartHLS threads are auto-detaching, which means if the function where the thread is created is exited without using <code class="docutils literal notranslate"><span class="pre">join</span></code>, the thread will be detached when destructed.
But the threaded function can continue executing.</p></li>
</ul>
</div>
<p>SmartHLS thread library also supports <code class="docutils literal notranslate"><span class="pre">mutex</span></code> and <code class="docutils literal notranslate"><span class="pre">barrier</span></code> as synchronization primitives.</p>
<p><code class="docutils literal notranslate"><span class="pre">mutex</span></code> can be used to protect shared data from being simultaneously accessed by multiple threads.
<code class="docutils literal notranslate"><span class="pre">hls::mutex</span></code> has <code class="docutils literal notranslate"><span class="pre">lock()</span></code> and <code class="docutils literal notranslate"><span class="pre">unlock()</span></code> methods. The example below shows how to create and use <code class="docutils literal notranslate"><span class="pre">hls::mutex</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hls</span><span class="o">::</span><span class="n">mutex</span> <span class="n">m</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">m</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
  <span class="p">....</span>
  <span class="n">m</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">barrier</span></code> provides a thread-coordination mechanism that allows at most an expected number of threads to block until the expected number of threads arrive at the barrier.
<code class="docutils literal notranslate"><span class="pre">hls::barrier</span></code> has <code class="docutils literal notranslate"><span class="pre">init()</span></code> and <code class="docutils literal notranslate"><span class="pre">wait()</span></code> methods. The following example illustrates the use of <code class="docutils literal notranslate"><span class="pre">hls::barrier</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">hls</span><span class="o">::</span><span class="n">barrier</span> <span class="n">bar</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">f1</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">....</span>
  <span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">f2</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">....</span>
  <span class="n">bar</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">bar</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f1</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>
  <span class="p">....</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="data-flow-parallelism-with-smarthls-threads">
<span id="data-flow-parallelism-with-pthreads"></span><h2><span class="section-number">1.10. </span>Data Flow Parallelism with SmartHLS Threads<a class="headerlink" href="#data-flow-parallelism-with-smarthls-threads" title="Permalink to this headline">¶</a></h2>
<p>Data flow parallelism is another commonly used technique to improve hardware throughput, where a succession of computational tasks that process
continuous streams of data can execute in parallel.
The concurrent execution of computational tasks can also be accurately described in software using <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code> APIs.
In addition, the continuous streams of data flowing through the tasks can be inferred using SmartHLS’s built-in FIFO data structure (see <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a>).</p>
<p>Let’s take a look at the code snippet below, which is from the example project, “Fir Filter (Loop Pipelining with <code class="docutils literal notranslate"><span class="pre">hls::thread</span></code>)”, included in the SmartHLS IDE.
In the example, the <code class="docutils literal notranslate"><span class="pre">main</span></code> function contains the following code snippet:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create input and output FIFOs</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">input_fifo</span><span class="p">(</span><span class="cm">/*depth*/</span> <span class="mi">2</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">output_fifo</span><span class="p">(</span><span class="cm">/*depth*/</span> <span class="mi">2</span><span class="p">);</span>

<span class="c1">// Launch thread kernels.</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_fir</span><span class="p">(</span><span class="n">FIRFilterStreaming</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_injector</span><span class="p">(</span><span class="n">test_input_injector</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">);</span>
<span class="n">hls</span><span class="o">::</span><span class="kr">thread</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">thread_var_checker</span><span class="p">(</span><span class="n">test_output_checker</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">);</span>

<span class="c1">// Join threads.</span>
<span class="n">thread_var_injector</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">thread_var_checker</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</pre></div>
</div>
<p>The corresponding hardware is illustrated in the figure below.</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/FIR_Pthreads_schematic.png"><img alt="_images/FIR_Pthreads_schematic.png" src="_images/FIR_Pthreads_schematic.png" style="width: 408.8px; height: 57.6px;" /></a>
</figure>
<p>The two hls::FIFO&lt;int&gt;s in the C++ code corresponds to the creation of the two FIFOs, where the bit-width is set according to the type shown in the constructor argument &lt;int&gt;.
The three <code class="docutils literal notranslate"><span class="pre">hls::thread&lt;void&gt;</span></code> calls initiate and parallelize the executions of three computational tasks, where each task is passed in a FIFO (or a pointer to a struct containing more than one FIFO pointers) as its argument.</p>
<p>The FIFO connections and data flow directions are implied by the uses of FIFO <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code> APIs.
For example, the <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> function has a <code class="docutils literal notranslate"><span class="pre">write()</span></code> call writing data into the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>, and the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> function uses a <code class="docutils literal notranslate"><span class="pre">read()</span></code> call to read data out from the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>.
This means that the data flows through the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> from <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> to <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">join()</span></code> API is called to wait for the completion of <code class="docutils literal notranslate"><span class="pre">test_input_injector</span></code> and <code class="docutils literal notranslate"><span class="pre">test_output_checker</span></code>.
We do not “join” the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> thread since it contains an
infinite loop (see code below) that is always active and processes incoming
data from <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> whenever the FIFO is not empty.
This closely matches the <em>always running</em> behaviour of streaming hardware, where hardware is constantly running and processing data..</p>
<p>Now let’s take a look at the implementation of the main computational task (i.e., the <code class="docutils literal notranslate"><span class="pre">FIRFilterStreaming</span></code> threading function).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span> <span class="kt">void</span> <span class="nf">FIRFilterStreaming</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">input_fifo</span><span class="p">,</span>
                         <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
     <span class="c1">// This loop is pipelined and will be &quot;always running&quot;, just like how a</span>
     <span class="c1">// streaming module always runs when new input is available.</span>
     <span class="cp">#pragma HLS loop pipeline</span>
     <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// Read from input FIFO.</span>
         <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="n">input_fifo</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">();</span>

         <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FIRFilterStreaming input: %d - %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">in</span><span class="p">);</span>
         <span class="k">static</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span> <span class="c1">// Need to store the last TAPS -1 samples.</span>
         <span class="k">const</span> <span class="kt">int</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>  <span class="mi">3</span><span class="p">,</span>  <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>
                                         <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">};</span>

         <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">temp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">)</span>
             <span class="n">previous</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
         <span class="n">previous</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

         <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">TAPS</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
             <span class="n">temp</span> <span class="o">+=</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>

         <span class="kt">int</span> <span class="n">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">temp</span><span class="p">;</span>

         <span class="c1">// Write to output FIFO.</span>
         <span class="n">output_fifo</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">output</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the code shown in the example project, you will notice that all three threading functions contain a loop, which repeatedly reads and/or writes data from/to FIFOs to perform processing.
In SmartHLS, this is how one can specify that functions are continuously processing data streams that are flowing through FIFOs.</p>
<section id="further-throughput-enhancement-with-loop-pipelining">
<h3><span class="section-number">1.10.1. </span>Further Throughput Enhancement with Loop Pipelining<a class="headerlink" href="#further-throughput-enhancement-with-loop-pipelining" title="Permalink to this headline">¶</a></h3>
<p>In this example, the throughput of the streaming circuit will be limited by how frequently the functions can start processing new data (i.e., how frequently the new loop iterations can be started).
For instance, if the slowest function among the three functions can only start a new loop iteration every 4 cycles, then the throughput of the entire streaming circuit will be limited to processing one piece of data every 4 cycles.
Therefore, as you may have guessed, we can further improve the circuit throughput by pipelining the loops in the three functions.
If you run SmartHLS synthesis for the example (<code class="docutils literal notranslate"><span class="pre">Compile</span> <span class="pre">Software</span> <span class="pre">to</span> <span class="pre">Hardware</span></code>), you should see in the <code class="docutils literal notranslate"><span class="pre">Pipeline</span> <span class="pre">Result</span></code> section of our report file, <code class="docutils literal notranslate"><span class="pre">summary.hls.rpt</span></code>, that all loops can be pipelined with an initiation interval of 1.
That means all functions can start a new iteration every clock cycle, and hence the entire streaming circuit can process one piece of data every clock cycle.
Now run the simulation (<code class="docutils literal notranslate"><span class="pre">Simulate</span> <span class="pre">Hardware</span></code>) to confirm our expected throughput. The reported cycle latency should be just slightly more than the number of data samples to be processed
(<code class="docutils literal notranslate"><span class="pre">INPUTSIZE</span></code> is set to 128; the extra cycles are spent on activating the parallel accelerators, flushing out the pipelines, and verifying the results).</p>
</section>
</section>
<section id="function-pipelining">
<span id="id4"></span><h2><span class="section-number">1.11. </span>Function Pipelining<a class="headerlink" href="#function-pipelining" title="Permalink to this headline">¶</a></h2>
<p>You have just seen how an efficient streaming circuit can be described in software by using loop pipelining with SmartHLS threads.
An alternative way to describe such a streaming circuit is to use <code class="docutils literal notranslate"><span class="pre">Function</span> <span class="pre">Pipelining</span></code>.
When a function is marked to be pipelined (by using the <code class="docutils literal notranslate"><span class="pre">Pipeline</span> <span class="pre">Function</span></code> constraint), SmartHLS will implement the function as a pipelined circuit that can start a new invocation every <code class="docutils literal notranslate"><span class="pre">II</span></code> cycles.
That is, the circuit can execute again while its previous invocation is still executing, allowing it to continuously process incoming data in a pipelined fashion.
This essentially has the same circuit behaviour as what was described in the previous example (loop pipelining with threads) in the <a class="reference internal" href="#data-flow-parallelism-with-pthreads"><span class="std std-ref">Data Flow Parallelism with SmartHLS Threads</span></a> section, without having to write the software code using threads.
This feature also allows multiple functions that are added to the <code class="docutils literal notranslate"><span class="pre">Pipeline</span> <span class="pre">function</span></code> constraint to execute in parallel, achieving the same hardware behaviour as the previous loop pipelining with threads example.</p>
<p>When using this feature, the user-specified top-level function (see <a class="reference internal" href="#custom-top-level"><span class="std std-ref">Specifying the Top-level Function</span></a>) can only call functions that are specified to be function pipelined (e.g., the top-level function cannot call one function pipeline and one non-function pipeline).
The top-level function cannot have any control flow (i.e., loops, if/else statements), and cannot perform any operations other than declaring variables (i.e., memories, FIFOs) and calling function pipelines.</p>
<p>For SW/HW co-simulation, the top-level function that calls one or more function pipelines can only have interfaces that are created from FIFOs and constant values (top-level interfaces are created from top-level function arguments and global variables that are accessed from both software testbench functions and hardware kernel functions).</p>
<p>Please refer to the <cite>C++ Canny Edge Detection (SW/HW Co-Simulation)</cite> example included in the SmartHLS IDE for an example of using function pipelining.</p>
<p>In this example, you should see the top-level function, <code class="docutils literal notranslate"><span class="pre">canny</span></code>, as below.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">canny</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span>
           <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
   <span class="cp">#pragma HLS function top</span>

   <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">output_fifo_gf</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>
   <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">short</span><span class="o">&gt;</span> <span class="n">output_fifo_sf</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>
   <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">output_fifo_nm</span><span class="p">(</span><span class="cm">/* depth = */</span> <span class="mi">2</span><span class="p">);</span>

   <span class="n">gaussian_filter</span><span class="p">(</span><span class="n">input_fifo</span><span class="p">,</span> <span class="n">output_fifo_gf</span><span class="p">);</span>
   <span class="n">sobel_filter</span><span class="p">(</span><span class="n">output_fifo_gf</span><span class="p">,</span> <span class="n">output_fifo_sf</span><span class="p">);</span>
   <span class="n">nonmaximum_suppression</span><span class="p">(</span><span class="n">output_fifo_sf</span><span class="p">,</span> <span class="n">output_fifo_nm</span><span class="p">);</span>
   <span class="n">hysteresis_filter</span><span class="p">(</span><span class="n">output_fifo_nm</span><span class="p">,</span> <span class="n">output_fifo</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As shown above, the top-level function has been specified with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">top</span></code>. The top-level function calls four functions, <code class="docutils literal notranslate"><span class="pre">gaussian_filter,</span> <span class="pre">sobel_filter,</span> <span class="pre">nonmaximum_suppression,</span> <span class="pre">and</span> <span class="pre">hysteresis_filter</span></code>, each of which are specified to be function pipelined (with <code class="docutils literal notranslate"><span class="pre">#pragma</span> <span class="pre">HLS</span> <span class="pre">function</span> <span class="pre">pipeline</span></code>).
The top-level arguments are <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code>. The <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> is given as an argument into the first function, <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code>, and gives the inputs into the overall circuit.
The <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code> is given as an argument into the last function, <code class="docutils literal notranslate"><span class="pre">hysteresis_filter</span></code>, and receives the outputs of the overall circuit.
There are also intermediate FIFOs, <code class="docutils literal notranslate"><span class="pre">output_fifo_gf</span></code>, <code class="docutils literal notranslate"><span class="pre">output_fifo_sf</span></code>, and <code class="docutils literal notranslate"><span class="pre">output_fifo_nm</span></code>, which are given as arguments into the function pipelines and thus connect them (i.e., outputs of <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code> is given as inputs to <code class="docutils literal notranslate"><span class="pre">sobel_filter</span></code>).</p>
<p>When synthesizing a top-level function with multiple pipelined sub-functions, SmartHLS will automatically parallelize the execution of all sub-functions that are called in the top-level function, forming a streaming circuit with data flow parallelism.
In this case <code class="docutils literal notranslate"><span class="pre">gaussian_filter</span></code> executes as soon as there is data in the <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code>, and <code class="docutils literal notranslate"><span class="pre">sobel_filter</span></code> starts running as soon as there is data in the <code class="docutils literal notranslate"><span class="pre">output_fifo_sf</span></code>.
In other words, a function pipeline does not wait for its previous function pipeline to completely finish running before it starts to execute, but rather, it starts running as early as possible.
Each function pipeline also starts working on the next data while the previous data is being processed (in a pipelined fashion).
If the initiation interval (II) is 1, a function pipeline starts processing new data every clock cycle.
Once the function pipelines reach steady-state, all function pipelines execute concurrently.
This example showcases the synthesis of a streaming circuit that consists of a succession of concurrently executing pipelined functions.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In the generated Verilog for a function pipelined hardware, the <code class="docutils literal notranslate"><span class="pre">start</span></code> input port serves as an enable signal to the circuit.
The circuit stops running when the <code class="docutils literal notranslate"><span class="pre">start</span></code> signal is de-asserted. To have the circuit running continuously, the <code class="docutils literal notranslate"><span class="pre">start</span></code> input port should be kept high.</p>
</div>
</section>
<section id="memory-partitioning">
<span id="id5"></span><h2><span class="section-number">1.12. </span>Memory Partitioning<a class="headerlink" href="#memory-partitioning" title="Permalink to this headline">¶</a></h2>
<p>Memory Partitioning is an optimization where aggregate types such as arrays and structs are partitioned into smaller pieces
allowing for a greater number of reads and writes (accesses) per cycle. SmartHLS instantiates a RAM for each aggregate
type where each RAM has up to two ports (allowing up to two reads/writes per cycle). Partitioning aggregate types into
smaller memories or into its individual elements allows for more accesses per cycle and improves memory bandwidth.</p>
<p>There are two flavors of memory partitioning, access-based partitioning and user-specified partitioning.</p>
<section id="access-based-memory-partitioning">
<h3><span class="section-number">1.12.1. </span>Access-Based Memory Partitioning<a class="headerlink" href="#access-based-memory-partitioning" title="Permalink to this headline">¶</a></h3>
<p>Access-based partitioning is automatically applied to all memories except for those at the top-level interfaces (<a class="reference internal" href="hwarchitecture.html#io-memory"><span class="std std-ref">I/O Memory</span></a>).
This flavor of memory partitioning will analyze the ranges of all accesses to a memory and create partitions based on
these accesses. After analyzing all memory accesses, independent partitions will be implemented in independent memories.
If two partitions overlap in what they access, they will be merged into one partition. If there are any sections of the memory that is not accessed, it will be discarded to reduce memory usage.
For example, if there are two loops, where one loop accesses the first half of an array and the second loop accesses the second half of the array, the accesses to the array from the two loops are completely independent.
In this case the array will be partitioned into two and be implemented in two memories, one that holds the first half of the array and another that holds the second half of the array.
However, if both loops access the entire array, their accesses overlap, hence the two partitions will be merged into one and the array will just be implemented in a single memory (without being partitioned).
Access-based partitioning is done automatically without needing any memory partition pragmas, in order to automatically improve memory bandwidth and reduce memory usage whenever possible.</p>
<p><strong>Example</strong></p>
<p>Access-based partitioning is automatically applied to all memories by SmartHLS except for interface memories (top-level function arguments and global variables accessed by both software testbench and hardware functions) to the
top-level function. Interface memories need to be partitioned with the memory partition pragma.
See the code snippet below that illustrate an example of accessed-based partitioning.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">...</span>

<span class="cp">#pragma unroll</span>
<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the example above, each iteration of the loop access an element of <code class="docutils literal notranslate"><span class="pre">array</span></code> and adds it to <code class="docutils literal notranslate"><span class="pre">result</span></code>. The <code class="docutils literal notranslate"><span class="pre">unroll</span></code> pragma is applied to completely unroll the loop.
Without partitioning, SmartHLS will implement this array in a RAM (with eight elements), where an FPGA RAM can have up to two read/write ports.
In this case, the loop will take four cycles, as eight reads are needed from the RAM and up to two reads can be performed per cycle with a two ported memory.</p>
<p>With access-based partitioning, the accesses to the above array will be analyzed. With unrolling, there will be eight
load instructions, each of which will access a single array element, with no overlaps in accesses between the load instructions (i.e., the accesses of each load instruction are independent).
This creates 8 partitions, with one array element in each partition.
After partitioning, all eight reads can occur in the same clock cycle, as each memory will only need one memory access. Hence the entire loop can finish in a single cycle.
With this example, we can see that memory partitioning can help to improve memory bandwidth and improve performance.</p>
<p>With access-based partitioning, SmartHLS outputs messages to the console specifying which memory has been partitioned into how many partitions, as shown below:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Partitioning memory: array into 8 partitions.
</pre></div>
</div>
<p>Limitations:</p>
<ul class="simple">
<li><p>Accessing memory outside of an array dimension is not supported by memory partitioning and may cause
incorrect circuit behavior. An example of this is lowering a 2-d array to a pointer and iterating through the size
of the 2-d array.</p></li>
<li><p>Pointers that alias to different memories or different sections of the same memory (e.g. a pointer that is assigned
to multiple memories based on a condition) are not supported in memory
partitioning. The aliased memories will not be partitioned.</p></li>
</ul>
<p>Please refer to the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> for more examples and details.</p>
</section>
<section id="user-specified-memory-partitioning">
<h3><span class="section-number">1.12.2. </span>User-Specified Memory Partitioning<a class="headerlink" href="#user-specified-memory-partitioning" title="Permalink to this headline">¶</a></h3>
<p>User-specified partitioning can be achieved with the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">memory</span> <span class="pre">partition</span></code> pragma .
User-specified partitioning is where the user explicitly specifies a memory to be partitioned via the <code class="docutils literal notranslate"><span class="pre">memory</span> <span class="pre">partition</span></code> pragma (#pragma HLS memory partition variable, #pragma HLS memory partition argument). See <span class="xref std std-ref">_pragma_memory_partition_argument</span> and <a class="reference internal" href="pragmas_docs/memory_partition_variable.html#pragma-memory-partition-variable"><span class="std std-ref">Partition Memory</span></a> for more details.
User-specified partitioning also analyzes accesses but partitions based on a predefined structure and array dimension.
There are two user-specified partitioning types supported by SmartHLS: <cite>Complete</cite> and <cite>Struct-fields</cite>.</p>
<section id="complete-partitioning">
<h4><span class="section-number">1.12.2.1. </span>Complete Partitioning<a class="headerlink" href="#complete-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Complete partitioning partitions memories based on a user-specified dimension. Memories are then partitioned completely on the specified dimension,
which means the memory is partitioned into individual elements of the specified array dimension. More information on the pragmas can be found in the
pragma references linked above. Unaccessed sections of the original memory are also discarded.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Accessing memory outside of an array dimension is not supported by memory partitioning and may cause
incorrect circuit behavior. An example of this is casting a 2-d array to a pointer (1-d) and iterating through the entire array as 1-d.</p>
</div>
<p><strong>Example</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS memory partition variable(array)</span>
<span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">...</span>

<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example above shows the same example that was shown for access-based partitioning, however, the loop is not unrolled in this case.
Access-based partitioning will try to partition the array but will only find one load instruction in the loop that accesses the entire array.
This preventing access-based partitioning as all eight accesses come from the same load instruction.</p>
<p>User-specified partitioning can be used to force partitioning of this array with a predefined structure. In the example above,
the memory partition pragma specifies the array to be partitioned completely into individual elements. After partitioning,
the array will be partitioned into eight individual elements just like with the access-based partitioning example above.
The benefit in this case is that the loop does not have to be unrolled, which can be useful in cases like when the loop is
pipelined and cannot be unrolled (see <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a>).</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// partitioned completely up to DIM1 from left to right</span>
<span class="cp">#pragma HLS memory partition variable(array3d) type(complete) dim(1)</span>
<span class="kt">int</span> <span class="n">array3d</span><span class="p">[</span><span class="n">DIM2</span><span class="p">][</span><span class="n">DIM1</span><span class="p">][</span><span class="n">DIM0</span><span class="p">];</span>
</pre></div>
</div>
<p>The memory partition pragma has optional arguments <code class="docutils literal notranslate"><span class="pre">type</span></code> and <code class="docutils literal notranslate"><span class="pre">dim</span></code> that specifies the partition type and dimension to be partitioned
up to, respectively. The default type is <code class="docutils literal notranslate"><span class="pre">complete</span></code> which means to partition the array into individual elements, and the default dimension
is <code class="docutils literal notranslate"><span class="pre">0</span></code> which means to partition up to the right-most dimension. The type can also specified to be <code class="docutils literal notranslate"><span class="pre">none</span></code> to prevent partitioning for a
specific memory. The dimension provided specifies the dimension to be partitioned up to, with the resulting partitions being elements of
that array dimension. For example, in the above code snippet <code class="docutils literal notranslate"><span class="pre">array3d</span></code> is specified to be partitioned up dimension 1, which means array
dimensions corresponding to <code class="docutils literal notranslate"><span class="pre">DIM2</span></code> and <code class="docutils literal notranslate"><span class="pre">DIM1</span></code> will be completely partitioned to produce <code class="docutils literal notranslate"><span class="pre">DIM2``x``DIM1</span></code> partitions of <code class="docutils literal notranslate"><span class="pre">int[DIM0]</span></code>.
Lower numbered dimensions correspond to right-ward dimensions of the array and higher numbered dimensions correspond to left-ward dimensions
of the array, as shown by the <code class="docutils literal notranslate"><span class="pre">DIMX</span></code> macros specifying the sizes of the dimensions of <code class="docutils literal notranslate"><span class="pre">array3d</span></code>.</p>
<p>With user-specified partitioning, SmartHLS outputs messages to the console stating the variable set to be partitioned and its settings.
SmartHLS also outputs messages specifying if a memory has been partitioned and into how many partitions.
If a memory is specified to be partitioned but cannot be partitioned, SmartHLS will output a warning.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Found user-specified memory: &quot;array&quot; on line 6 of test.c, with partition type: Complete, partition dimension: 0.
Info: Found user-specified memory: &quot;array3d&quot; on line 27 of test.c, with partition type: Complete, partition dimension: 1.
Warning: The user-specified memory &quot;array3d&quot; on line 27 of test.c could not be partitioned because a loop variable indexing into a multi-dimenional array comes from a loop variable and goes out of the array dimension bounds. Going outside of array dimension bounds is not supported for memory partitioning.
Info: Partitioning memory: array into 8 partitions.
</pre></div>
</div>
<p>Limitations:</p>
<ul class="simple">
<li><p>Accessing memory outside of an array dimension is not supported by memory partitioning and will sometimes cause
incorrect circuit behavior. An example of this is lowering a 2-d array to a pointer and iterating through the size
of the 2-d array.</p></li>
<li><p>Pointers that alias to different memories or different sections of the same memory (e.g. a pointer that is assigned
to multiple memories based on a condition) are not supported in memory
partitioning. The aliased memories will not be partitioned. The exception
to this is that functions that get called with different pointers are handled properly for user-specified
partitioning.</p></li>
</ul>
<p>Please refer to the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a> for more examples and details.</p>
</section>
<section id="struct-fields-partitioning">
<h4><span class="section-number">1.12.2.2. </span>Struct-Fields Partitioning<a class="headerlink" href="#struct-fields-partitioning" title="Permalink to this headline">¶</a></h4>
<p>Struct-fields partitioning partitions a (array of) struct argument / variable into its individual fields such that each field is a partition.
Unlike complete partitioning, if a field in the partitioned struct is an aggregate type (struct or array), the field is not further partitioned to its elements.
Note that applying Struct-fields partitining to  an array-of-struct creates an array for each field in the struct.
Unaccessed paritions (fields) are discarded, but the Unaccessed elements in an aggreagte partition (field) are not be discarded.</p>
<p><strong>Example</strong></p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">Ty</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="nc">SubTy</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="p">};</span>
    <span class="kt">char</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">short</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">SubTy</span> <span class="n">z</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="n">Ty</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(array) type(struct_fields)</span>
    <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">z</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The example above shows an array of struct <cite>array</cite> that is array of struct of type <cite>Ty</cite> that is
partitioned using Struct-fields partitioning.
With the user-specified partitioning, SmartHLS outputs messages to the console stating that the argument
set to be partitioned and how many partitions are created.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Found partition interface: array.
Info: Partitioning memory: array into 3 partitions.
</pre></div>
</div>
<p>The summary report from SmartHLS lists the 3 partitions created from the fields of the struct.
Note that the array field <cite>Ty.y</cite> has one partition, and similarly the struct field <cite>Ty.z</cite>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+---------------------------------------------------------------------------+
| I/O Memories                                                              |
+---------+-----------------------+------+-------------+------------+-------+
| Name    | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
+---------+-----------------------+------+-------------+------------+-------+
| array_x | sum                   | ROM  | 0           | 8          | 0     |
| array_y | sum                   | ROM  | 0           | 16         | 0     |
| array_z | sum                   | ROM  | 0           | 64         | 0     |
+---------+-----------------------+------+-------------+------------+-------+
</pre></div>
</div>
</section>
</section>
</section>
<section id="smarthls-c-c-library">
<h2><span class="section-number">1.13. </span>SmartHLS C/C++ Library<a class="headerlink" href="#smarthls-c-c-library" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS includes a number of C/C++ libraries that allow creation of efficient hardware.</p>
<section id="streaming-library">
<span id="streaming-lib"></span><h3><span class="section-number">1.13.1. </span>Streaming Library<a class="headerlink" href="#streaming-library" title="Permalink to this headline">¶</a></h3>
<p>The streaming library includes the FIFO (first-in first-out) data structure along with its associated API functions.
The library can be compiled in software to run on the host machine (e.g., x86).
Each FIFO instance in software is implemented as a First Word Fall Through (FWFT) FIFO in hardware.</p>
<p>The FIFO library is provided as a C++ template class.
The FIFO data type can be flexibly defined and specified as a template argument of the FIFO object.
For example, the FIFO data type could be defined as a struct containing multiple integers:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">AxisWord</span> <span class="p">{</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">keep</span><span class="p">;</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span> <span class="n">last</span><span class="p">;</span> <span class="p">};</span>

<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">AxisWord</span><span class="o">&gt;</span> <span class="n">my_axi_stream_interface_fifo</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A valid data type could be any of the
1) C/C++ primitive integer types,
2) SmartHLS’s <a class="reference internal" href="#ap-lib"><span class="std std-ref">C++ Arbitrary Precision Data Types Library</span></a> (ap_int, ap_uint, ap_fixpt, ap_ufixpt),
or 3) a struct containing primitive integer types or SmartHLS’s C++ arbitrary
Precision Data Types.
In the case of a struct type, it is prohibited to use ‘ready’ or ‘valid’ as
the name of a struct field.  This is because in the generated Verilog, a FIFO
object will introduce an AXI-stream interface associated with valid/ready
handshaking signals and the names will overlap.</p>
</div>
<p>You can use the C++ streaming library by including the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/streaming.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Users should always use the APIs below to create and access FIFOs. Any other uses of FIFOs are not supported in SmartHLS.</p>
</div>
<p>An example code for using the streaming library is shown below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// declare a 32-bit wide fifo</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">my_fifo</span><span class="p">;</span>
<span class="c1">// set the fifo&#39;s depth to 10</span>
<span class="n">my_fifo</span><span class="p">.</span><span class="n">setDepth</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

<span class="c1">// write to the fifo</span>
<span class="n">my_fifo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="c1">// read from the fifo</span>
<span class="n">MyStructT</span> <span class="n">data</span> <span class="o">=</span> <span class="n">my_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
<span class="c1">// check if fifo is empty</span>
<span class="kt">bool</span> <span class="n">is_empty</span> <span class="o">=</span> <span class="n">my_fifo</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
<span class="c1">// check if the fifo is full</span>
<span class="kt">bool</span> <span class="n">is_full</span> <span class="o">=</span> <span class="n">my_fifo</span><span class="p">.</span><span class="n">full</span><span class="p">();</span>

<span class="c1">// declare a 32-bit wide fifo with a depth of 10</span>
<span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">my_fifo_depth_10</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>
</div>
<p>As shown above, there are two ways of creating a FIFO (<code class="docutils literal notranslate"><span class="pre">hls::FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">hls::FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo_depth_10(10)</span></code>).
The width of the FIFO is determined based on the templated data type of the FIFO.
For example, <code class="docutils literal notranslate"><span class="pre">FIFO&lt;unsigned&gt;</span> <span class="pre">my_fifo</span></code> creates a FIFO that is 32 bits wide.
The FIFO’s data type can be any primitive type or arbitrary bitwidth types (ap_int/ap_uint/ap_fixpt/ap_ufixpt),
or a struct of primitive/arbitrary bitwidth types (or nested structs of those types) but
cannot be a pointer or an array (or a struct with a pointer/array).
An array or a struct of FIFOs is supported.</p>
<p>The depth of the FIFO can be provided by the user as a constructor argument
when the FIFO is declared, or it can also be set afterwards with the <code class="docutils literal notranslate"><span class="pre">setDepth(unsigned</span> <span class="pre">depth)</span></code> function.
If the depth is not provided by the user, SmartHLS uses a default FIFO depth of 2.
The depth of a FIFO can also be set to 0, in which case SmartHLS will create direct ready/valid/data wire connections (without a FIFO) between the source and the sink.</p>
<section id="streaming-library-blocking-behaviour">
<h4><span class="section-number">1.13.1.1. </span>Streaming Library - Blocking Behaviour<a class="headerlink" href="#streaming-library-blocking-behaviour" title="Permalink to this headline">¶</a></h4>
<p>Note that the fifo <code class="docutils literal notranslate"><span class="pre">read()</span></code> and <code class="docutils literal notranslate"><span class="pre">write()</span></code> calls are blocking.
Hence if a module attempts to read from a FIFO that is empty, it will be stalled.
Similarly, if it attempts to write to a FIFO that is full, it will be stalled.
If you want non-blocking behaviour, you can check if the FIFO is
empty (with <code class="docutils literal notranslate"><span class="pre">empty()</span></code>) before calling <code class="docutils literal notranslate"><span class="pre">read()</span></code>, and likewise, check
if the FIFO is full (with <code class="docutils literal notranslate"><span class="pre">full()</span></code>) before calling <code class="docutils literal notranslate"><span class="pre">write()</span></code> (see <a class="reference internal" href="#streaming-lib-non-blocking"><span class="std std-ref">Streaming Library - Non-Blocking Behaviour</span></a>).</p>
<p>With the blocking behaviour, if the depths of FIFOs are not sized properly,
it can cause a deadlock. SmartHLS prints out messages to alert the user that
a FIFO is causing stalls.</p>
<p>In hardware simulation, the following messages are shown.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>Warning: fifo_write<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being full.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_write<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being full.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
Warning: fifo_read<span class="o">()</span> has been stalled <span class="k">for</span>     <span class="m">1000000</span> cycles due to FIFO being empty.
</pre></div>
</div>
<p>If you continue to see these messages, you can suspect that there may be a
deadlock. In this case, we recommend making sure there is no blocking read from
an empty FIFO or blocking write to a full FIFO, and potentially increasing the
depth of the FIFOs.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We recommend the minimum depth of a FIFO to be 2, as a depth of 1 FIFO can cause excessive stalls.</p>
</div>
</section>
<section id="streaming-library-non-blocking-behaviour">
<span id="streaming-lib-non-blocking"></span><h4><span class="section-number">1.13.1.2. </span>Streaming Library - Non-Blocking Behaviour<a class="headerlink" href="#streaming-library-non-blocking-behaviour" title="Permalink to this headline">¶</a></h4>
<p>As mentioned above, non-blocking FIFO behaviour can be created with the use of <code class="docutils literal notranslate"><span class="pre">empty()</span></code> and <code class="docutils literal notranslate"><span class="pre">full()</span></code> functions.
Non-blocking FIFO read and write can be achieved as shown below.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="o">(</span>!fifo_a.empty<span class="o">())</span>
    unsigned <span class="nv">data_in</span> <span class="o">=</span> fifo_a.read<span class="o">()</span><span class="p">;</span>

<span class="k">if</span> <span class="o">(</span>!fifo_b.full<span class="o">())</span>
    fifo_b.write<span class="o">(</span>data_out<span class="o">)</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A deadlock may occur if a fifo with a depth of 0 uses non-blocking write on its source and non-block read on its sink.</p>
</div>
</section>
</section>
<section id="c-arbitrary-precision-data-types-library">
<span id="ap-lib"></span><h3><span class="section-number">1.13.2. </span>C++ Arbitrary Precision Data Types Library<a class="headerlink" href="#c-arbitrary-precision-data-types-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Data Types Library provides numeric types <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code>, which can be used to specify data types of arbitrary bitwidths in software (e.g., ap_int&lt;9&gt; for a 9-bit integer variable).
These data types will be efficiently translated to create hardware with the exact widths. The data types also come with bit manipulation utilities, such as bit range selection and concatenation.</p>
</section>
<section id="c-arbitrary-precision-integer-library">
<h3><span class="section-number">1.13.3. </span>C++ Arbitrary Precision Integer Library<a class="headerlink" href="#c-arbitrary-precision-integer-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> type allows specifying signed and unsigned data types of any bitwidth.
They can be used for arithmetic, concatenation, and bit level operations. You can use the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> type
by including the following header file.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The desired width of the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> can be specified as a template parameter, <code class="docutils literal notranslate"><span class="pre">ap_[u]int&lt;W&gt;</span></code>,
allowing for wider types than the existing C arbitrary bit-width library.</p>
<p>An example using the C++ library is shown below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">(</span><span class="s">&quot;0123456789ABCDEF0123456789ABCDEF&quot;</span><span class="p">);</span>
    <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If this four bit range of data is &lt;= 7</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// iostream doesn&#39;t synthesize to hardware, so only include this</span>
    <span class="c1">// line in software compilation. Any block surrounded by this ifdef</span>
    <span class="c1">// will be ignored when compiling to hardware.</span>
    <span class="cp">#ifdef SMARTHLS_SW</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">res</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the above code we iterate through a 128 bit unsigned integer in four bit segments,
and track the difference between how many segments are above and below 7.
All variables have been reduced to their specified minimum widths.</p>
<section id="printing-arbitrary-precision-integers">
<h4><span class="section-number">1.13.3.1. </span>Printing Arbitrary Precision integers<a class="headerlink" href="#printing-arbitrary-precision-integers" title="Permalink to this headline">¶</a></h4>
<p>The C++ Arbitrary Precision Integer Library provides some utilities for printing <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types. The <code class="docutils literal notranslate"><span class="pre">to_string(base,</span> <span class="pre">signedness)</span></code> function
takes an optional base argument (one of 2, 10, and 16) which defaults to 16, as well as an optional signedness argument which determines if the data
should be printed as signed or unsigned, which defaults to false. The output stream operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> is also overloaded to put arbitrary precision integer
types in the output stream as if they were called with the default <code class="docutils literal notranslate"><span class="pre">to_string</span></code> arguments.</p>
<p>Some example code using these utilities is shown below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">ap_u</span> <span class="o">=</span> <span class="mi">21</span><span class="p">;</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">ap</span> <span class="o">=</span> <span class="mi">-22</span><span class="p">;</span>

<span class="c1">// prints: 0x15</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ap_u</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// prints: -22</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ap</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// prints: 234</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ap</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// prints 00010101</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ap_u</span><span class="p">.</span><span class="n">to_string</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="initializing-arbitrary-precision-integers">
<h4><span class="section-number">1.13.3.2. </span>Initializing Arbitrary Precision integers<a class="headerlink" href="#initializing-arbitrary-precision-integers" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types can be constructed and assigned to from other arbitrary precision integers, C++ integral
types, <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types, as well as concatenations and bit selections. They can also be initialized from a hexadecimal
string describing the exact bits.</p>
<p>Some examples of initializing arbitrary precision integer types are show below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// Initialized to -7</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int1</span> <span class="o">=</span> <span class="mi">-7</span><span class="p">;</span>

<span class="c1">// Initialized to 15</span>
<span class="c1">// The bits below the decimal are truncated.</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int2</span> <span class="o">=</span> <span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">AP_RND</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">15.5</span><span class="p">);</span>

<span class="c1">// Initialized to 132</span>
<span class="c1">// Could also write &quot;0x84&quot;</span>
<span class="c1">// The 0x is optional</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">int3</span><span class="p">(</span><span class="s">&quot;84&quot;</span><span class="p">);</span>

<span class="c1">// Initialized to 4</span>
<span class="c1">// Bit selections are zero extended to match widths</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">int4</span> <span class="o">=</span> <span class="n">int3</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// Initialized to 128</span>
<span class="c1">// ap_uint types are zero extended to match widths</span>
<span class="c1">// ap_int types are sign extended to match widths</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">int5</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;80&quot;</span><span class="p">);</span>

<span class="c1">// Initialized to 2</span>
<span class="c1">// The value 4098 (= 4096 + 2) is wrapped to 2</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">int6</span> <span class="o">=</span> <span class="mi">4098</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="c-arbitrary-precision-integer-arithmetic">
<h4><span class="section-number">1.13.3.3. </span>C++ Arbitrary Precision Integer Arithmetic<a class="headerlink" href="#c-arbitrary-precision-integer-arithmetic" title="Permalink to this headline">¶</a></h4>
<p>The C++ Arbitrary Precision Integer library supports all standard arithmetic, logical bitwise, shifts, and comparison operations.
Note that for shifting that &gt;&gt; and &lt;&lt; are logical, and the .ashr(x) function implements arithmetic right shift.
The output types of an operation are wider than their operands as necessary to hold the result. Operands of ap_int, and ap_uint type,
as well as operands of different widths can be mixed freely.
By default ap_int will be sign extended to the appropriate width for an operation,
while ap_uint will be zero extended. When mixing ap_int and ap_uint in an arithmetic operation
the resulting type will always be ap_int. Some of this behaviour is demonstrated in the example below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">7</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="c1">// Multiply expands to the sum of a and b&#39;s width</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">20</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// Add result in max of widths + 1</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">13</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// Logical bitwise ops result in max of widths</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">;</span>

<span class="c1">// Mixing ap_int and ap_uint results in ap_int</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>

<span class="c1">// ap_(u)int types can be mixed freely with integral types</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">33</span><span class="o">&gt;</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">-1</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="c-arbitrary-precision-integer-explicit-conversions">
<h4><span class="section-number">1.13.3.4. </span>C++ Arbitrary Precision Integer Explicit Conversions<a class="headerlink" href="#c-arbitrary-precision-integer-explicit-conversions" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types support several explicit conversion functions which allow the value to be interpreted in different ways.
The <code class="docutils literal notranslate"><span class="pre">to_uint64()</span></code> function will return a 64 bit <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> with the same bits as the original <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code>, zero extending
and wrapping as necessary. Assigning an <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> wider than 64 bits to an <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">long</span> <span class="pre">long</span></code> would also wrap to match widths,
without needing to call <code class="docutils literal notranslate"><span class="pre">to_uint64()</span></code>. The <code class="docutils literal notranslate"><span class="pre">to_int64()</span></code> function will return a 64 bit <code class="docutils literal notranslate"><span class="pre">signed</span> <span class="pre">long</span> <span class="pre">long</span></code> and will sign extend as necessary.</p>
<p>An arbitrary precision integer data type can be casted to an arbitrary precision fixed-point data type with the <code class="docutils literal notranslate"><span class="pre">to_fixpt&lt;I_W&gt;()</span></code> and <code class="docutils literal notranslate"><span class="pre">to_ufixpt&lt;I_W&gt;()</span></code> functions (returns <code class="docutils literal notranslate"><span class="pre">ap_fixpt&lt;W,</span> <span class="pre">I_W&gt;</span></code> and <code class="docutils literal notranslate"><span class="pre">ap_ufixpt&lt;W,</span> <span class="pre">I_W&gt;</span></code> types respectively), with the same bits as the original <code class="docutils literal notranslate"><span class="pre">ap_[u]int&lt;W&gt;</span></code>.
For more on the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> template, please refer to the <a class="reference internal" href="#fixed-point-library"><span class="std std-ref">C++ Arbitrary Precision Fixed Point Library</span></a> section.</p>
<p>An example demonstrating these functions is shown below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// zero extend 16 bit -32768 to 64 bit 32768</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">A</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">-32768</span><span class="p">).</span><span class="n">to_uint64</span><span class="p">();</span>

<span class="c1">// wrap from 65 bit 2**64 + 1 to 64 bit 1</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">B</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">65</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;10000000000000001&quot;</span><span class="p">).</span><span class="n">to_uint64</span><span class="p">();</span>

<span class="c1">// interpret 8 bit uint as 8 bit ufixpt with four bits above decimal</span>
<span class="c1">// by value 248 becomes 15.5 (== 248 / 2**4)</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">248</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// interpret 4 bit int as 4 bit fixpt with leading bit 8 bits above decimal</span>
<span class="c1">// by value -8 becomes -128 (== -8 * 2**4)</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">D</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">-8</span><span class="p">).</span><span class="n">to_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// interpret 6 bit int as 6 bit ufixpt with 6 bits above decimal</span>
<span class="c1">// by value 8 becomes 8</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">E</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">8</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
</section>
</section>
<section id="c-arbitrary-precision-bit-level-operations">
<h3><span class="section-number">1.13.4. </span>C++ Arbitrary Precision Bit-level Operations<a class="headerlink" href="#c-arbitrary-precision-bit-level-operations" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Library provides utilities to select, and update ranges of arbitrary precision data,
as well as perform concatenation.</p>
<p>Bit selection and updating is defined for all C++ arbitrary precision numeric types. Concatenation is defined on all
C++ Arbitrary Precision Library constructs including arbitrary precision numeric types, as well as bit selections, and other concatenations.</p>
<section id="selecting-and-assigning-to-a-range-of-bits">
<h4><span class="section-number">1.13.4.1. </span>Selecting and Assigning to a Range of Bits<a class="headerlink" href="#selecting-and-assigning-to-a-range-of-bits" title="Permalink to this headline">¶</a></h4>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">(</span><span class="mh">0xBC</span><span class="p">);</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// B initialized as 0xB; &quot;A(7, 4)&quot; is equivalent to &quot;A.range(7, 4)&quot;</span>
<span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span> <span class="n">C</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>    <span class="c1">// C initialized as 0x1</span>
                       <span class="c1">// A[2] is zero extended to match widths</span>
<span class="n">A</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xA</span><span class="p">;</span>         <span class="c1">// A becomes 0xBA; &quot;A(3, 0) is equivalent to &quot;A.range(3, 0)&quot;</span>
</pre></div>
</div>
<p>On C++ arbitrary precision types <code class="docutils literal notranslate"><span class="pre">num(a,</span> <span class="pre">b)</span></code> (or <code class="docutils literal notranslate"><span class="pre">num.range(a,</span> <span class="pre">b)</span></code>) will select and create a reference to the underlying arbitrary precision value.
The operator <code class="docutils literal notranslate"><span class="pre">num[a]</span></code> selects and creates a reference to a single bit.
This reference can be assigned to, and used to access the underlying data.</p>
</section>
<section id="bit-concatenation">
<h4><span class="section-number">1.13.4.2. </span>Bit Concatenation<a class="headerlink" href="#bit-concatenation" title="Permalink to this headline">¶</a></h4>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">A</span><span class="p">(</span><span class="mh">0xA</span><span class="p">);</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>  <span class="n">B</span><span class="p">(</span><span class="mh">0xCB</span><span class="p">);</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span>  <span class="n">AB</span><span class="p">(</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="p">);</span>                   <span class="c1">// AB initialized as 0xAB</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">ABC</span><span class="p">(</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0xB</span><span class="p">),</span> <span class="n">B</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span> <span class="p">);</span> <span class="c1">// ABC initialized as 0xABC</span>
</pre></div>
</div>
<p>Putting any C++ arbitrary precision types in a comma separated list will generate a concatenation.
The concatenation can currently be used to create arbitrary precision types (zero extending or truncating to match widths), but can not be assigned to.</p>
</section>
</section>
<section id="c-arbitrary-precision-fixed-point-library">
<span id="fixed-point-library"></span><h3><span class="section-number">1.13.5. </span>C++ Arbitrary Precision Fixed Point Library<a class="headerlink" href="#c-arbitrary-precision-fixed-point-library" title="Permalink to this headline">¶</a></h3>
<p>The C++ Arbitrary Precision Fixed Point library provides fast bit accurate software simulation, and efficient equivalent
hardware generation. The C++ <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types allow specifying signed and unsigned fixed point numbers of arbitrary width,
and arbitrary fixed position relative to the decimal. They can be used
for arithmetic, concatenation, and bit level operations. You can use the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> type by including the
following header file.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> template allows specifying the width of the type, how far the most significant bit is above the decimal,
as well as several quantization and overflow modes.</p>
<p>Quantization and overflow handling is triggered during assignment and construction.
The policies used for quantization and overflow are based on the quantization and overflow modes of the
left hand side of an assignment, or of the value being constructed.</p>
<p>The template <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt&lt;W,</span> <span class="pre">I_W,</span> <span class="pre">Q_M,</span> <span class="pre">O_M&gt;</span></code> is described in the following table. The last two template parameters are optional.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 23%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head" colspan="2"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>W</p></td>
<td colspan="2"><p>The width of the word in bits.</p></td>
</tr>
<tr class="row-odd"><td><p>I_W</p></td>
<td colspan="2"><p>How far the most significant bit is above the decimal. I_W
can be negative. I_W &gt; 0 implies the MSB is above the
decimal. I_W &lt;= 0 implies the MSB is below the decimal.</p>
<p>If W &gt;= I_W &gt;= 0 then I_W is the number of bits used for
the integer portion.</p>
</td>
</tr>
<tr class="row-even"><td rowspan="8"><p>Q_M</p></td>
<td colspan="2"><p>The Quantization (rounding) mode used when a result has
precision below the least significant bit.</p>
<p>Defaults to AP_TRN.</p>
</td>
</tr>
<tr class="row-odd"><td><p>AP_TRN</p></td>
<td><p>Truncate bits below the LSB bringing the
result closer to -∞.</p></td>
</tr>
<tr class="row-even"><td><p>AP_TRN_ZERO</p></td>
<td><p>Truncate bits below the LSB bringing the
result closer to zero.</p></td>
</tr>
<tr class="row-odd"><td><p>AP_RND</p></td>
<td><p>Round to the nearest representable value
with the midpoint going towards +∞.</p></td>
</tr>
<tr class="row-even"><td><p>AP_RND_INF</p></td>
<td><p>Round to the nearest representable value
with the midpoint going towards -∞ for
negative numbers, and +∞ for positive
numbers.</p></td>
</tr>
<tr class="row-odd"><td><p>AP_RND_MIN_INF</p></td>
<td><p>Round to the nearest representable value
with the midpoint going towards -∞.</p></td>
</tr>
<tr class="row-even"><td><p>AP_RND_ZERO</p></td>
<td><p>Round to the nearest representable value
with the midpoint going towards 0.</p></td>
</tr>
<tr class="row-odd"><td><p>AP_RND_CONV</p></td>
<td><p>Round to the nearest representable value
with the midpoint going towards the
nearest even multiple of the quantum.
(This helps to remove bias in rounding).</p></td>
</tr>
<tr class="row-even"><td rowspan="5"><p>O_M</p></td>
<td colspan="2"><p>The Overflow mode used when a result exceeds the maximum or
minimum representable value.</p>
<p>Defaults to AP_WRAP.</p>
</td>
</tr>
<tr class="row-odd"><td><p>AP_WRAP</p></td>
<td><p>Wraparound between the minimum and maximum
representable values in the range.</p></td>
</tr>
<tr class="row-even"><td><p>AP_SAT</p></td>
<td><p>On positive and negative overflow saturate
the result to the maximum or minimum value
in the range respectively.</p></td>
</tr>
<tr class="row-odd"><td><p>AP_SAT_ZERO</p></td>
<td><p>On any overflow set the result to zero.</p></td>
</tr>
<tr class="row-even"><td><p>AP_SAT_SYM</p></td>
<td><p>On positive and negative overflow saturate
the result to the maximum or minimum value
in the range symmetrically about zero.</p>
<p>For ap_ufixpt this is the same as AP_SAT.</p>
</td>
</tr>
</tbody>
</table>
<p>An <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> is a W bit wide integer, in 2’s complement for the signed case, which
has some fixed position relative to the decimal. This means that arithmetic is efficiently
implemented as integer operations with some shifting to line up decimals. Generally a
fixed point number can be thought of as a signed or unsigned integer word multiplied by 2^(I_W - W).
The range of values that an <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> can take on, as well as the quantum that
separates those values is determined by the W, and I_W template parameters. The AP_SAT_SYM
overflow mode forces the range to be symmetrical about zero for signed fixed point types.
This information is described in the following table. Q here represents the quantum.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 25%" />
<col style="width: 30%" />
<col style="width: 32%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Type</p></td>
<td><p>Quantum</p></td>
<td><p>Range</p></td>
<td><p>AP_SAT_SYM Range</p></td>
</tr>
<tr class="row-even"><td><p>ap_ufixpt</p></td>
<td><p>2^(I_W - W)</p></td>
<td><p>0</p>
<p>to</p>
<p>2^(I_W) - Q</p>
</td>
<td><p>0</p>
<p>to</p>
<p>2^(I_W) - Q</p>
</td>
</tr>
<tr class="row-odd"><td><p>ap_fixpt</p></td>
<td><p>2^(I_W - W)</p></td>
<td><p>-2^(I_W - 1)</p>
<p>to</p>
<p>2^(I_W - 1) - Q</p>
</td>
<td><p>-2^(I_W - 1) + Q</p>
<p>to</p>
<p>2^(I_W - 1) - Q</p>
</td>
</tr>
</tbody>
</table>
<p>Some <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> ranges are demonstrated in the following table.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 28%" />
<col style="width: 34%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Type</p></td>
<td><p>Quantum</p></td>
<td><p>Range</p></td>
</tr>
<tr class="row-even"><td><p>ap_fixpt&lt;8, 4&gt;</p></td>
<td><p>0.0625</p></td>
<td><p>-8 to 7.9375</p></td>
</tr>
<tr class="row-odd"><td><p>ap_ufixpt&lt;4, 12&gt;</p></td>
<td><p>256</p></td>
<td><p>0 to 3840</p></td>
</tr>
<tr class="row-even"><td><p>ap_ufixpt&lt;4, -2&gt;</p></td>
<td><p>0.015625</p></td>
<td><p>0 to 0.234375</p></td>
</tr>
</tbody>
</table>
<p>An example using <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> is show below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/streaming.hpp&quot;</span><span class="cp"></span>

<span class="cp">#define TAPS 8</span>

<span class="c1">// A signed fixed point type with 10 integer bits and 6 fractional bits</span>
<span class="c1">// It employs convergent rounding for quantization, and saturation for overflow.</span>
<span class="k">typedef</span> <span class="n">hls</span><span class="o">::</span><span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">AP_RND_CONV</span><span class="p">,</span> <span class="n">hls</span><span class="o">::</span><span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">fixpt_t</span><span class="p">;</span>

<span class="c1">// A signed fixed point type with 3 integer bits and 1 fractional bit</span>
<span class="c1">// It uses the default truncation, and wrapping modes.</span>
<span class="k">typedef</span> <span class="n">hls</span><span class="o">::</span><span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span> <span class="n">fixpt_s_t</span><span class="p">;</span>

<span class="c1">// This function is marked function_pipeline in the config</span>
<span class="kt">void</span> <span class="nf">fir</span><span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">fixpt_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">input_fifo</span><span class="p">,</span>
         <span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">fixpt_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">output_fifo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fixpt_t</span> <span class="n">in</span> <span class="o">=</span> <span class="n">input_fifo</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>

    <span class="k">static</span> <span class="n">fixpt_t</span> <span class="n">previous</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">const</span> <span class="n">fixpt_s_t</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">TAPS</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">-2</span><span class="p">,</span> <span class="mf">-1.5</span><span class="p">,</span> <span class="mi">-1</span><span class="p">,</span> <span class="mf">-0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">TAPS</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="n">previous</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">in</span><span class="p">;</span>

    <span class="n">fixpt_t</span> <span class="n">accumulate</span><span class="p">[</span><span class="n">TAPS</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">TAPS</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">accumulate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">previous</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">coefficients</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// Accumulate results, doing adds and saturation in</span>
    <span class="c1">// a binary tree to reduce the number of serial saturation</span>
    <span class="c1">// checks. This significantly improves pipelining results</span>
    <span class="c1">// over serially adding results together when saturation</span>
    <span class="c1">// is required.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">TAPS</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">accumulate</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">accumulate</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">output_fifo</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">accumulate</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This example implements a streaming FIR filter with 8 taps. Using the minimum width <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> to represent
the constant coefficients allows the multiply to happen at a smaller width than if they were the same (wider)
type as the inputs. This example ensures that no overflows occur by always assigning to an <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> that uses the AP_SAT
overflow mode. This does incur a performance penalty, but this is minimized here by accumulating the results in a binary
fashion, such that there are only log(TAPS) = 3 saturating operations that depend on each other. If the results were
accumulated in a single variable in one loop then there would be TAPS = 8 saturating operations depending on each other.
Having more saturating operations in a row is slower because at each step overflow needs to be checked before the next
operation can occur.</p>
<section id="printing-ap-u-fixpt-types">
<h4><span class="section-number">1.13.5.1. </span>Printing ap_[u]fixpt Types<a class="headerlink" href="#printing-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The Arbitrary Precision Fixed Point Library provides some utilities for printing <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types in software, demonstrated below.
The <code class="docutils literal notranslate"><span class="pre">to_fixpt_string(base,</span> <span class="pre">signedness)</span></code> function takes an optional base argument which is one of 2, 10, or 16, and defaults to 10,
as well as an optional signedness argument which determines if the data should be treated as signed or unsigned. The signedness argument defaults to false
for ap_ufixpt, and true for ap_fixpt.</p>
<p>The output stream operator <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> can be used to put a fixed point number into an output stream
as if it were called with the default <code class="docutils literal notranslate"><span class="pre">to_fixpt_string</span></code> arguments.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">to_double()</span></code> function can be useful for printing, but it can lose precision over a wide fixed point. It can be used
in hardware, but this is expensive, and should be avoided when possible.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed</span> <span class="o">=</span> <span class="mf">12.75</span><span class="p">;</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">s_fixed</span><span class="p">(</span><span class="s">&quot;CC&quot;</span><span class="p">);</span>

<span class="c1">// prints: -52 * 2^-4</span>
<span class="c1">// Read -52 * 0.0625 = -3.25</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s_fixed</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// prints: 11001100 * 2^-4</span>
<span class="c1">// Read unsigned 11001100 * 2^-4 = 204 * 0.0625</span>
<span class="c1">// = 12.75</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fixed</span><span class="p">.</span><span class="n">to_fixpt_string</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">c_str</span><span class="p">());</span>

<span class="c1">// prints: CC * 2^-4</span>
<span class="c1">// Read signed CC * 2^-4 = -52 * 0.0625</span>
<span class="c1">// = -3.25</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s_fixed</span><span class="p">.</span><span class="n">to_fixpt_string</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

<span class="c1">// prints: -3.25</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%.2f</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">s_fixed</span><span class="p">.</span><span class="n">to_double</span><span class="p">());</span>
</pre></div>
</div>
</section>
<section id="initializing-ap-u-fixpt-types">
<h4><span class="section-number">1.13.5.2. </span>Initializing ap_[u]fixpt Types<a class="headerlink" href="#initializing-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types can be constructed and assigned from other fixed points, the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types, C++ integer and floating
point types, as well as concatenations and bit selections. They can also be initialized from a hexadecimal string describing the exact
bits. Note that construction and assignment will always trigger the quantization and overflow handling of the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> being constructed or assigned to,
except when copying from the exact same type, or initializing from a hexadecimal string. For logical assignments of bits, bit selection assignments can be used, as well as
the <code class="docutils literal notranslate"><span class="pre">from_raw_bits</span></code> function, or the <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> <code class="docutils literal notranslate"><span class="pre">to_fixpt&lt;I_W&gt;()</span></code> functions in the case of <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Initializing <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types from floating point types in hardware is expensive, and should be avoided when possible. However, initializing
<code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> from floating point literals is free, and happens at compile time.</p>
</div>
<p>Some examples of initializing fixed point types are shown in the following code snippet.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;hls/ap_int.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="c1">// Initialized to -13.75</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed1</span> <span class="o">=</span> <span class="mf">-13.75</span><span class="p">;</span>

<span class="c1">// Initialized to 135</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">fixed2</span> <span class="o">=</span> <span class="mi">135</span><span class="p">;</span>

<span class="c1">// Initialized to -112</span>
<span class="c1">// Could also write &quot;0x9&quot;</span>
<span class="c1">// 0x is optional</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">fixed3</span><span class="p">(</span><span class="s">&quot;9&quot;</span><span class="p">);</span>

<span class="c1">// Initialized to 14</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed4</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">14</span><span class="p">);</span>

<span class="c1">// Initialized to -1 (AP_SAT triggered)</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">AP_TRN</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">fixed5</span> <span class="o">=</span> <span class="mi">-4</span><span class="p">;</span>

<span class="c1">// Initialized to 1.5 (AP_RND triggered)</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">AP_RND</span><span class="o">&gt;</span> <span class="n">fixed6</span> <span class="o">=</span> <span class="mf">1.25</span><span class="p">;</span>

<span class="c1">// Initialized to 15.75 from a logical string of bits</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed7</span><span class="p">;</span>
<span class="n">fixed7</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;FC&quot;</span><span class="p">);</span>

<span class="c1">// Assign an existing ap_uint variable to an ap_ufixpt variable</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">fixed8</span><span class="p">;</span>
<span class="n">fixed8</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ap_uint_var</span><span class="p">;</span>

<span class="c1">// Initialize to 13 from a logical string of bits</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">fixed9</span><span class="p">;</span>
<span class="n">fixed9</span><span class="p">.</span><span class="n">from_raw_bits</span><span class="p">(</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">26</span><span class="p">));</span>

<span class="c1">// Initialize to -32 from a logical string of bits</span>
<span class="c1">// (First convert ap_uint&lt;4&gt; to ap_fixpt&lt;4, 6&gt; logically,</span>
<span class="c1">// then perform fixed point assignment)</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">fixed10</span> <span class="o">=</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">).</span><span class="n">to_fixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>

<span class="c1">// Initialize to 32 from a logical string of bits</span>
<span class="c1">// (First convert ap_int&lt;4&gt; to ap_ufixpt&lt;4, 6&gt; logically,</span>
<span class="c1">// then perform fixed point assignment)</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="o">&gt;</span> <span class="n">fixed11</span> <span class="o">=</span> <span class="n">ap_int</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;8&quot;</span><span class="p">).</span><span class="n">to_ufixpt</span><span class="o">&lt;</span><span class="mi">6</span><span class="o">&gt;</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="arithmetic-with-ap-u-fixpt-types">
<h4><span class="section-number">1.13.5.3. </span>Arithmetic With ap_[u]fixpt Types<a class="headerlink" href="#arithmetic-with-ap-u-fixpt-types" title="Permalink to this headline">¶</a></h4>
<p>The Arbitrary Precision Fixed Point library supports all standard arithmetic, logical bitwise, shifts, and comparison
operations. During arithmetic intermediate results are kept in a wide enough type to hold all of the possible resulting values. Operands
are shifted to line up decimal points, and sign or zero extended to match widths before an operation is performed. For fixed
point arithmetic, whenever the result of a calculation can be negative the intermediate type is an <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> instead of <code class="docutils literal notranslate"><span class="pre">ap_ufixpt</span></code>
regardless of whether any of the operands were ap_fixpt.
Overflow and quantization handling only happen when the result is assigned to a fixed point type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Overflow and quantization handling is not performed for any assigning shifting operations (&lt;&lt;=, &gt;&gt;=) on <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types.
Also, non-assigning shifts (&lt;&lt;, &gt;&gt;, .ashr(x)) do not change the width or type of the fixed point they are applied to. This means that bits can be shifted out of
range.</p>
</div>
<p>Fixed point types can be mixed freely with other arbitrary precision and c++ numeric types for arithmetic, logical bitwise, and comparison operations,
with some caveats for floating point types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For arithmetic and logical bitwise operations floating point types <strong>must</strong> be explicitly cast to an <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> type before
being used, because of the wide range of possible values the floating point type could represent. It is also a good idea, but not required, to
use <code class="docutils literal notranslate"><span class="pre">ap_[u]int</span></code> types in place of C++ integers when less width is required.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For convenience floating point types can be used directly in fixed point comparisons, however floating points are truncated
and wrapped as if they were assigned to a signed <code class="docutils literal notranslate"><span class="pre">ap_fixpt</span></code> just big enough to hold all values of the <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code>
type being compared against, with the AP_TRN and AP_WRAP modes on.</p>
</div>
<p>An example demonstrating some of this behaviour is show below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">65</span><span class="p">,</span> <span class="mi">14</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="mf">32.5714285713620483875274658203125</span><span class="p">;</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="o">&gt;</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">c</span> <span class="o">=</span> <span class="mf">-3.125</span><span class="p">;</span>

<span class="c1">// the resulting type is wide enough to hold all</span>
<span class="c1">// 51 fractional bits of a, and 15 integer bits of b</span>
<span class="c1">// the width, and integer width are increased by 1 to hold</span>
<span class="c1">// all possible results of the addition</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">67</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// 39.5714285713620483875274658203125</span>

<span class="c1">// the resulting type is a signed fixed point</span>
<span class="c1">// with width, and integer width that are the sum</span>
<span class="c1">// of the two operands&#39; widths</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">23</span><span class="p">,</span> <span class="mi">19</span><span class="o">&gt;</span> <span class="n">e</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// -21.875</span>

<span class="c1">// Assignment triggers the AP_TRN_ZERO quantization mode</span>
<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">AP_TRN_ZERO</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span> <span class="c1">// -21.5</span>

<span class="c1">// Mask out bits above the decimal</span>
<span class="n">f</span> <span class="o">&amp;=</span> <span class="mh">0xFF</span><span class="p">;</span> <span class="c1">// -22</span>

<span class="c1">// Assignment triggers the AP_SAT overflow mode,</span>
<span class="c1">// and saturates the negative result to 0</span>
<span class="n">ap_ufixpt</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">AP_TRN</span><span class="p">,</span> <span class="n">AP_SAT</span><span class="o">&gt;</span> <span class="n">g</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="n">d</span><span class="p">;</span> <span class="c1">// 0</span>
</pre></div>
</div>
</section>
<section id="explicit-conversions-of-ap-u-fixpt">
<h4><span class="section-number">1.13.5.4. </span>Explicit Conversions of ap_[u]fixpt<a class="headerlink" href="#explicit-conversions-of-ap-u-fixpt" title="Permalink to this headline">¶</a></h4>
<p>There are several functions to explicitly convert <code class="docutils literal notranslate"><span class="pre">ap_[u]fixpt</span></code> types into other types, besides value based assignments. The <code class="docutils literal notranslate"><span class="pre">raw_bits</span></code> function produces a uint of
the same width as the ap_[u]fixpt with the same raw data, and to_double returns a double representing the value of the ap_[u]fixpt. Note that
for wide enough ap_[u]fixpt to_double can lose precision, and can be inefficient in hardware. These are demonstrated in the
following code snippet.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/ap_fixpt.hpp&quot;</span><span class="cp"></span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="p">...</span>

<span class="n">ap_fixpt</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">fixed</span><span class="p">(</span><span class="s">&quot;898&quot;</span><span class="p">);</span>

<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">12</span><span class="o">&gt;</span> <span class="n">logical_fixed</span> <span class="o">=</span> <span class="n">fixed</span><span class="p">.</span><span class="n">raw_bits</span><span class="p">();</span>
<span class="n">logical_fixed</span> <span class="o">==</span> <span class="mh">0x898</span><span class="p">;</span> <span class="c1">// true</span>

<span class="kt">double</span> <span class="n">double_fixed</span> <span class="o">=</span> <span class="n">fixed</span><span class="p">.</span><span class="n">to_double</span><span class="p">();</span>
<span class="n">double_fixed</span> <span class="o">==</span> <span class="mf">-14.8125</span><span class="p">;</span> <span class="c1">// true</span>
</pre></div>
</div>
</section>
</section>
<section id="supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point">
<h3><span class="section-number">1.13.6. </span>Supported Operations in ap_[u]int, ap_[u]fixpt, and floating-point<a class="headerlink" href="#supported-operations-in-ap-u-int-ap-u-fixpt-and-floating-point" title="Permalink to this headline">¶</a></h3>
<p>The table below shows all the standard arithmetic operations that are supported in
our Arbitrary Precision Integer and Fixed Point Libraries as well as for
floating-point data types. It also shows some useful APIs that can be used to
convert from one type to another or to convert to standard integral types or strings.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 13%" />
<col style="width: 28%" />
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 15%" />
<col style="width: 12%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p>Type</p></td>
<td><p>Operator</p></td>
<td><p>Description</p></td>
<td><p>ap_[u]int</p></td>
<td><p>ap_[u]fixpt</p></td>
<td><p>floating</p></td>
</tr>
<tr class="row-even"><td rowspan="7"><p>Arithmetic</p></td>
<td><p>+</p></td>
<td><p>Addition</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>-</p></td>
<td><p>Subtraction</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>*</p></td>
<td><p>Multiplication</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>/</p></td>
<td><p>Division</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>%</p></td>
<td><p>Modulo</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Note Below</p></td>
</tr>
<tr class="row-odd"><td><p>++</p></td>
<td><p>Increment</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>--</p></td>
<td><p>Decrement</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td rowspan="11"><p>Assignment</p></td>
<td><p>=</p></td>
<td><p>Assignment</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>+=</p></td>
<td><p>Add and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>-=</p></td>
<td><p>Sub and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>*=</p></td>
<td><p>Mult and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>/=</p></td>
<td><p>Div and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>%=</p></td>
<td><p>Mod and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Note Below</p></td>
</tr>
<tr class="row-odd"><td><p>&amp;=</p></td>
<td><p>bitwise AND
and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>|=</p></td>
<td><p>Bitwise OR
and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>^=</p></td>
<td><p>Bitwise XOR
and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>&gt;&gt;=</p></td>
<td><p>SHR and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;&lt;=</p></td>
<td><p>SHL and assign</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td rowspan="6"><p>Comparison</p></td>
<td><p>==</p></td>
<td><p>Equal to</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>!=</p></td>
<td><p>Not equal to</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>&gt;</p></td>
<td><p>Greater than</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;</p></td>
<td><p>Less than</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td><p>&gt;=</p></td>
<td><p>Greater than
or equal to</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-odd"><td><p>&lt;=</p></td>
<td><p>Less than
or equal to</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
</tr>
<tr class="row-even"><td rowspan="5"><p>Bitwise</p></td>
<td><p>&amp;</p></td>
<td><p>Bitwise AND</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>^</p></td>
<td><p>Bitwise XOR</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>|</p></td>
<td><p>Bitwise OR</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>~</p></td>
<td><p>Bitwise Not</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>.or_reduce()</p></td>
<td><p>Bitwise OR
reduction</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td rowspan="3"><p>Shift</p></td>
<td><p>&lt;&lt;</p></td>
<td><p>Shift left</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>&gt;&gt;</p></td>
<td><p>Shift right</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>.ashr(ap_uint numbits)</p></td>
<td><p>Arithmetic
shift right</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td rowspan="4"><p>Bit level
access</p></td>
<td><p>num(a, b)</p></td>
<td><p>Range
selection</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>num.range(a, b)</p></td>
<td><p>Range
selection</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>num[a]</p></td>
<td><p>Bit
selection</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>(numa, numb, numc)</p></td>
<td><p>Concat</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td rowspan="7"><p>Explicit
Conversion</p></td>
<td><p>.to_ufixpt()</p></td>
<td><p>Convert to
ap_ufixpt</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>.to_fixpt()</p></td>
<td><p>Convert to
ap_fixt</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>.to_uint64()</p></td>
<td><p>Convert to
uint64</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>.to_int64()</p></td>
<td><p>Convert to
int64</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>.raw_bits()</p></td>
<td><p>Convert to
raw bits</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td><p>.from_raw_bits()</p></td>
<td><p>Convert from
raw bits</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>.to_double()</p></td>
<td><p>Convert to
double</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>String
Conversion</p></td>
<td><p>.to_fixpt_string()</p></td>
<td><p>Convert to
fixpt string</p></td>
<td><p>N/A</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
<tr class="row-even"><td><p>.to_string()</p></td>
<td><p>Convert to
int string</p></td>
<td><p>Y</p></td>
<td><p>Y</p></td>
<td><p>N/A</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To use floating point remainder, call the <code class="docutils literal notranslate"><span class="pre">fmod</span></code> or <code class="docutils literal notranslate"><span class="pre">fmodf</span></code> function from the &lt;math.h&gt; header.</p>
<p>Note that the floating-point remainder core can be very large when used in a pipeline, so it should be
used with care. For the same reason, floating point remainder is only directly supported for
the float type. For double, the inputs to the core will be cast down to float,
and the result will be cast back to double. This can result in a loss of precision,
or incorrect results when the double input is not representable in the range of float.</p>
</div>
</section>
<section id="image-processing-library">
<h3><span class="section-number">1.13.7. </span>Image Processing Library<a class="headerlink" href="#image-processing-library" title="Permalink to this headline">¶</a></h3>
<p>The SmartHLS image processing library provides C++ class/function APIs for a
number of commonly used image processing operations.
You can use these class/function APIs by including the following header file,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;hls/image_processing.hpp&quot;</span><span class="cp"></span>
</pre></div>
</div>
<section id="line-buffer">
<span id="line-buffer-user-guide"></span><h4><span class="section-number">1.13.7.1. </span>Line Buffer<a class="headerlink" href="#line-buffer" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class implements the line buffer structure that is commonly
seen in image convolution (filtering) operations, where a filter kernel is
“slided” over an input image and is applied on a local window (e.g., a square)
of pixels at every sliding location.  As the filter is slided across the image,
the line buffer is fed with a new pixel at every new sliding location while
retaining the pixels of the previous image rows that can be covered for the
sliding window.
The public interface of the <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class is shown below,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">PixelType</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ImageWidth</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">WindowSize</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">LineBuffer</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">PixelType</span> <span class="n">window</span><span class="p">[</span><span class="n">WindowSize</span><span class="p">][</span><span class="n">WindowSize</span><span class="p">];</span>
    <span class="kt">void</span> <span class="nf">ShiftInPixel</span><span class="p">(</span><span class="n">PixelType</span> <span class="n">input_pixel</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Below shows an example usage of the LineBuffer class:</p>
<ul class="simple">
<li><p>Instantiate the line buffer in your C++ code, with template
arguments being the pixel data type, input image width, and sliding window
size.  The window maintained by the line buffer assumes a square
<code class="docutils literal notranslate"><span class="pre">WindowSize</span> <span class="pre">x</span> <span class="pre">WindowSize</span></code> window.  If you are instantiating the line buffer
inside a pipelined function (accepting a new pixel in every function call),
you will need to add ‘static’ to make the line buffer static.</p></li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">hls</span><span class="o">::</span><span class="n">LineBuffer</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">,</span> <span class="n">ImageWidth</span><span class="p">,</span> <span class="n">WindowSize</span><span class="o">&gt;</span> <span class="n">line_buffer</span><span class="p">;</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Shift in a new pixel by calling the <code class="docutils literal notranslate"><span class="pre">ShiftInPixel</span></code> method:</p></li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">line_buffer</span><span class="p">.</span><span class="n">ShiftInPixel</span><span class="p">(</span><span class="n">input_pixel</span><span class="p">);</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Then your filter can access any pixels in the <code class="docutils literal notranslate"><span class="pre">window</span></code> by:</p></li>
</ul>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="n">line_buffer</span><span class="p">.</span><span class="n">window</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>The figure below illustrates how the line buffer <code class="docutils literal notranslate"><span class="pre">window</span></code> is being updated
after each call of <code class="docutils literal notranslate"><span class="pre">ShiftInPixel</span></code>.  You will notice that the <cite>window</cite> can
contain out-of-bound pixels at certain sliding locations.</p>
<a class="reference internal image-reference" href="_images/LineBufferClass.png"><img alt="_images/LineBufferClass.png" class="align-center" src="_images/LineBufferClass.png" style="width: 765.0px; height: 1044.0px;" /></a>
<p>For more details about when/why to use the <code class="docutils literal notranslate"><span class="pre">LineBuffer</span></code> class, see
<a class="reference internal" href="optimizationguide.html#line-buffer-opt-guide"><span class="std std-ref">Inferring a Line Buffer</span></a> in the <a class="reference internal" href="optimizationguide.html#optimizationguide"><span class="std std-ref">Optimization Guide</span></a>.</p>
</section>
</section>
<section id="c-numerics-library-math-h-in-c-cmath-in-c">
<span id="c-numerics-library"></span><h3><span class="section-number">1.13.8. </span>C Numerics Library (math.h in C / &lt;cmath&gt; in C++)<a class="headerlink" href="#c-numerics-library-math-h-in-c-cmath-in-c" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS supports a subset of the C Numerics Library. These functions are supported for functionality, however, may not lead to an efficient hardware implementation.
If you require high performance, we recommend restructuring your software code to not call these math functions.
The table below shows supported math functions.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 21%" />
<col style="width: 63%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Function Types</p></th>
<th class="head"><p>Function Names</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="2"><p>Trigonometric functions</p></td>
<td><p>cos, cosf, sin, sinf, tan, tanf, acos, acosf, asin, asinf, atan, atanf, atan2</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p>Hyperbolic functions</p></td>
<td><p>cosh, coshf, sinh, sinhf, tanh, tanhf, acosh, acoshf, asinh, asinhf, atanh, atanhf</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>Exponential and logarithmic functions</p></td>
<td><p>exp, expf, frexp, log, logf, log10, modf, exp2, expm1, ilogb, log1p, log2, logb, scalbn, scalbln</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p>Power functions</p></td>
<td><p>pow, powf, sqrt, hypot, cbrt</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>Error and gamma functions</p></td>
<td><p>erf, erfc, tgamma</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p>Rounding and remainder functions</p></td>
<td><p>ceil, floor, fmod, fmodf, trunc, round, lround, llround, rint, lrint, llrint, nearbyint, remainder, remquo</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>Floating-point manipulation functions</p></td>
<td><p>copysign, nan, nextafter</p></td>
</tr>
<tr class="row-odd"><td colspan="2"><p>Minimum, maximum, difference functions</p></td>
<td><p>fdim, fmax, fmin</p></td>
</tr>
<tr class="row-even"><td colspan="2"><p>Other functions</p></td>
<td><p>fabs, fabsf, fma</p></td>
</tr>
<tr class="row-odd"><td rowspan="2"><p>Implemented as macros in C
and as functions in C++</p></td>
<td><p>Classification macros or functions</p></td>
<td><p>isinf, isnan</p></td>
</tr>
<tr class="row-even"><td><p>Comparison macros or functions</p></td>
<td><p>isgreater, isgreaterequal, isless, islessequal, islessgreater</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="top-level-rtl-interface">
<span id="rtl-interface"></span><h2><span class="section-number">1.14. </span>Top-Level RTL Interface<a class="headerlink" href="#top-level-rtl-interface" title="Permalink to this headline">¶</a></h2>
<p>The SmartHLS-generated top-level RTL module can be instantiated and integrated with other HDL blocks, by following the protocols used by the SmartHLS’s
RTL interface.
This section describes the types of interfaces that are supported by SmartHLS, the
default interface for each data type in C/C++, and how to customize the
interface.</p>
<section id="module-control-interface">
<h3><span class="section-number">1.14.1. </span>Module Control Interface<a class="headerlink" href="#module-control-interface" title="Permalink to this headline">¶</a></h3>
<p>The top-level Verilog module generated by SmartHLS is always associated with a
module control interface.  The table below shows the interface ports of the
control interface.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 81%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Port Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>clock</cite></p></td>
<td><p>IN</p></td>
<td><p>The input clock signal to the RTL module.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>reset</cite></p></td>
<td><p>IN</p></td>
<td><p>The input reset signal to the RTL module.</p></td>
</tr>
<tr class="row-even"><td><p><cite>ready</cite></p></td>
<td><p>OUT</p></td>
<td><p>Indicates the readiness of the RTL module.
<cite>ready</cite> is set to 1 when the RTL module is ready to start a new iteration (invocation) with a new set
of inputs.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>start</cite></p></td>
<td><p>IN</p></td>
<td><p>When <cite>ready</cite> is 1, setting <cite>start</cite> to 1 will start the execution of the RTL module;
When <cite>ready</cite> is 0, the <cite>start</cite> signal is ignored by the RTL module.</p></td>
</tr>
<tr class="row-even"><td><p><cite>finish</cite></p></td>
<td><p>OUT</p></td>
<td><p><cite>finish</cite> is set to 1 for one clock cycle when the RTL module finishes.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>return_val</cite></p></td>
<td><p>OUT</p></td>
<td><p>Holds the valid return value when <cite>finish</cite> is asserted.
This signal does not exist if the top-level function has a void return type.</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>The top-level module starts a new iteration of execution upon the
handshaking when both <cite>ready</cite> and <cite>start</cite> are high at a positive edge
clock.</p></li>
<li><p>For a circuit containing pipelined functions, the <cite>ready</cite> signal can be
high before the previous invocations have finished, allowing multiple
invocations to overlap and run in parallel.</p></li>
<li><p>For circuits without pipelined functions, the <cite>ready</cite> signal is only
asserted when the last invocation has finish.</p></li>
<li><p>The scalar arguments (described in the next section) should be provided at
the same time when the <cite>start</cite> signal is set to high.</p></li>
</ul>
</div>
<section id="timing-diagram-no-pipeline-functions">
<h4><span class="section-number">1.14.1.1. </span>Timing Diagram (No Pipeline Functions)<a class="headerlink" href="#timing-diagram-no-pipeline-functions" title="Permalink to this headline">¶</a></h4>
<img alt="_images/control_intf.png" class="align-center" src="_images/control_intf.png" />
<p>The timing diagram above illustrates the behaviour of the module control
interface when the generated circuit contains no pipelined circuits.</p>
<ul class="simple">
<li><p>First, the <cite>ready</cite> signal comes out high after reset (label 0).</p></li>
<li><p>When the <cite>start</cite> signal becomes high at the next cycle (label a), the
handshaking between <cite>ready</cite> and <cite>start</cite> (label 1 &amp; a) occurs and the
top-level module starts running.</p>
<ul>
<li><p>Notice that at the same time as the <cite>start</cite> signal is asserted (label a),
the argument inputs (i.e., <cite>arg_X</cite> and <cite>arg_Y</cite>) should also be provided to
the top-level module.  The scalar argument inputs are sampled by the
top-level module when the handshaking occurs and will be used as the input
for the current invocation.</p></li>
</ul>
</li>
<li><p>Then the <cite>ready</cite> signal goes to low at the next cycle (label 2) to indicate
the top-level module cannot accept a new invocation.</p></li>
<li><p>When the <cite>ready</cite> signal is low, the <cite>start</cite> signal is ignored by the
top-level module.
For example, the <cite>start</cite> signal becomes high at label b. The <cite>ready</cite> signal
from the top-level module is still low at this cycle and hence a new function
invocation won’t be started yet.</p></li>
<li><p>At label x, when the previous invocation finishes, the top-level module sets
<cite>finish</cite> signal high for one clock cycle. In this clock cycle, the return
value of the top-level function is available on the <cite>return_val</cite> port.</p></li>
<li><p>Meanwhile, the <cite>ready</cite> signal becomes high as the previous invocation
finishes (label 3). A new handshaking with <cite>start</cite> occurs (label 3 &amp; c), then
the top-level function starts the second invocation and finishes at label y.</p></li>
</ul>
</section>
<section id="timing-diagram-pipeline-functions">
<h4><span class="section-number">1.14.1.2. </span>Timing Diagram (Pipeline Functions)<a class="headerlink" href="#timing-diagram-pipeline-functions" title="Permalink to this headline">¶</a></h4>
<img alt="_images/control_intf_func_pipeline.png" class="align-center" src="_images/control_intf_func_pipeline.png" />
<p>The timing diagram above illustrates the module control interface when the
generated circuit contains pipelined function(s).  In this case, the SmartHLS
circuit can overlap the execution of multiple invocations, by starting a new
invocation with a new set of inputs before previous invocations have finished.</p>
<ul class="simple">
<li><p>There are a total of five invocations (or five <cite>ready</cite> &amp; <cite>start</cite>
handshakings, label 0-4 &amp; a-e). As shown in the diagram, the new invocations
can start without waiting for the prior invocations to finish.</p></li>
<li><p>Although the SmartHLS circuit can process multiple invocations in parallel,
there are times when the SmartHLS circuit cannot start a new invocation.
Such case can happen when the pipeline initiation internal is not 1 (i.e.,
the SmartHLS circuit cannot start a new invocation every clock cycle),
or when the circuit is stalled waiting for resource/data to become available
(e.g., waiting to read from an input FIFO).
When the SmartHLS circuit can not start a new invocation, the <cite>ready</cite> signal
will be set to low.</p>
<ul>
<li><p>For example, the <cite>ready</cite> signal is low for one cycle before label 2,
postponing the start of the third invocation until the <cite>ready</cite> signal is
back to high at label 2 &amp; c.</p></li>
</ul>
</li>
<li><p>The external logic of the SmartHLS circuit can also lower the <cite>start</cite> signal to
delay the start of a new invocation, as shown in the cycle before label d.</p></li>
<li><p>The invocations are always finished in the same order as they started.
That is, the handshakings at label 0 &amp; a, 1 &amp; b, 2 &amp; c, 3 &amp; d, 4 &amp; e,
are corresponding to the completion at label o, p, q, r, s, respectively.</p></li>
</ul>
</section>
</section>
<section id="scalar-argument">
<h3><span class="section-number">1.14.2. </span>Scalar Argument<a class="headerlink" href="#scalar-argument" title="Permalink to this headline">¶</a></h3>
<p>Each scalar argument of the top-level function (e.g., void foo(<strong>int
scalar_arg</strong>);) becomes an input port of the top-level RTL module. Valid
argument values should be provided on these input ports when the <cite>start</cite> signal
is asserted.
If the input port can be held valid and unchanged throughout the whole
iteration of the execution, a <cite>stable</cite> option can be specified using the
following pragma to inform SmartHLS and potentially save register usage in the
generated module.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS interface argument(&lt;SCALAR_ARGUMENT_NAME&gt;) type(simple) stable(&lt;false|true&gt;)</span>
</pre></div>
</div>
<p>Note that the <cite>type</cite> option is not configurable in the current release but
still needs to be specified if you wish to add the <cite>stable</cite> option.
If <cite>stable</cite> is false, the pragma is not necessary because SmartHLS assumes not stable by default.</p>
<p>As shown in the table below, each scalar argument corresponds to an input port
of the top-level module,</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 16%" />
<col style="width: 8%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Port Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>&lt;ARGUMENT_NAME&gt;</cite></p></td>
<td><p>IN</p></td>
<td><p>The input value of the scalar argument.  This input port is sampled by the SmartHLS module when both
<cite>start</cite> and <cite>ready</cite> signals are 1.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="pointer-argument-and-shared-global-variable">
<h3><span class="section-number">1.14.3. </span>Pointer Argument and Shared Global Variable<a class="headerlink" href="#pointer-argument-and-shared-global-variable" title="Permalink to this headline">¶</a></h3>
<p>Pointer argument and global variables are considered as “memories” that
maintain states in the circuit.  The “memories” may be implemented inside or
outside of the SmartHLS-generated circuit, depending on the specified interface
type.  For a global variable, a top-level RTL interface is only created if the
variable is shared/accessed by both the software testbench and the HLS
function.  If the global variable is only accessed by the HLS function, the
“memory” will be implemented inside the generated circuit and has no top-level
interface.</p>
<p>There are two interface types for pointer arguments and shared global
variables: memory and AXI4 slave. As shown in the table below,
the available and default interface types vary depending on the data type of
the pointer or global variable.  We will explain each interface type in the
sections below.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 37%" />
<col style="width: 42%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>Data Type</p></th>
<th class="head" colspan="2"><p>Interface Type</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Memory</p></th>
<th class="head"><p>AXI4 Slave</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Array</p></td>
<td><p>Yes (default)</p></td>
<td><p>n/a</p></td>
</tr>
<tr class="row-even"><td><p>Struct</p></td>
<td><p>Yes (default)</p></td>
<td><p>Yes  (global only)</p></td>
</tr>
<tr class="row-odd"><td><p>Scalar</p></td>
<td><p>Yes (default)</p></td>
<td><p>n/a</p></td>
</tr>
</tbody>
</table>
<section id="memory-type">
<h4><span class="section-number">1.14.3.1. </span>Memory Type<a class="headerlink" href="#memory-type" title="Permalink to this headline">¶</a></h4>
<p>The memory interface can be used for array/struct arguments or shared global
array/struct. The generated RTL interface can be connected to an external RAM
module that stores the corresponding data.
The pragma below specifies the memory interface type for a given argument or
global variable,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// For top-level function arguments:</span>
<span class="c1">// Add at the beginning of the function definition</span>
<span class="cp">#pragma HLS interface argument(&lt;ARGUMENT_NAME&gt;) type(memory) num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;)</span>

<span class="c1">// For shared global variables:</span>
<span class="c1">// Add before the variable definition</span>
<span class="cp">#pragma HLS interface variable(&lt;ARGUMENT_NAME&gt;) type(memory) num_elements(&lt;NUM_ARRAY_ELEMENTS&gt;)</span>
</pre></div>
</div>
<p>The <cite>num_elements</cite> option is only available for array type arguments. The array size
can be specified or overridden (over the declared size in C++) by specifying
the <cite>num_elements</cite> option.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The specified num_elements will represent the total number of elements of the
array.  In the case of multi-dimensional array, the size of the outermost
dimension will be overrided to (num_elements / COMBINE_DEPTH_OF_INNER_DIMENSIONS),
and the sizes of inner dimensions will remain the same.
For multi-dimensional arrays, the specified num_elements has to be a multiple
of the combined number of elements of all inner dimensions (except the
outermost dimension).  Meaning only the outermost dimension’s size can be
overrided.</p>
</div>
<section id="aggregate-memory-type-array-struct-or-class">
<h5><span class="section-number">1.14.3.1.1. </span>Aggregate Memory Type (array, struct, or class)<a class="headerlink" href="#aggregate-memory-type-array-struct-or-class" title="Permalink to this headline">¶</a></h5>
<p>When the memory has more than 1 elements (not a scalar type memory), SmartHLS
creates an interface with two RAM ports. Each RAM port can do both read and
write to the external RAM. A one cycle read latency is expected.
Typically an external true dual-port RAM can be connected to the interface,
allowing both ports to perform independent reads/writes simultaneously.
The same port will not perform read and write at the same cycle.</p>
<p>The table below lists the signals of each RAM port, with “_a” and “_b” suffixes
respectively.  Some signals are not available when the memory is read-only or
write-only, i.e., when the top-level function (and its descendant functions)
never write to or read from the memory.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 31%" />
<col style="width: 9%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Port Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>&lt;ARG_NAME&gt;_address_&lt;a|b&gt;</cite></p></td>
<td><p>OUT</p></td>
<td><p>The address pointing to the RAM entry that SmartHLS module wants to access.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>&lt;ARG_NAME&gt;_read_en_&lt;a|b&gt;</cite></p></td>
<td><p>OUT</p></td>
<td><p>Read enable port (n/a for write-only memory).</p></td>
</tr>
<tr class="row-even"><td><p><cite>&lt;ARG_NAME&gt;_read_data_&lt;a|b&gt;</cite></p></td>
<td><p>IN</p></td>
<td><p>Read data port (n/a for write-only memory).</p></td>
</tr>
<tr class="row-odd"><td><p><cite>&lt;ARG_NAME&gt;_write_en_&lt;a|b&gt;</cite></p></td>
<td><p>OUT</p></td>
<td><p>Write enable port (n/a for read-only memory).</p></td>
</tr>
<tr class="row-even"><td><p><cite>&lt;ARG_NAME&gt;_byte_en_&lt;a|b&gt;</cite></p></td>
<td><p>OUT</p></td>
<td><p>Byte-enable port. Only available if the memory requires writes to partial
bytes of a memory word.
(n/a for read-only memory, or when all write operations update the whole
memory words).</p></td>
</tr>
<tr class="row-odd"><td><p><cite>&lt;ARG_NAME&gt;_write_data_&lt;a|b&gt;</cite></p></td>
<td><p>OUT</p></td>
<td><p>Write data port (n/a for read-only memory).</p></td>
</tr>
</tbody>
</table>
<p>The timing diagram shows the memory interface behaviour expected by the SmartHLS-generated module.</p>
<img alt="_images/memory_intf.png" class="align-center" src="_images/memory_intf.png" />
<ul class="simple">
<li><p>At Cycle a, the top-level module performs a write operation to the connected
external memory, by setting the <cite>arg_write_en</cite> port to high and providing the
address “A0” and write data “D0” on the <cite>arg_address</cite> and <cite>arg_write_data</cite>
ports respectively.</p></li>
<li><p>At Cycle b, the top-level module issues a read from the connected external
memory by setting <cite>arg_address</cite> to the read address “A0” and <cite>arg_read_en</cite> to
high.  SmartHLS module expects the read data “D0” to be available on the
<cite>arg_read_data</cite> port in the subsequent cycle (i.e., Cycle c).</p></li>
<li><p>At Cycle d, the top-level module writes “D1” to address “A1”</p></li>
<li><p>Keeping the address port the same and setting <cite>arg_read_en</cite> high at the next
cycle, the top-level module reads from address “A1” at Cycle e, and expects to
receive “D1” at the right next cycle at Cycle f.</p></li>
</ul>
</section>
<section id="scalar-memory-type">
<h5><span class="section-number">1.14.3.1.2. </span>Scalar Memory Type<a class="headerlink" href="#scalar-memory-type" title="Permalink to this headline">¶</a></h5>
<p>The scalar memory interface is used by SmartHLS module to access an external
memory that has only one element, and can be thought of as a special memory
interface that has no address port and expects a 0-cycle read latency.</p>
<p>The scalar memory interface is used by default for scalar pointer arguments and
shared scalar global variables.
Note that specifying an array / struct data type to be partitioned into individual
elements using <cite>#pragma HLS memory partition</cite> (See <span class="xref std std-ref">_memory_partitioning</span> for details) can create scalar interfaces.
The following example has an array interface <cite>array</cite> that is partitioned completely into 10 elements, each element is
a scalar memory.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">kernel</span><span class="p">(</span><span class="kt">int</span> <span class="n">array</span><span class="p">[</span><span class="mi">10</span><span class="p">])</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
<span class="cp">#pragma HLS memory partition argument(array) type(complete)</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The table below lists the associated RTL module ports for each scalar memory
interface.  Some signals are not available when the memory is read-only or
write-only, i.e., when the top-level function (and its descendant functions)
never write to or read from the memory.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 25%" />
<col style="width: 10%" />
<col style="width: 65%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Port Name</p></th>
<th class="head"><p>Direction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>&lt;ARG_NAME&gt;_read_data</cite></p></td>
<td><p>IN</p></td>
<td><p>The input value of the argument (n/a for write-only memory).
The signal is not sampled at the start of circuit execution.
The external logic needs to keep the signal stable
and valid at any given time during the circuit execution.</p></td>
</tr>
<tr class="row-odd"><td><p><cite>&lt;ARG_NAME&gt;_write_data</cite></p></td>
<td><p>OUT</p></td>
<td><p>The output value of the argument (n/a for read-only memory).
The <cite>write_data</cite> port has valid value
only when the <cite>write_en</cite> signal is high.
This port is not available if the SmartHLS circuit never writes to the
pointer argument (or global variable).</p></td>
</tr>
<tr class="row-even"><td><p><cite>&lt;ARG_NAME&gt;_write_en</cite></p></td>
<td><p>OUT</p></td>
<td><p>Indicates the write_data is valid (n/a for read-only memory).
This port is not available if the SmartHLS circuit never writes to the
pointer argument (or global variable).</p></td>
</tr>
</tbody>
</table>
<p>Note that SmartHLS circuit expects a 0-cycle read latency.
This is, the <cite>&lt;ARG_NAME&gt;_read_data</cite> port is expected to always hold the valid
data for the pointer argument such that the SmartHLS circuit can use its value at
any time.</p>
<p>One way of using the scalar memory interface is to connect the scalar memory
interface to a register outside of the SmartHLS module. The <cite>read_data</cite> port can
be connected to the register itself. The <cite>write_en</cite> and <cite>write_data</cite> ports will
be used to update the register.</p>
<img alt="_images/scalar_memory_intf.png" class="align-center" src="_images/scalar_memory_intf.png" />
<p>The timing diagram gives an example of how the scalar memory interface would
behave when it is connected to an external register.  Initially the external
register is holding a value of “D0” and providing the value to the
<cite>arg_read_data</cite> port.
At Cycle a, the top-level module writes to the register by asserting
<cite>arg_write_en</cite> and setting <cite>arg_write_data</cite> to “D1”.
Then at the next cycle, Cycle b, the register value is updated, and the
<cite>arg_read_data</cite> is also immediately updated to the new value.</p>
<p>Note that the scalar memory interface does not always have to be connected to
an external register.
One use case of the scalar memory interface could be to connect the
<cite>arg_read_data</cite> port to an input signal that is changing while the SmartHLS
circuit runs, allowing the SmartHLS circuit to read the up-to-date value from the
input. Typically, the pointer argument is read-only by the SmartHLS circuit in
such case.</p>
<p>Similarly, the <cite>arg_write_data</cite> can be connected to an output that needs to be
updated in real-time.  In this case, the pointer argument is normally only
written to by the SmartHLS circuit (with no read access).</p>
</section>
</section>
<section id="axi4-slave-type">
<h4><span class="section-number">1.14.3.2. </span>AXI4 Slave Type<a class="headerlink" href="#axi4-slave-type" title="Permalink to this headline">¶</a></h4>
<p>In contrast to the memory and scalar memory interfaces, when the AXI4 slave
interface is used, the “memories” for storing the data is inside the
SmartHLS-generated RTL module rather than outside.  The logic outside of SmartHLS
module is responsible for initializing and/or retrieving the memory content
before and/or after the execution of SmartHLS module. The pragma below specifies
an AXI4 slave interface,</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="c1">// For shared global variables:</span>
<span class="c1">// Add before the variable definition</span>
<span class="cp">#pragma HLS interface variable(&lt;SCALAR_ARGUMENT_NAME&gt;) type(axi_slave) concurrent_access(true|false)</span>
</pre></div>
</div>
<p>When the <cite>concurrent_access</cite> option is set to true (default to false), the
external logic can read/write the AXI4 slave interface while the SmartHLS module is
running.  The concurrent access will however reduce the SmartHLS module’s
throughput to access the memory.</p>
<p>After compilation, SmartHLS will generate a report file
(<code class="docutils literal notranslate"><span class="pre">reports/axi_slave_memory_map.hls.rpt</span></code>) to specify the address map for
each struct element.
Here is an example struct and its corresponding memory map,</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifndef __SLAVE_LAYOUT_H__</span>
<span class="cp">#define __SLAVE_LAYOUT_H__</span>

<span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp"></span>

<span class="c1">// Define the AXI slave memory layout as a struct in a header file.</span>
<span class="k">struct</span> <span class="nc">SlaveLayout</span> <span class="p">{</span>
    <span class="kt">uint16_t</span> <span class="n">array</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
    <span class="kt">uint32_t</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">sum_result</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">xor_result</span><span class="p">,</span> <span class="n">or_result</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// Declare a &#39;SlaveLayout&#39; type global variable in C++ source file (.cpp).</span>
<span class="c1">// Use HLS interface pragma with axi_slave type to specify an AXI4 slave interface.</span>
<span class="cp">#pragma HLS interface variable(global_var) type(axi_slave) concurrent_access(true)</span>
<span class="n">SlaveLayout</span> <span class="n">global_var</span><span class="p">;</span>
</pre></div>
</div>
<p>The corresponding address map report
(<code class="docutils literal notranslate"><span class="pre">reports/axi_slave_memory_map.hls.rpt</span></code>) is shown below.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Address Map for AXI Slave Interface: global_var

+--------------+-----------+-------------------+----------+
| Word Address | Bit Range | Variables         | Removed? |
+--------------+-----------+-------------------+----------+
| 0            |  15 :  0  | memory.array[0]   |          |
|              |  31 : 16  | memory.array[1]   |          |
|              |  47 : 32  | memory.array[2]   |          |
|              |  63 : 48  | memory.array[3]   |          |
| 1            |  15 :  0  | memory.array[4]   |          |
|              |  31 : 16  | memory.array[5]   |          |
|              |  47 : 32  | memory.array[6]   |          |
|              |  63 : 48  | memory.array[7]   |          |
| 2            |  31 :  0  | memory.a          |          |
|              |  63 : 32  | memory.b          |          |
| 3            |  63 :  0  | memory.sum_result |          |
| 4            |  31 :  0  | memory.xor_result |          |
|              |  63 : 32  | memory.or_result  |          |
| 5            |   0 :  0  | slave_memory_ctrl |          |
+--------------+-----------+-------------------+----------+
</pre></div>
</div>
<ul class="simple">
<li><p>Note that the first column in the report shows the word-address – multiply
by 8 to get the byte-address.</p></li>
<li><p>The last column will indicate the struct elements that are optimized away
from compilation because the SmartHLS module does not access them.</p></li>
<li><p>Notice that the last element in the table, <code class="docutils literal notranslate"><span class="pre">slave_memory_ctrl</span></code>, is not part
of the struct definition.  This is a special status control register for the
SmartHLS module. Writing to the address of <code class="docutils literal notranslate"><span class="pre">slave_memory_ctrl</span></code> will start the
SmartHLS module (if the module was not running), and reading the register can
poll the status, a value of 1 indicates the SmartHLS module has finished
running, and 0 otherwise.  This memory-mapped control interface can be useful
for an AXI4 master to control the SmartHLS-generated module’s execution (e.g., a
processor controlling the SmartHLS-generated module).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>IMPORTANT: the AXI4 slave has some restrictions</strong>,</p>
<ul class="simple">
<li><p>A SmartHLS module can have at most one AXI4 slave interface, and the AXI4
slave interface type can only be specified for a global variable with a
struct data type.</p>
<ul>
<li><p>If multiple data need to be placed behind the AXI4 slave interface, you
can define a new struct type to include all the data, then instantiate a
global variable with the struct type, and specify the above pragma for
the global variable.</p></li>
</ul>
</li>
<li><p>The AXI4 slave interface always uses 32-bit address and 64-bit data width.</p></li>
<li><p>The AXI4 slave interface only supports the AXI4-lite protocol with
additional support for incremental bursting.</p></li>
<li><p>The AxBURST and AxSIZE input signals are ignored by the slave logic.</p>
<ul>
<li><p>Regardless of the actual input values of the AxBURST and AxSIZE signals,
the AXI4 slave always uses the incremental burst type (AxBURST == 1) with a
size of 8 bytes per transfer (AxSIZE == 3).</p></li>
</ul>
</li>
<li><p>Byte-enable write (via WSTRB port) must be aligned to the elements in the
struct.</p>
<ul>
<li><p>For the WSTRB bits corresponding to (different bytes of) a common struct
element, these WSTRB bits must be all 1s or all 0s.</p></li>
<li><p>For example, if we are writing to a word address that maps to two ‘int’
type integers (4 bytes each, packed together as one 64-bit AXI word), the
upper 4 bits of the WSTRB port must be all 1s or 0s, and the same applies
to the lower 4 bits of the WSTRB port.
That is, we cannot update partial bytes of either ‘int’ type integers, but
updating all bytes of one of the two ‘int’ type integers is allowed.</p></li>
</ul>
</li>
<li><p>The SW/HW Co-Simulation is only supported if the top level function is not
pipelined.</p></li>
<li><p>When AXI4 slave interface is used, the top-level function must use void
return type.</p></li>
</ul>
</div>
</section>
</section>
<section id="hls-fifo-argument">
<h3><span class="section-number">1.14.4. </span>hls::FIFO Argument<a class="headerlink" href="#hls-fifo-argument" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS provides a <a class="reference internal" href="#streaming-lib"><span class="std std-ref">Streaming Library</span></a> which includes a FIFO
template class for inferring the AXI4-stream like, ready-valid-data (RVD)
interface.  When a <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> type argument is used by the top-level
function, a corresponding RVD interface is always generated.</p>
<p>The RVD interface is useful to transfer data from an upstream producer to a
downstream consumer. The upstream sends the data along with a valid signal to
indicate the data validity, while the downstream controls a ready signal to
indicate its readiness to consume the data.  A data is only transferred when
both valid and ready signals are high at a positive clock edge.</p>
<img alt="_images/rvd_intf.png" class="align-center" src="_images/rvd_intf.png" />
<p>As shown in the above timing diagram, three sets of data are transferred at
the 2rd, 4th, and 6th positive clock edges.
No data transfer occurs at the 3rd positive clock edge because the upstream
does not assert the valid signal.
The data “D2” is also not transferred at the 5th positive clock edge because
the downstream back-pressures the upstream by lowering the ready signal.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> template class is declared as</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">pack</span> <span class="o">=</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="k">class</span> <span class="nc">FIFO</span><span class="p">;</span>
</pre></div>
</div>
<p>The template argument <code class="docutils literal notranslate"><span class="pre">T</span></code> defines the data type, which can be a scalar data
type or a struct of multiple scalar types. The template argument <code class="docutils literal notranslate"><span class="pre">pack</span></code>
defines whether the scalar elements inside the struct should be packed into a
single data port. When <code class="docutils literal notranslate"><span class="pre">pack</span></code> is false, each scalar element has its own data
port, and all scalar elements in the struct share the same pair of ready and
valid ports.
A <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> argument must be either write-only or read-only. The data and
valid ports always have the same direction (output if write-only, input if
read-only), while the ready port has the opposite direction. The following
table shows the interface ports of the <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> argument depending on
the template parameters.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 38%" />
<col style="width: 19%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head" colspan="2"><p>Template Parameter</p></th>
<th class="head"><p>Port Name</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td colspan="2"><p><code class="docutils literal notranslate"><span class="pre">T</span></code> is a scalar data type  (<code class="docutils literal notranslate"><span class="pre">pack</span></code> is ignored)</p></td>
<td><div class="line-block">
<div class="line">&lt;ARG_NAME&gt;</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
<tr class="row-odd"><td rowspan="2"><p><code class="docutils literal notranslate"><span class="pre">T</span></code> is a struct of scalars, e.g.,</p>
<p>struct MyAxiStream {
ap_uint&lt;32&gt; data;
ap_uint&lt;8&gt;  keep;
ap_uint&lt;1&gt;  last;
};</p>
</td>
<td><p><code class="docutils literal notranslate"><span class="pre">pack</span></code> = false</p></td>
<td><div class="line-block">
<div class="line">&lt;ARG_NAME&gt;_data</div>
<div class="line">&lt;ARG_NAME&gt;_keep</div>
<div class="line">&lt;ARG_NAME&gt;_last</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">pack</span></code> = true</p></td>
<td><div class="line-block">
<div class="line">&lt;ARG_NAME&gt;  // 41-bit wide.</div>
<div class="line">&lt;ARG_NAME&gt;_valid</div>
<div class="line">&lt;ARG_NAME&gt;_ready</div>
</div>
</td>
</tr>
</tbody>
</table>
<p>In the struct type example above, the <code class="docutils literal notranslate"><span class="pre">ap_uint</span></code> template class is from
<a class="reference internal" href="#ap-lib"><span class="std std-ref">C++ Arbitrary Precision Data Types Library</span></a>, which allows you
to define custom bit-width integers.</p>
<p>If you are familiar with the AXI4-stream interface, you may already notice that
the struct example (non-pack case) yields an AXI4-stream interface.
Indeed, this is how to infer AXI4-stream interface using <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> library.</p>
<section id="implementing-a-custom-axi4-master-slave-using-hls-fifo">
<h4><span class="section-number">1.14.4.1. </span>Implementing A Custom AXI4 Master/Slave Using hls::FIFO<a class="headerlink" href="#implementing-a-custom-axi4-master-slave-using-hls-fifo" title="Permalink to this headline">¶</a></h4>
<p>In addition to inferring an AXI4-stream interface as shown in the example
above, <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> can also be used to implement a custom AXI4 slave or
AXI4 master.
The AXI4 interface protocol has 5 channels, read address (AR), read data (R),
write address (AW), write data (W), and write response (B). Each channel is an
AXI4 stream interface and can be described in C++ as a <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> object.
For example, the read address channel has an address signal and a length
signal.  The AXI4 channel can be implemented as following in C++ to get the
corresponding AR channel in the RTL interface.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">RdAddrSignals</span> <span class="p">{</span> <span class="kt">uint32_t</span> <span class="n">addr</span><span class="p">;</span>  <span class="kt">uint8_t</span> <span class="n">len</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">void</span> <span class="nf">MyTopFunctoin</span> <span class="p">(</span><span class="n">hls</span><span class="o">::</span><span class="n">FIFO</span><span class="o">&lt;</span><span class="n">RdAddrSignals</span><span class="o">&gt;</span> <span class="n">ar</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">RdAddrSignals</span> <span class="n">ar_sig</span><span class="p">;</span>
  <span class="n">ar_sig</span><span class="p">.</span><span class="n">addr</span> <span class="o">=</span> <span class="mh">0x2000</span><span class="p">;</span>
  <span class="n">ar_sig</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>  <span class="c1">// 8-beat burst.</span>
  <span class="n">ar</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ar_sig</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-Verilog notranslate"><div class="highlight"><pre><span></span><span class="k">module</span> <span class="n">MyTopFunction</span> <span class="p">(</span>
  <span class="k">input</span> <span class="n">clock</span><span class="p">,</span>
  <span class="k">input</span> <span class="n">reset</span><span class="p">,</span>
  <span class="k">input</span>         <span class="n">ar_ready</span><span class="p">,</span>
  <span class="k">output</span>        <span class="n">ar_valid</span><span class="p">,</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">31</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span> <span class="n">ar_addr</span><span class="p">,</span>
  <span class="k">output</span> <span class="p">[</span><span class="mh">7</span><span class="o">:</span><span class="mh">0</span><span class="p">]</span>  <span class="n">ar_len</span>
<span class="p">);</span>
</pre></div>
</div>
</section>
<section id="c-library-for-custom-axi-master-interface">
<h4><span class="section-number">1.14.4.2. </span>C++ Library for Custom AXI Master Interface<a class="headerlink" href="#c-library-for-custom-axi-master-interface" title="Permalink to this headline">¶</a></h4>
<p>SmartHLS provides a C++ library for implementing the AXI4 master interfaces. The
library defines the AXI4 master interface in C++ and provides several API
functions for typical operations. For advanced users hoping to have more
fine-grained custom control, or additional AXI4 interface signals that are not
included in the library, the library can serve as a reference implementation
for customization (create your own AXI4 master library based on SmartHLS’s
<code class="docutils literal notranslate"><span class="pre">axi_interface.hpp</span></code> header file).</p>
<p>To create an AXI4 master interface using SmartHLS’s library, include the header file:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/axi_interface.hpp&gt;</span><span class="cp"></span>
</pre></div>
</div>
<p>To add an AXI4 master interface, you will need to</p>
<ol class="arabic simple">
<li><p>Create an instance of the <code class="docutils literal notranslate"><span class="pre">AxiInterface</span></code> class and specify the address width, data width and wstrb width through template parameters.</p></li>
<li><p>Pass the created instance by reference to the top-level function.
E.g., <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">MyTop(AxiInterface&lt;/*</span> <span class="pre">ADDR:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;32&gt;,</span> <span class="pre">/*</span> <span class="pre">DATA:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;64&gt;,</span> <span class="pre">/*</span> <span class="pre">WSTRB:</span> <span class="pre">*/</span> <span class="pre">ap_uint&lt;8&gt;&gt;</span> <span class="pre">&amp;master);</span></code></p></li>
<li><p>Use the utility functions (APIs) defined in the header to control the AXI master interface.</p></li>
</ol>
<p>Below are the API functions to access the AXI master interface.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">Send a read request starting from &#39;byte_addr&#39; for &#39;burst_len&#39; number of transfers.</span>
<span class="cm">- &#39;burst_len&#39; can not be greater than 256 (max: 256) according to AXI4 specification.</span>
<span class="cm">- &#39;burst_type&#39; is optional. The default value is 1 (incremental).</span>
<span class="cm">- &#39;transfer_size&#39; is optional. The default value is automatically set to the full size matching T_DATA.</span>
<span class="cm">  - The byte size per transfer equals to 2 to the power of transfer_size.</span>
<span class="cm">  - e.g., if T_DATA is of an ap_uint&lt;64&gt; or uint64 type, the default transfer_size is 3.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_read_req</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                    <span class="n">T_ADDR</span> <span class="n">byte_addr</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">burst_len</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">burst_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">transfer_size</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">SIZE_MATCHING_T_DATA</span><span class="o">&gt;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Receive the read data (return value) for one read transfer.</span>
<span class="cm">- The function should be called after a read request is sent by &#39;axi_m_read_req&#39;.</span>
<span class="cm">- For a read request with &#39;burst_len&#39; number of transfers, this function</span>
<span class="cm">  should be called for &#39;burst_len&#39; number of times to receive all read data.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="n">T_DATA</span> <span class="n">axi_m_read_data</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Send a write request starting from &#39;byte_addr&#39; for &#39;burst_len&#39; number of transfers.</span>
<span class="cm">- &#39;burst_len&#39; can not be greater than 256 (max: 256) according to AXI4 specification.</span>
<span class="cm">- &#39;burst_type&#39; is optional. The default value is 1 (incremental).</span>
<span class="cm">- &#39;transfer_size&#39; is optional. The default value is automatically set to the full size matching T_DATA.</span>
<span class="cm">  - The byte size per transfer equals to 2 to the power of transfer_size.</span>
<span class="cm">  - e.g., if T_DATA is of an ap_uint&lt;64&gt; or uint64 type, the default transfer_size is 3.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_write_req</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                     <span class="n">T_ADDR</span> <span class="n">byte_addr</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">burst_len</span><span class="p">,</span>
                     <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">burst_type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span> <span class="n">transfer_size</span> <span class="o">=</span> <span class="o">&lt;</span><span class="n">SIZE_MATCHING_T_DATA</span><span class="o">&gt;</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Send the write data &#39;val&#39; for one write transfer.</span>
<span class="cm">- The function should be called after a write request is sent by &#39;axi_m_write_req&#39;.</span>
<span class="cm">- For a write request with &#39;burst_len&#39; number of transfers, this function</span>
<span class="cm">  should be called for &#39;burst_len&#39; number of times to send all write data.</span>
<span class="cm">  - &#39;strb&#39; acts as the byte-enable with each bit corresponds to a byte of the data.</span>
<span class="cm">  - &#39;last&#39; should be set to 1 if and only if the current function call</span>
<span class="cm">    corresponds to the last transfer of the current write request.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">axi_m_write_data</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">,</span>
                      <span class="n">T_DATA</span> <span class="n">val</span><span class="p">,</span> <span class="n">T_WSTRB</span> <span class="n">strb</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">last</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm">Receive the response acknowledgement for the last write request from the slave.</span>
<span class="cm">- The function should be called after all write data are sent by &#39;axi_m_write_data&#39;.</span>
<span class="cm">- A return value of 0 means &#39;OK&#39;; otherwise indicates an error.</span>
<span class="cm">*/</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T_ADDR</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_DATA</span><span class="p">,</span> <span class="k">class</span> <span class="nc">T_WSTRB</span><span class="o">&gt;</span>
<span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">axi_m_write_resp</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">T_ADDR</span><span class="p">,</span> <span class="n">T_DATA</span><span class="p">,</span> <span class="n">T_WSTRB</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
</pre></div>
</div>
<p>The read and write operations are independent and therefore can be executed in
parallel at the same time.</p>
<p>Same as the AXI4 slave interface, this AXI4 master interface library only
supports the AXI4-lite protocol with additional support for bursting.</p>
<p>SW/HW Co-Simulation is supported for AXI master, but requires modeling the AXI
slave’s responses to the AXI master in software before the kernel is called. An
example of an AXI4 master interface tested with CoSim is shown below.</p>
<div class="highlight-CPP notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;hls/axi_interface.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;hls/ap_int.hpp&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">hls</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">simple_master</span><span class="p">(</span><span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">master</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#pragma HLS function top</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">9</span><span class="o">&gt;</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">r_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">w_addr</span> <span class="o">=</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

<span class="cp">#pragma HLS loop pipeline</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">remaining</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">remaining</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span> <span class="n">is_last</span> <span class="o">=</span> <span class="n">remaining</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">==</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// Request to read data in burst.</span>
            <span class="n">axi_m_read_req</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">r_addr</span><span class="p">,</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>

            <span class="c1">// Request to write data in burst.</span>
            <span class="n">axi_m_write_req</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">w_addr</span><span class="p">,</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Write back the data we read + 1.</span>
        <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span> <span class="n">data</span> <span class="o">=</span> <span class="n">axi_m_read_data</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
        <span class="n">axi_m_write_data</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">),</span> <span class="n">is_last</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="c1">// After the last write, read the response code.</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span> <span class="n">bresp</span> <span class="o">=</span> <span class="n">axi_m_write_resp</span><span class="p">(</span><span class="n">master</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">AxiInterface</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;&gt;</span> <span class="n">axi_if</span><span class="p">(</span><span class="n">AXIM_MAX_BURST_LEN</span><span class="p">);</span>

    <span class="c1">// Prepare the data to be read by the AXI master.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RdDataSignals</span><span class="o">&lt;</span><span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">64</span><span class="o">&gt;&gt;</span> <span class="n">r_sig</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">resp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">r_sig</span><span class="p">.</span><span class="n">last</span> <span class="o">=</span> <span class="n">i</span> <span class="o">==</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">axi_if</span><span class="p">.</span><span class="n">r</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">r_sig</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Prepare the write response for the write from AXI master.</span>
    <span class="n">WrRespSignals</span> <span class="n">b_sig</span><span class="p">;</span>
    <span class="n">axi_if</span><span class="p">.</span><span class="n">b</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">b_sig</span><span class="p">);</span>

    <span class="c1">// Run the top-level function that will be synthesize to hardware.</span>
    <span class="n">simple_master</span><span class="p">(</span><span class="n">axi_if</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">failed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="c1">// Clear the write and read request.</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">r_addr</span> <span class="o">=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">ar</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">addr</span><span class="p">;</span>
    <span class="n">ap_uint</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">w_addr</span> <span class="o">=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">aw</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">addr</span><span class="p">;</span>

    <span class="c1">// Check that the read and write addresses were as expected.</span>
    <span class="n">failed</span> <span class="o">|=</span> <span class="n">r_addr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">failed</span> <span class="o">|=</span> <span class="n">w_addr</span> <span class="o">!=</span> <span class="n">AXIM_MAX_BURST_LEN</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

    <span class="c1">// Read all of write data.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">AXIM_MAX_BURST_LEN</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Check that write data is i + 1.</span>
        <span class="n">failed</span> <span class="o">|=</span> <span class="n">axi_if</span><span class="p">.</span><span class="n">w</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">data</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Now that all FIFOs have been cleared, the AXI interface could be prepared</span>
    <span class="c1">// for more calls to the kernel..</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">failed</span><span class="p">)</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;PASS!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;FAILED!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">failed</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="specifying-a-custom-test-bench">
<span id="custom-testbench"></span><h2><span class="section-number">1.15. </span>Specifying a Custom Test Bench<a class="headerlink" href="#specifying-a-custom-test-bench" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS allows one to use a custom test bench to simulate the hardware generated by SmartHLS.
When a custom top-level function is specified by the user, there are two options for simulation:</p>
<ul class="simple">
<li><p>Use <a class="reference internal" href="#sw-hw-cosimulation"><span class="std std-ref">SW/HW Co-Simulation</span></a>.</p></li>
<li><p>A custom test bench must be provided by the user.</p></li>
</ul>
<p>A custom test bench can be specified to SmartHLS via the <code class="docutils literal notranslate"><span class="pre">HLS</span> <span class="pre">Constraints</span></code> window:</p>
<a class="reference internal image-reference" href="_images/set_custom_test_bench.png"><img alt="_images/set_custom_test_bench.png" class="align-center" src="_images/set_custom_test_bench.png" style="width: 723.0px; height: 300.0px;" /></a>
<p>One must specify both the name of custom Verilog module as well as the name of the custom test bench file.
It can also be specified directly in the <code class="docutils literal notranslate"><span class="pre">config.tcl</span></code> file as the following:</p>
<div class="highlight-tcl notranslate"><div class="highlight"><pre><span></span><span class="nv">set_custom_test_bench_module</span> <span class="s2">&quot;testBenchModuleName&quot;</span>
<span class="nv">set_custom_test_bench_file</span> <span class="s2">&quot;testBenchFileName.v&quot;</span>
</pre></div>
</div>
<p>This constraint is also described in <a class="reference internal" href="constraintsmanual.html#set-custom-test-bench-module"><span class="std std-ref">set_custom_test_bench_module</span></a> and <a class="reference internal" href="constraintsmanual.html#set-custom-test-bench-file"><span class="std std-ref">set_custom_test_bench_file</span></a>.</p>
</section>
<section id="report-files">
<h2><span class="section-number">1.16. </span>Report Files<a class="headerlink" href="#report-files" title="Permalink to this headline">¶</a></h2>
<section id="smarthls-report">
<h3><span class="section-number">1.16.1. </span>SmartHLS Report<a class="headerlink" href="#smarthls-report" title="Permalink to this headline">¶</a></h3>
<p>After compiling software to hardware, SmartHLS generates a summary report file
(<code class="docutils literal notranslate"><span class="pre">reports/summary.hls.rpt</span></code>) to show some insights about the generated RTL
circuit, such as the top-level module interface, scheduling information, memory
usage and etc.
The following will explain each section of the report file.</p>
<section id="rtl-interface-section">
<h4><span class="section-number">1.16.1.1. </span>RTL Interface Section<a class="headerlink" href="#rtl-interface-section" title="Permalink to this headline">¶</a></h4>
<p>The RTL Interface section shows the interfaces used by the top-level module.
Below is an example of the RTL interface report table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+---------------------------------------------------------------------------------------------+
| RTL Interface Generated by SmartHLS                                                         |
+--------------+-------------------+--------------------+------------------+------------------+
| C++ Name     | Interface Type    | Signal Name        | Signal Bit-width | Signal Direction |
+--------------+-------------------+--------------------+------------------+------------------+
|              | Control           | clk                | 1                | input            |
|              |                   | finish             | 1                | output           |
|              |                   | ready              | 1                | output           |
|              |                   | reset              | 1                | input            |
|              |                   | start              | 1                | input            |
+--------------+-------------------+--------------------+------------------+------------------+
| input_a_fifo | Input AXI Stream  | input_a_fifo_ready | 1                | output           |
|              |                   | input_a_fifo_valid | 1                | input            |
|              |                   | input_a_fifo       | 16               | input            |
+--------------+-------------------+--------------------+------------------+------------------+
</pre></div>
</div>
<p>The table shows the interface for each top-level function argument (or global
variable accessed by both the SW testbench and the top-level function).</p>
<blockquote>
<div><ul class="simple">
<li><p>The first column of the table shows the name of the argument or global
variable.</p></li>
<li><p>The second column shows the interface types used for this argument or
global variable.</p></li>
<li><p>The last three columns list the names, bit-widths, and directions for all
the signals that are included in the interface. For example, the AXI Stream
interface has three signals in this case, <cite>input_a_fifo</cite> for the 16-bit
data, with associated valid and ready signals.</p></li>
</ul>
</div></blockquote>
<p>Note that the <cite>Control</cite> interface is the standard module control interface that
is always used by any SmartHLS-generated module, and hence there is no C++ name
attached to it.
For more details about the RTL interface, please refer to <a class="reference internal" href="#rtl-interface"><span class="std std-ref">Top-Level RTL Interface</span></a>.</p>
</section>
<section id="scheduling-result">
<h4><span class="section-number">1.16.1.2. </span>Scheduling Result<a class="headerlink" href="#scheduling-result" title="Permalink to this headline">¶</a></h4>
<p>The scheduling result section primarily shows the cycle latency of each basic
block inside each function.
A basic block is a collection of instructions that always run together.
Below is an example table:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Basic Block Latencies:

+-------------------------------------------------+
| Function: sobel_filter (non-pipelined function) |
+--------------------------------+----------------+
| Basic Block                    | Cycle Latency  |
+--------------------------------+----------------+
| %entry                         | 1              |
| %for.cond1.preheader           | 1              |
| %for.body3                     | 2              |
| %for.body3.for.inc54_crit_edge | 1              |
| %for.cond14.preheader          | 9              |
| %for.inc54                     | 2              |
| %for.inc57                     | 1              |
| %for.end59                     | 1              |
+--------------------------------+----------------+
</pre></div>
</div>
<p>SmartHLS’s <cite>Schedule Viewer</cite> is more helpful in this case to visualize the
scheduling and the control-flow between basic blocks.</p>
</section>
<section id="pipeline-result">
<h4><span class="section-number">1.16.1.3. </span>Pipeline Result<a class="headerlink" href="#pipeline-result" title="Permalink to this headline">¶</a></h4>
<p>The pipeline result section reports the initiation interval, pipeline length, iteration count, and latency for each pipelined loop or function.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
| Label              | Function                   | Basic Block | Location in Source Code        | Initiation Interval | Pipeline Length | Iteration Count | Latency |
+--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
| loop_test_injector | test_input_injector(void*) | %for.body   | line 19 of test_util.cpp       | 1                   | 2               | 262144          | 262145  |
| gaussian_loop      | gaussian_filter(void*)     | %while.body | line 63 of gaussian_filter.cpp | 1                   | 8               | n/a             | n/a     |
| loop_test_checker  | test_output_checker(void*) | %for.body   | line 39 of test_util.cpp       | 1                   | 3               | 262144          | 262146  |
+--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
</pre></div>
</div>
<p>The iteration count and latency may not be available for a pipelined function or a pipelined loop with non-deterministic loop bound.
Please refer to <a class="reference internal" href="#loop-pipelining"><span class="std std-ref">Loop Pipelining</span></a> and <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a> for more details.
SmartHLS’s <cite>Schedule Viewer</cite> also gives more details about how individual instructions are scheduled inside each pipeline.</p>
</section>
<section id="memory-usage">
<h4><span class="section-number">1.16.1.4. </span>Memory Usage<a class="headerlink" href="#memory-usage" title="Permalink to this headline">¶</a></h4>
<p>The memory usage section lists the memories used by the generated circuit, grouped by the type of memory architecture.
Please refer to <a class="reference internal" href="hwarchitecture.html#mem-arch"><span class="std std-ref">Memory Architecture</span></a> section for more details about the memory architecture used by SmartHLS.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>+-------------------------------------------------------------------------+
| Local Constant Memories                                                 |
+-------+-----------------------+------+-------------+------------+-------+
| Name  | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
+-------+-----------------------+------+-------------+------------+-------+
| gauss | blackscholes_hw       | ROM  | 8192        | 32         | 256   |
+-------+-----------------------+------+-------------+------------+-------+

+-------------------------------------------------------------------------------------------------------------------------+
| Shared Local Memories                                                                                                   |
+-------------+--------------------------------------------------------+---------------+-------------+------------+-------+
| Name        | Accessing Function(s)                                  | Type          | Size [Bits] | Data Width | Depth |
+-------------+--------------------------------------------------------+---------------+-------------+------------+-------+
| init_fifo   | mersenne_twister_generate_hw, mersenne_twister_init_hw | FIFO (LUTRAM) | 64          | 32         | 2     |
| random_fifo | blackscholes_hw, mersenne_twister_generate_hw          | FIFO (LUTRAM) | 64          | 32         | 2     |
| idata_0     | mersenne_twister_init_hw, option_pricing               | Register      | 1           | 1          | 1     |
| idata_1     | mersenne_twister_init_hw, option_pricing               | Register      | 32          | 32         | 1     |
| tdata_0     | mersenne_twister_generate_hw, option_pricing           | Register      | 32          | 32         | 1     |
| tdata_1     | mersenne_twister_generate_hw, option_pricing           | Register      | 32          | 32         | 1     |
| bdata_0     | blackscholes_hw, option_pricing                        | Register      | 32          | 32         | 1     |
| bdata_1     | blackscholes_hw, option_pricing                        | Register      | 32          | 32         | 1     |
+-------------+--------------------------------------------------------+---------------+-------------+------------+-------+

+----------------------------------------------------------------------------------------------------------------+
| Aliased Memories                                                                                               |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+
| Name                   | Memory Controller   | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+
| foo_entry_local_array1 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     |
| foo_entry_local_array2 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     |
+------------------------+---------------------+-----------------------+------+-------------+------------+-------+

+------------------------------------------------------------------------------------------+
| I/O Memories                                                                             |
+--------+-----------------------+----------------------+-------------+------------+-------+
| Name   | Accessing Function(s) | Type                 | Size [Bits] | Data Width | Depth |
+--------+-----------------------+----------------------+-------------+------------+-------+
| rd_reg | kernel                | Register (Read-Only) | 0           | 16         | 0     |
| rd_arr | kernel                | ROM                  | 0           | 16         | 0     |
| wr_reg | kernel                | Register             | 0           | 16         | 0     |
| wr_arr | kernel                | RAM                  | 0           | 16         | 0     |
+--------+-----------------------+----------------------+-------------+------------+-------+
</pre></div>
</div>
<p>The example tables above show the accessing functions and the hardware implementation of each “memory” in the software.</p>
<blockquote>
<div><ul class="simple">
<li><p>The <cite>Type</cite> column shows how a memory is implemented in hardware, which could be in RAM, ROM (read-only), register or FIFO (only applicable to <code class="docutils literal notranslate"><span class="pre">hls::FIFO</span></code> type variables in C++).</p></li>
<li><p>The <cite>Size</cite> column reports the total size of the memory in bits, equals to <cite>Data Width</cite> * <cite>Depth</cite>.</p></li>
<li><p>The <cite>Data Width</cite> refers to the bit-width of the data ports of a RAM/FIFO, or the bit-width of a register.</p></li>
<li><p>The <cite>Depth</cite> field represents the depth of a RAM or FIFO, and it is always 1 for register.</p></li>
<li><p><cite>Aliased Memories</cite> have an additional column showing the name of the <cite>Memory Controller</cite> of which the memory is being placed behind.
So you can see which memories are aliasing and being put behind the same memory controller to support aliased memory accesses.</p></li>
</ul>
</div></blockquote>
</section>
</section>
<section id="simulation-and-rtl-synthesis-place-route-report">
<h3><span class="section-number">1.16.2. </span>Simulation and RTL Synthesis, Place &amp; Route Report<a class="headerlink" href="#simulation-and-rtl-synthesis-place-route-report" title="Permalink to this headline">¶</a></h3>
<p>SmartHLS also generates a summary report (<code class="docutils literal notranslate"><span class="pre">reports/summary.results.rpt</span></code>) to show
the results of simulation and RTL synthesis + Place &amp; Route.
Below is an example report:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>====== 1. Simulation Cycle Latency ======

Number of calls:        6,105
Cycle latency:        6,134
SW/HW co-simulation: PASS

====== 2. Timing Result ======

+--------------+---------------+-------------+-------------+----------+-------------+
| Clock Domain | Target Period | Target Fmax | Worst Slack | Period   | Fmax        |
+--------------+---------------+-------------+-------------+----------+-------------+
| clk          | 10.000 ns     | 100.000 MHz | 5.775 ns    | 4.225 ns | 236.686 MHz |
+--------------+---------------+-------------+-------------+----------+-------------+

The reported Fmax is for the HLS core in isolation (from Libero&#39;s post-place-and-route timing analysis).
When the HLS core is integrated into a larger system, the system Fmax may be lower depending on the critical path of the system.

====== 3. Resource Usage ======

+--------------------------+----------+--------+------------+
| Resource Type            | Used     | Total  | Percentage |
+--------------------------+----------+--------+------------+
| Fabric + Interface 4LUT* | 488 + 72 | 108600 | 0.52       |
| Fabric + Interface DFF*  | 397 + 72 | 108600 | 0.43       |
| I/O Register             | 0        | 852    | 0.00       |
| User I/O                 | 0        | 284    | 0.00       |
| uSRAM                    | 0        | 1008   | 0.00       |
| LSRAM                    | 2        | 352    | 0.57       |
| Math                     | 0        | 336    | 0.00       |
+--------------------------+----------+--------+------------+

* Interface 4LUTs and DFFs are occupied due to the uses of LSRAM, Math, and uSRAM.
  Number of interface 4LUTs/DFFs = (36 * #.LSRAM) + (36 * #.Math) + (12 * #.uSRAM) = (36 * 2) + (36 * 0) + (12 * 0) = 72.
</pre></div>
</div>
<p>The first section shows the result of <cite>SW/HW co-simulation</cite>, including the
number of calls of the top-level function, the total cycle latency for running
the whole simulation, and whether the SW/HW co-simulation has passed.</p>
<p>Note that when <a class="reference internal" href="#function-pipelining"><span class="std std-ref">Function Pipelining</span></a> is used, the auto-generated RTL
testbench for SW/HW co-simulation can inject a new set of inputs to the
top-level module without waiting for the previous “function calls” to finish.
And because of this overlapped execution, you could see the average cycle per
call being close to the reported initiation interval of the pipelined function.
For instance, the example report above is from a pipelined function with an
initiation interval of 1, and we can see that the average cycle per call is
very close to 1 (6,134/6,105).</p>
<p>The next two sections show the timing and resource usage results, parsed from
Libero’s report files after running RTL Synthesis and Place &amp; Route.
The target period is what you set in <a class="reference internal" href="#smarthls-constraints"><span class="std std-ref">SmartHLS Constraints</span></a>. If the <cite>Clock
Period</cite> is not set, SmartHLS uses a default clock period for the target FPGA
family (see the table in <a class="reference internal" href="#smarthls-constraints"><span class="std std-ref">SmartHLS Constraints</span></a>).</p>
</section>
</section>
<section id="schedule-viewer">
<h2><span class="section-number">1.17. </span>Schedule Viewer<a class="headerlink" href="#schedule-viewer" title="Permalink to this headline">¶</a></h2>
<p>The Schedule Viewer shows information on how the top-level function was scheduled in hardware by SmartHLS.
This includes information on the flow of control between different functions and blocks of execution,
as well as the cycle by cycle schedule of the operations in hardware.</p>
<p>The Schedule Viewer can be launched by clicking the “Launch Schedule Viewer” button in the SmartHLS IDE.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Toolbar.png"><img alt="_images/Schedule_Viewer_Toolbar.png" class="align-center" src="_images/Schedule_Viewer_Toolbar.png" style="width: 297.0px; height: 26.0px;" /></a>
<p>Alternatively, if using the Linux commandline, you can run the Schedule Viewer command.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>$ shls scheduleviewer
</pre></div>
</div>
<p>The Schedule Viewer has the Explorer tab and four views: the Call Graph, Control Flow Graph, Schedule Chart and Pipeline Viewer.
The Explorer tab lets you navigate between the functions and blocks within the design.
The Call Graph contains the directed graph of which software functions are called by which other software functions within the top-level function.
The Control Flow Graph shows the control flow of execution between the blocks within each function for if/else conditionals and loops.
The Schedule Chart and Pipeline Viewer shows the scheduling of instructions within a block or a pipeline on a cycle-by-cycle basis.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer.png"><img alt="_images/Schedule_Viewer.png" class="align-center" src="_images/Schedule_Viewer.png" style="width: 698.5999999999999px; height: 445.2px;" /></a>
<section id="background-llvm-internal-representation-used-by-smarthls">
<h3><span class="section-number">1.17.1. </span>Background: LLVM Internal Representation used by SmartHLS<a class="headerlink" href="#background-llvm-internal-representation-used-by-smarthls" title="Permalink to this headline">¶</a></h3>
<p>The instructions displayed in the Schedule Viewer are from the LLVM compiler that SmartHLS is built on.
These assembly-like instructions are called <a class="reference external" href="https://llvm.org/docs/LangRef.html">LLVM intermediate representation (IR)</a>.
Some understanding of the LLVM IR is beneficial when using the Schedule Viewer.</p>
<p>For example, given the 32-bit code:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span>result = a + b – 5
</pre></div>
</div>
<p>This C++ code could be represented as instructions in LLVM IR as:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="o">%</span><span class="n">result</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span>
</pre></div>
</div>
<p>In LLVM IR, intermediate variables are prefixed with a “%”.
Each operation (add/sub) includes the bitwidth “i32” indicating 32-bit integer.
The add operands are %a + %b and the result is stored in a temporary 32-bit variable %0.
The subtract operands are %0 – 5 and the result is stored in the variable %result.</p>
<p>Basic blocks are also important concepts in LLVM IR.
A basic block is a group of instructions that always run together with a single entry point at the beginning and a single exit point at the end.
A basic block in LLVM IR always has a label at the beginning and a branching instruction at the end (<code class="docutils literal notranslate"><span class="pre">br</span></code>, <code class="docutils literal notranslate"><span class="pre">ret</span></code>, etc.).
Control flow occurs between basic blocks.</p>
<p>Here the <code class="docutils literal notranslate"><span class="pre">body.0</span></code> basic block performs some operations and then branches unconditionally to another basic block labeled <code class="docutils literal notranslate"><span class="pre">body.1</span></code>.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">body</span><span class="mf">.0</span><span class="o">:</span>
  <span class="o">%</span><span class="mi">0</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
  <span class="o">%</span><span class="n">result</span> <span class="o">=</span> <span class="n">sub</span> <span class="n">i32</span> <span class="o">%</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span>
  <span class="n">br</span> <span class="n">label</span> <span class="o">%</span><span class="n">body</span><span class="mf">.1</span>
</pre></div>
</div>
<p>All of the basic blocks and instructions shown in the Scheduler Viewer are directly from the LLVM IR optimized by SmartHLS before being compiled into Verilog.</p>
</section>
<section id="call-graph">
<h3><span class="section-number">1.17.2. </span>Call Graph<a class="headerlink" href="#call-graph" title="Permalink to this headline">¶</a></h3>
<p>When you open the Scheduler Viewer, the default view is of the Call Graph.
You can also click on the “Call Graph” tab at the top.
The Call Graph shows the top-level function and all of the sub-functions that are called.</p>
<p>For example the following code has a function <code class="docutils literal notranslate"><span class="pre">main</span></code> which calls <code class="docutils literal notranslate"><span class="pre">top_level</span></code> which in turn calls
<code class="docutils literal notranslate"><span class="pre">helper_func_0</span></code> and <code class="docutils literal notranslate"><span class="pre">helper_func_1</span></code>.
The <code class="docutils literal notranslate"><span class="pre">noinline</span></code> attributes makes sure that SmartHLS does not inline these small functions into the
main function body, making sure we can see them in the Call Graph.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">helper_func_0</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gv</span> <span class="o">+=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">helper_func_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">gv</span> <span class="o">-=</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__attribute__</span><span class="p">((</span><span class="n">noinline</span><span class="p">))</span>
<span class="kt">void</span> <span class="n">top_level</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">helper_func_0</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">helper_func_1</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">top_level</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This will generate the Call Graph shown below.
The Call Graph shows that <code class="docutils literal notranslate"><span class="pre">main</span></code> calls <code class="docutils literal notranslate"><span class="pre">top_level</span></code>, which in turn calls <code class="docutils literal notranslate"><span class="pre">helper_func_0</span></code> and <code class="docutils literal notranslate"><span class="pre">helper_function_1</span></code>.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Call_Graph.png"><img alt="_images/Schedule_Viewer_Call_Graph.png" class="align-center" src="_images/Schedule_Viewer_Call_Graph.png" style="width: 698.5999999999999px; height: 445.2px;" /></a>
</section>
<section id="control-flow-graph">
<h3><span class="section-number">1.17.3. </span>Control Flow Graph<a class="headerlink" href="#control-flow-graph" title="Permalink to this headline">¶</a></h3>
<p>The Control Flow Graph can be brought up by clicking on any function in the Explorer tab.
The Control Flow Graph shows the connections between basic blocks and shows which basic blocks can branch to which other basic blocks.</p>
<p>For example the following code has an if/else statement and then a for-loop in the else body.
This has multiple code blocks and branches to different sections of the code.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">gv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">gv</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This Control Flow Graph shows the two paths of the if statement on the right and the else statement on the left, and the for-loop in the left middle bubbles.
Control flow is represented by an arrow, where a basic block will only branch into another basic block that it points to.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Control_Flow_Graph.png"><img alt="_images/Schedule_Viewer_Control_Flow_Graph.png" class="align-center" src="_images/Schedule_Viewer_Control_Flow_Graph.png" style="width: 698.5999999999999px; height: 443.79999999999995px;" /></a>
</section>
<section id="schedule-chart">
<h3><span class="section-number">1.17.4. </span>Schedule Chart<a class="headerlink" href="#schedule-chart" title="Permalink to this headline">¶</a></h3>
<p>If you click on a non-pipelined block, the Schedule Chart will open.
This shows the scheduling of instructions within a block on a cycle-by-cycle basis.</p>
<p>For the following example, two multiplies are made then added and stored to a variable.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">mult1</span> <span class="o">=</span> <span class="n">coeff1</span> <span class="o">*</span> <span class="n">coeff1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">mult2</span> <span class="o">=</span> <span class="n">coeff2</span> <span class="o">*</span> <span class="n">coeff2</span><span class="p">;</span>
<span class="n">gv</span> <span class="o">=</span> <span class="n">mult1</span> <span class="o">+</span> <span class="n">mult2</span><span class="p">;</span>
</pre></div>
</div>
<p>In the Schedule Chart, we can see the instructions that these lines of code turn into and the cycles they are scheduled for.
For example, we can see the add is scheduled for cycle 4 and takes 1 cycle.
You can mouse over the scheduled instructions in the Schedule Chart and the selected instruction will be highlighted in yellow.
Instructions that the highlighted instruction depend on will be outlined in red and the instructions that depend on the highlighted instruction will be outlined in orange.
Here the add depends on the two multiplies highlighted in red. The store highlighted in orange depends on this add.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Schedule_Chart.png"><img alt="_images/Schedule_Viewer_Schedule_Chart.png" class="align-center" src="_images/Schedule_Viewer_Schedule_Chart.png" style="width: 699.3px; height: 444.5px;" /></a>
</section>
<section id="pipeline-viewer">
<h3><span class="section-number">1.17.5. </span>Pipeline Viewer<a class="headerlink" href="#pipeline-viewer" title="Permalink to this headline">¶</a></h3>
<p>If you click on a pipelined block, the Pipeline Viewer will open.
This shows the scheduling of instructions within a pipelined block on a cycle-by-cycle basis.</p>
<p>For the following example a value is loaded an array, added to a value, then it is stored back into the array.
This is done repeatedly in a loop and the loop is pipelined.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma HLS loop pipeline</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeff1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In the Pipeline Viewer, we find the name and initiation interval (II) for the pipeline at the top.
The column headings in the first row show the clock cycle and pipeline stages for each column.
The remaining rows show the instructions that run in the pipeline at each stage.
The left-most column indicates the loop iteration for the instructions in the row starting from Iteration 0. For function pipelines, Iteration 0 corresponds to the first input.
If you hold your mouse over an instruction you will see more details about the operation type.
In the pipeline viewer, the right-most column highlighted in a thick black box shows the behavior of the pipeline in steady state.
The last row shown in the pipeline viewer (Iteration 1) is the first iteration of the pipeline in steady state.</p>
<a class="reference internal image-reference" href="_images/Schedule_Viewer_Pipeline_Viewer.png"><img alt="_images/Schedule_Viewer_Pipeline_Viewer.png" class="align-center" src="_images/Schedule_Viewer_Pipeline_Viewer.png" style="width: 697.9px; height: 444.5px;" /></a>
</section>
</section>
<section id="instantiating-smarthls-ip-core-in-libero-smartdesign">
<span id="smartdesign"></span><h2><span class="section-number">1.18. </span>Instantiating SmartHLS IP Core in Libero SmartDesign<a class="headerlink" href="#instantiating-smarthls-ip-core-in-libero-smartdesign" title="Permalink to this headline">¶</a></h2>
<p>After we use SmartHLS to design a hardware IP component, we will want to instantiate
the component into Libero SmartDesign and integrate this core into our larger system.
When SmartHLS generates the hardware, SmartHLS will also generate a <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code>
script to easily instantiate the SmartHLS-generated IP core into Libero SmartDesign.</p>
<p>You will see the log message in the console which includes the full path to the script like this:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>Info: Generating HDL+ Tcl script to be imported in SmartDesign: C:\SmartHLS-2021.2\workspace\sobel_part3\create_hdl_plus.tcl.
</pre></div>
</div>
<p>Now we can use Libero to open a Libero project, create a new SmartDesign, and give the newly created SmartDesign a suitable name.
Alternatively, we can also open an existing SmartDesign.</p>
<a class="reference internal image-reference" href="_images/create_SmartDesign_in_Libero.png"><img alt="_images/create_SmartDesign_in_Libero.png" class="align-center" src="_images/create_SmartDesign_in_Libero.png" style="width: 275.0px; height: 97.0px;" /></a>
<p>We now go to the Libero <code class="docutils literal notranslate"><span class="pre">Project</span></code> menu and select <code class="docutils literal notranslate"><span class="pre">Execute</span> <span class="pre">Script</span></code> and give the path to
the generated <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> script as shown in the figures below. Then click <code class="docutils literal notranslate"><span class="pre">Run</span></code>.
Running the Tcl script will add the SmartHLS-generated HDL+ component (<code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> in this example),
all required Verilog files, memory initialization files, and other dependencies to the Libero project.</p>
<a class="reference internal image-reference" href="_images/projects_execute_script.png"><img alt="_images/projects_execute_script.png" class="align-center" src="_images/projects_execute_script.png" style="width: 166.0px; height: 272.0px;" /></a>
<a class="reference internal image-reference" href="_images/execute_script.png"><img alt="_images/execute_script.png" class="align-center" src="_images/execute_script.png" style="width: 385.0px; height: 142.0px;" /></a>
<p>As shown in the figures below, we can now instantiate the component in SmartDesign by right-clicking on the HDL+ component
(<code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> in this example) in the <code class="docutils literal notranslate"><span class="pre">Design</span> <span class="pre">Hiearchy</span></code> panel on the left and selecting <code class="docutils literal notranslate"><span class="pre">Instantiate</span> <span class="pre">in</span> <span class="pre">system</span></code>.
In the SmartDesign system we will now see the new IP component (<code class="docutils literal notranslate"><span class="pre">sobel_filter_top_0</span></code> in this example).</p>
<a class="reference internal image-reference" href="_images/instantiate_in_system.png"><img alt="_images/instantiate_in_system.png" class="align-center" src="_images/instantiate_in_system.png" style="width: 393.0px; height: 190.0px;" /></a>
<a class="reference internal image-reference" href="_images/new_IP_component.png"><img alt="_images/new_IP_component.png" class="align-center" src="_images/new_IP_component.png" style="width: 335.0px; height: 199.0px;" /></a>
<p>The generated <code class="docutils literal notranslate"><span class="pre">create_hdl_plus.tcl</span></code> script will automatically group ports as AXI4-Master, AXI4-Slave or AXI4-Stream
interfaces if they match the corresponding AXI4 specifications. In this example, since the <code class="docutils literal notranslate"><span class="pre">sobel_filter_top</span></code> IP component
used SmartHLS FIFOs as top-level arguments and they match AXI4-Stream specifications, SmartHLS has automatically grouped
the <code class="docutils literal notranslate"><span class="pre">output_fifo</span></code> and <code class="docutils literal notranslate"><span class="pre">input_fifo</span></code> data/ready/valid ports as AXI4-Stream interfaces.</p>
<p>We also have the option to expose the sub-signals under the AXI4-Stream bus. This will allow us to connect individual
ports instead of the entire bus. To do this, right click on the AXI4-Stream bus on the SmartHLS-generated IP component
and choose Show/Hide BIF Pins. Then choose the sub-signals as appropriate. For example, in the figures below, if we
choose all 3 sub-signals and press OK, we will see the 3 corresponding ports in the IP component: <code class="docutils literal notranslate"><span class="pre">output_fifo_ready</span></code>
as an input, and <code class="docutils literal notranslate"><span class="pre">output_fifo[7:0]</span></code> and <code class="docutils literal notranslate"><span class="pre">output_fifo_axi4stream</span></code> as the outputs.</p>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals1.png"><img alt="_images/AXI4_Stream_subsignals1.png" class="align-center" src="_images/AXI4_Stream_subsignals1.png" style="width: 241.0px; height: 173.0px;" /></a>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals2.png"><img alt="_images/AXI4_Stream_subsignals2.png" class="align-center" src="_images/AXI4_Stream_subsignals2.png" style="width: 190.0px; height: 159.0px;" /></a>
<a class="reference internal image-reference" href="_images/AXI4_Stream_subsignals3.png"><img alt="_images/AXI4_Stream_subsignals3.png" class="align-center" src="_images/AXI4_Stream_subsignals3.png" style="width: 202.0px; height: 115.0px;" /></a>
</section>
<section id="smarthls-command-line-interface">
<h2><span class="section-number">1.19. </span>SmartHLS Command Line Interface<a class="headerlink" href="#smarthls-command-line-interface" title="Permalink to this headline">¶</a></h2>
<p>SmartHLS can run in command line with the following command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>shls <span class="o">[</span>-h<span class="o">]</span> &lt;cmd&gt;
</pre></div>
</div>
<dl class="simple">
<dt>Where <code class="docutils literal notranslate"><span class="pre">&lt;cmd&gt;</span></code> can be one of:</dt><dd><ul class="simple">
<li><p><strong>hw</strong> (default): Run the hardware-only flow.</p></li>
<li><p><strong>sw</strong> : Compile and run the program in software on host machine.</p></li>
<li><p><strong>sim</strong>: Simulate the SmartHLS-generated circuit in ModelSim (only for hardware flow).</p></li>
<li><p><strong>cosim</strong>: Verify the SmartHLS-generated circuit using C test bench (only for hardware flow).</p></li>
<li><p><strong>fpga</strong>: Fully synthesize design for target FPGA.</p></li>
<li><p><strong>scheduleviewer</strong>: Show the scheduler viewer.</p></li>
<li><p><strong>clean</strong>: Delete files generated by SmartHLS.</p></li>
</ul>
</dd>
</dl>
</section>
</section>


           </div>
           
          </div>
          <footer>
<!-- Amandeep.Talwar: Moved the footer code to layout.html to resolve conflict with the Microchip template -->
</footer>

        </div>
      </div>
      </div>
    </section>


  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

  
<footer _ngcontent-hes-c23=""><div _ngcontent-hes-c23="" class="social-icons">
<a _ngcontent-hes-c23="" href="https://github.com/MicrochipTech/" target="_top">
<div _ngcontent-hes-c23="" class="facebook"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="fa-github-square" class="svg-inline--fa fa-github-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path
     fill="currentColor"
     d="m 151.375,357.33334 q 1.16667,-2 -0.875,-4.33334 -2.625,-2.33334 -4.08333,-0.66666 -1.16667,2 0.875,4.33332 2.625,2.33334 4.08333,0.66668 z m -8.16667,-13.66668 q -1.45833,-2.33332 -3.5,-1.33332 -1.75,1.33332 0,4 2.04167,2.66666 3.5,1.66666 1.75,-1.33334 0,-4.33334 z M 131.25,330.33334 Q 131.83333,329 129.79167,327.66666 127.75,327 127.45833,328.33334 126.58333,330 128.625,331 q 2.33333,0.66666 2.625,-0.66666 z M 137.375,338 q 0.58333,-0.33334 0.4375,-1.5 -0.14583,-1.16666 -1.02083,-1.83334 -1.75,-2.33332 -2.91667,-1 -1.16667,1.33334 0.29167,3.66668 1.75,2 3.20833,0.66666 z m 25.08333,25 q 0.58334,-2.33334 -2.625,-3.66666 -2.625,-1 -3.79166,1.33332 -0.58334,2.33334 2.625,3.66668 2.625,1 3.79166,-1.33334 z m 12.25,1 q 0,-2.66666 -3.5,-2.66666 -2.91666,0 -2.91666,2.66666 0,2.66666 3.20833,2.66666 3.20833,0 3.20833,-2.66666 z m 11.375,-2.33334 Q 185.5,359.33334 182.29167,360 q -3.20834,0.66666 -2.625,3 0.58333,2.66666 3.5,2 2.91666,-0.66666 2.91666,-3.33334 z M 373.33333,256 q 0,-70.66666 -43.75,-120.66666 Q 285.83333,85.333334 224,85.333334 q -61.83333,0 -105.58333,50.000006 -43.750003,50 -43.750003,120.66666 0,55.66666 28.583333,100.16666 28.58333,44.5 73.5,61.83334 5.25,1 7.72917,-1.66666 2.47916,-2.66668 2.47916,-6.66668 0,-17.33332 -0.29166,-31.66666 -1.75,0.33334 -4.52084,0.83334 -2.77083,0.5 -10.35416,0.66666 -7.58334,0.16666 -14,-1.33334 -6.41667,-1.5 -12.6875,-6.66666 Q 138.83333,366.33334 136.5,357.66666 129.79167,338 119.875,333 q -0.58333,-0.33334 -1.3125,-1.16666 L 116.22917,329.16666 114.1875,326 l 1.16667,-2.5 5.6875,-1.16666 q 1.75,0 4.375,0.66666 2.625,0.66666 8.75,5.16666 6.125,4.5 9.625,11.83334 4.66666,9.33334 10.9375,14 6.27083,4.66666 12.6875,4.66666 6.41666,0 11.08333,-1.16666 4.66667,-1.16666 8.75,-3.16666 2.04167,-15.66668 9.625,-23 -14.29167,-2 -25.08333,-6.16668 Q 161,321 150.5,312.16666 140,303.33334 134.3125,286.83334 128.625,270.33334 128.625,247 q 0,-26.33334 15.45833,-45.66666 -7,-20.66668 1.45834,-45.33334 5.54166,-2 15.89583,2.5 10.35417,4.5 17.64583,9.83334 l 7.58334,5.33332 Q 203.58333,168 224,168 q 20.41667,0 37.33333,5.66666 3.20834,-2.33332 8.3125,-6 Q 274.75,164 285.83333,159 q 11.08334,-5 16.625,-3 8.45834,24.66666 1.45834,45.33334 Q 319.375,220.66666 319.375,247 q 0,19 -4.08333,33.5 -4.08334,14.5 -10.35417,23.33334 -6.27083,8.83332 -15.60417,14.83332 -9.33333,6 -18.22916,8.66668 -8.89584,2.66666 -19.97917,4 10.20833,10.33332 10.20833,31.66666 0,13.33334 -0.14583,29.66666 -0.14583,16.33334 -0.14583,17 0,4 2.47916,6.66668 Q 266,419 271.25,418 316.16667,400.66666 344.75,356.16666 373.33333,311.66666 373.33333,256 Z M 448,96 v 320 q 0,39.66666 -24.64583,67.83334 Q 398.70833,512 364,512 H 84 Q 49.291667,512 24.645833,483.83334 0,455.66666 0,416 V 96 Q 0,56.333334 24.645833,28.166666 49.291667,0 84,0 H 364 Q 398.70833,0 423.35417,28.166666 448,56.333334 448,96 Z"/></svg></fa-icon></div>
</a>



<a _ngcontent-hes-c23="" href="https://www.facebook.com/pages/Microchip-Technology-Inc/20320981741" target="_top">
<div _ngcontent-hes-c23="" class="facebook"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="facebook-square" class="svg-inline--fa fa-facebook-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48A48 48 0 0 0 0 80v352a48 48 0 0 0 48 48h137.25V327.69h-63V256h63v-54.64c0-62.15 37-96.48 93.67-96.48 27.14 0 55.52 4.84 55.52 4.84v61h-31.27c-30.81 0-40.42 19.12-40.42 38.73V256h68.78l-11 71.69h-57.78V480H400a48 48 0 0 0 48-48V80a48 48 0 0 0-48-48z"></path></svg></fa-icon></div></a>
<a _ngcontent-hes-c23="" href="https://google.com/+MicrochipTech" target="_top"><div _ngcontent-hes-c23="" class="google"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="google-plus-square" class="svg-inline--fa fa-google-plus-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zM164 356c-55.3 0-100-44.7-100-100s44.7-100 100-100c27 0 49.5 9.8 67 26.2l-27.1 26.1c-7.4-7.1-20.3-15.4-39.8-15.4-34.1 0-61.9 28.2-61.9 63.2 0 34.9 27.8 63.2 61.9 63.2 39.6 0 54.4-28.5 56.8-43.1H164v-34.4h94.4c1 5 1.6 10.1 1.6 16.6 0 57.1-38.3 97.6-96 97.6zm220-81.8h-29v29h-29.2v-29h-29V245h29v-29H355v29h29v29.2z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.linkedin.com/company/microchip-technology" target="_top"><div _ngcontent-hes-c23="" class="linkedin"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="linkedin" class="svg-inline--fa fa-linkedin fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://twitter.com/MicrochipTech" target="_top"><div _ngcontent-hes-c23="" class="twitter"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter-square" class="svg-inline--fa fa-twitter-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.5 32 0 53.5 0 80v352c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V80c0-26.5-21.5-48-48-48zm-48.9 158.8c.2 2.8.2 5.7.2 8.5 0 86.7-66 186.6-186.6 186.6-37.2 0-71.7-10.8-100.7-29.4 5.3.6 10.4.8 15.8.8 30.7 0 58.9-10.4 81.4-28-28.8-.6-53-19.5-61.3-45.5 10.1 1.5 19.2 1.5 29.6-1.2-30-6.1-52.5-32.5-52.5-64.4v-.8c8.7 4.9 18.9 7.9 29.6 8.3a65.447 65.447 0 0 1-29.2-54.6c0-12.2 3.2-23.4 8.9-33.1 32.3 39.8 80.8 65.8 135.2 68.6-9.3-44.5 24-80.6 64-80.6 18.9 0 35.9 7.9 47.9 20.7 14.8-2.8 29-8.3 41.6-15.8-4.9 15.2-15.2 28-28.8 36.1 13.2-1.4 26-5.1 37.8-10.2-8.9 13.1-20.1 24.7-32.9 34z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.youtube.com/user/MicrochipTechnology" target="_top"><div _ngcontent-hes-c23="" class="youtube"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="youtube-square" class="svg-inline--fa fa-youtube-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M186.8 202.1l95.2 54.1-95.2 54.1V202.1zM448 80v352c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V80c0-26.5 21.5-48 48-48h352c26.5 0 48 21.5 48 48zm-42 176.3s0-59.6-7.6-88.2c-4.2-15.8-16.5-28.2-32.2-32.4C337.9 128 224 128 224 128s-113.9 0-142.2 7.7c-15.7 4.2-28 16.6-32.2 32.4-7.6 28.5-7.6 88.2-7.6 88.2s0 59.6 7.6 88.2c4.2 15.8 16.5 27.7 32.2 31.9C110.1 384 224 384 224 384s113.9 0 142.2-7.7c15.7-4.2 28-16.1 32.2-31.9 7.6-28.5 7.6-88.1 7.6-88.1z"></path></svg></fa-icon></div></a><a _ngcontent-hes-c23="" href="https://www.microchip.com/rss/" target="_top"><div _ngcontent-hes-c23="" class="rss"><fa-icon _ngcontent-hes-c23="" class="ng-fa-icon"><svg role="img" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss-square" class="svg-inline--fa fa-rss-square fa-w-14" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentColor" d="M400 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V80c0-26.51-21.49-48-48-48zM112 416c-26.51 0-48-21.49-48-48s21.49-48 48-48 48 21.49 48 48-21.49 48-48 48zm157.533 0h-34.335c-6.011 0-11.051-4.636-11.442-10.634-5.214-80.05-69.243-143.92-149.123-149.123-5.997-.39-10.633-5.431-10.633-11.441v-34.335c0-6.535 5.468-11.777 11.994-11.425 110.546 5.974 198.997 94.536 204.964 204.964.352 6.526-4.89 11.994-11.425 11.994zm103.027 0h-34.334c-6.161 0-11.175-4.882-11.427-11.038-5.598-136.535-115.204-246.161-251.76-251.76C68.882 152.949 64 147.935 64 141.774V107.44c0-6.454 5.338-11.664 11.787-11.432 167.83 6.025 302.21 141.191 308.205 308.205.232 6.449-4.978 11.787-11.432 11.787z"></path></svg></fa-icon></div></a></div><div _ngcontent-hes-c23="" id="mchip-overlay" onclick="off()" style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; z-index: 1000; background-color: rgba(0,0,0,.3); display: none;"><div _ngcontent-hes-c23="" style="position: relative; width: 100%; height: 100%;"></div></div><div _ngcontent-hes-c23="" class="links"><nav _ngcontent-hes-c23=""><a _ngcontent-hes-c23="" href="https://www.microchip.com/products/" target="_top">Products</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/technology/" target="_top">Applications</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/technology/" target="_top">Design</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/training/" target="_top">Training</a><a _ngcontent-hes-c23="" href="https://www.microchipdirect.com/" target="_top">Sample</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/aboutus/" target="_top">About</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/contactus/" target="_top">Contact</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/legal/" target="_top">Legal</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/about-us/legal-information/privacy-policy" target="_top">Privacy Policy</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/investors/" target="_top">Investors</a><a _ngcontent-hes-c23="" href="https://www.microchip.com/careers/" target="_top">Careers</a><a _ngcontent-hes-c23="" href="https://support.microchip.com/" target="_top">Support</a></nav><p _ngcontent-hes-c23="" class="links">©Copyright 2021 Microchip Technology Inc. All rights reserved.</p></div></footer>
</body>
</html>