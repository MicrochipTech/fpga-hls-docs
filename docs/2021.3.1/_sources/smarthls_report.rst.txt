Report Files
----------------------

SmartHLS Report
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

After compiling software to hardware, SmartHLS generates a summary report file
(``hls_output/reports/summary.hls.rpt``) to show some insights about the generated RTL
circuit, such as the top-level module interface, scheduling information, memory
usage and etc.
The following will explain each section of the report file.

RTL Interface Section
++++++++++++++++++++++

The RTL Interface section shows the interfaces used by the top-level module. 
Below is an example of the RTL interface report table:

.. code-block:: text

  +---------------------------------------------------------------------------------------------+
  | RTL Interface Generated by SmartHLS                                                         |
  +--------------+-------------------+--------------------+------------------+------------------+
  | C++ Name     | Interface Type    | Signal Name        | Signal Bit-width | Signal Direction |
  +--------------+-------------------+--------------------+------------------+------------------+
  |              | Control           | clk                | 1                | input            |
  |              |                   | finish             | 1                | output           |
  |              |                   | ready              | 1                | output           |
  |              |                   | reset              | 1                | input            |
  |              |                   | start              | 1                | input            |
  +--------------+-------------------+--------------------+------------------+------------------+
  | input_a_fifo | Input AXI Stream  | input_a_fifo_ready | 1                | output           |
  |              |                   | input_a_fifo_valid | 1                | input            |
  |              |                   | input_a_fifo       | 16               | input            |
  +--------------+-------------------+--------------------+------------------+------------------+

The table shows the interface for each top-level function argument (or global
variable accessed by both the SW testbench and the top-level function).
  * The first column of the table shows the name of the argument or global
    variable.
  * The second column shows the interface types used for this argument or
    global variable.
  * The last three columns list the names, bit-widths, and directions for all
    the signals that are included in the interface. For example, the AXI Stream
    interface has three signals in this case, `input_a_fifo` for the 16-bit
    data, with associated valid and ready signals.

Note that the `Control` interface is the standard module control interface that
is always used by any SmartHLS-generated module, and hence there is no C++ name
attached to it.
For more details about the RTL interface, please refer to :ref:`rtl_interface`.


Scheduling Result
++++++++++++++++++++++

The scheduling result section primarily shows the cycle latency of each basic
block inside each function.
A basic block is a collection of instructions that always run together.
Below is an example table:

.. code-block:: text

  Basic Block Latencies:
  
  +-------------------------------------------------+
  | Function: sobel_filter (non-pipelined function) |
  +--------------------------------+----------------+
  | Basic Block                    | Cycle Latency  |
  +--------------------------------+----------------+
  | %entry                         | 1              |
  | %for.cond1.preheader           | 1              |
  | %for.body3                     | 2              |
  | %for.body3.for.inc54_crit_edge | 1              |
  | %for.cond14.preheader          | 9              |
  | %for.inc54                     | 2              |
  | %for.inc57                     | 1              |
  | %for.end59                     | 1              |
  +--------------------------------+----------------+

SmartHLS's `Schedule Viewer` is more helpful in this case to visualize the
scheduling and the control-flow between basic blocks.

Pipeline Result
++++++++++++++++++++++

The pipeline result section reports the initiation interval, pipeline length, iteration count, and latency for each pipelined loop or function.

.. code-block:: text

  +--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
  | Label              | Function                   | Basic Block | Location in Source Code        | Initiation Interval | Pipeline Length | Iteration Count | Latency |
  +--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+
  | loop_test_injector | test_input_injector(void*) | %for.body   | line 19 of test_util.cpp       | 1                   | 2               | 262144          | 262145  |
  | gaussian_loop      | gaussian_filter(void*)     | %while.body | line 63 of gaussian_filter.cpp | 1                   | 8               | n/a             | n/a     |
  | loop_test_checker  | test_output_checker(void*) | %for.body   | line 39 of test_util.cpp       | 1                   | 3               | 262144          | 262146  |
  +--------------------+----------------------------+-------------+--------------------------------+---------------------+-----------------+-----------------+---------+

The iteration count and latency may not be available for a pipelined function or a pipelined loop with non-deterministic loop bound.
Please refer to :ref:`loop_pipelining` and :ref:`function_pipelining` for more details.
SmartHLS's `Schedule Viewer` also gives more details about how individual instructions are scheduled inside each pipeline.

Memory Usage
++++++++++++++++++++++

The memory usage section lists the memories used by the generated circuit, grouped by the type of memory architecture.
Please refer to :ref:`mem_arch` section for more details about the memory architecture used by SmartHLS.

.. code-block:: text

  +-------------------------------------------------------------------------+
  | Local Constant Memories                                                 |
  +-------+-----------------------+------+-------------+------------+-------+
  | Name  | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
  +-------+-----------------------+------+-------------+------------+-------+
  | gauss | blackscholes_hw       | ROM  | 8192        | 32         | 256   |
  +-------+-----------------------+------+-------------+------------+-------+
  
  +-------------------------------------------------------------------------------------------------------------------------+
  | Shared Local Memories                                                                                                   |
  +-------------+--------------------------------------------------------+---------------+-------------+------------+-------+
  | Name        | Accessing Function(s)                                  | Type          | Size [Bits] | Data Width | Depth |
  +-------------+--------------------------------------------------------+---------------+-------------+------------+-------+
  | init_fifo   | mersenne_twister_generate_hw, mersenne_twister_init_hw | FIFO (LUTRAM) | 64          | 32         | 2     |
  | random_fifo | blackscholes_hw, mersenne_twister_generate_hw          | FIFO (LUTRAM) | 64          | 32         | 2     |
  | idata_0     | mersenne_twister_init_hw, option_pricing               | Register      | 1           | 1          | 1     |
  | idata_1     | mersenne_twister_init_hw, option_pricing               | Register      | 32          | 32         | 1     |
  | tdata_0     | mersenne_twister_generate_hw, option_pricing           | Register      | 32          | 32         | 1     |
  | tdata_1     | mersenne_twister_generate_hw, option_pricing           | Register      | 32          | 32         | 1     |
  | bdata_0     | blackscholes_hw, option_pricing                        | Register      | 32          | 32         | 1     |
  | bdata_1     | blackscholes_hw, option_pricing                        | Register      | 32          | 32         | 1     |
  +-------------+--------------------------------------------------------+---------------+-------------+------------+-------+

  +----------------------------------------------------------------------------------------------------------------+
  | Aliased Memories                                                                                               |
  +------------------------+---------------------+-----------------------+------+-------------+------------+-------+
  | Name                   | Memory Controller   | Accessing Function(s) | Type | Size [Bits] | Data Width | Depth |
  +------------------------+---------------------+-----------------------+------+-------------+------------+-------+
  | foo_entry_local_array1 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     |
  | foo_entry_local_array2 | memory_controller_0 | foo, foo_sub          | RAM  | 160         | 32         | 5     |
  +------------------------+---------------------+-----------------------+------+-------------+------------+-------+
  
  +------------------------------------------------------------------------------------------+
  | I/O Memories                                                                             |
  +--------+-----------------------+----------------------+-------------+------------+-------+
  | Name   | Accessing Function(s) | Type                 | Size [Bits] | Data Width | Depth |
  +--------+-----------------------+----------------------+-------------+------------+-------+
  | rd_reg | kernel                | Register (Read-Only) | 0           | 16         | 0     |
  | rd_arr | kernel                | ROM                  | 0           | 16         | 0     |
  | wr_reg | kernel                | Register             | 0           | 16         | 0     |
  | wr_arr | kernel                | RAM                  | 0           | 16         | 0     |
  +--------+-----------------------+----------------------+-------------+------------+-------+

The example tables above show the accessing functions and the hardware implementation of each "memory" in the software.

  * The `Type` column shows how a memory is implemented in hardware, which could be in RAM, ROM (read-only), register or FIFO (only applicable to ``hls::FIFO`` type variables in C++).
  * The `Size` column reports the total size of the memory in bits, equals to `Data Width` * `Depth`.
  * The `Data Width` refers to the bit-width of the data ports of a RAM/FIFO, or the bit-width of a register.
  * The `Depth` field represents the depth of a RAM or FIFO, and it is always 1 for register.
  * `Aliased Memories` have an additional column showing the name of the `Memory Controller` of which the memory is being placed behind.
    So you can see which memories are aliasing and being put behind the same memory controller to support aliased memory accesses.

Simulation and RTL Synthesis, Place & Route Report
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

SmartHLS also generates a summary report (``hls_output/reports/summary.results.rpt``) to show
the results of simulation and RTL synthesis + Place & Route.
Below is an example report:

.. code-block:: text

  ====== 1. Simulation Cycle Latency ======
  
  Number of calls:        6,105
  Cycle latency:        6,134
  SW/HW co-simulation: PASS

  ====== 2. Timing Result ======
  
  +--------------+---------------+-------------+-------------+----------+-------------+
  | Clock Domain | Target Period | Target Fmax | Worst Slack | Period   | Fmax        |
  +--------------+---------------+-------------+-------------+----------+-------------+
  | clk          | 10.000 ns     | 100.000 MHz | 5.775 ns    | 4.225 ns | 236.686 MHz |
  +--------------+---------------+-------------+-------------+----------+-------------+
  
  The reported Fmax is for the HLS core in isolation (from Libero's post-place-and-route timing analysis).
  When the HLS core is integrated into a larger system, the system Fmax may be lower depending on the critical path of the system.
  
  ====== 3. Resource Usage ======
  
  +--------------------------+----------+--------+------------+
  | Resource Type            | Used     | Total  | Percentage |
  +--------------------------+----------+--------+------------+
  | Fabric + Interface 4LUT* | 488 + 72 | 108600 | 0.52       |
  | Fabric + Interface DFF*  | 397 + 72 | 108600 | 0.43       |
  | I/O Register             | 0        | 852    | 0.00       |
  | User I/O                 | 0        | 284    | 0.00       |
  | uSRAM                    | 0        | 1008   | 0.00       |
  | LSRAM                    | 2        | 352    | 0.57       |
  | Math                     | 0        | 336    | 0.00       |
  +--------------------------+----------+--------+------------+
  
  * Interface 4LUTs and DFFs are occupied due to the uses of LSRAM, Math, and uSRAM.
    Number of interface 4LUTs/DFFs = (36 * #.LSRAM) + (36 * #.Math) + (12 * #.uSRAM) = (36 * 2) + (36 * 0) + (12 * 0) = 72.

The first section shows the result of `SW/HW co-simulation`, including the
number of calls of the top-level function, the total cycle latency for running
the whole simulation, and whether the SW/HW co-simulation has passed.

Note that when :ref:`function_pipelining` is used, the auto-generated RTL
testbench for SW/HW co-simulation can inject a new set of inputs to the
top-level module without waiting for the previous "function calls" to finish.
And because of this overlapped execution, you could see the average cycle per
call being close to the reported initiation interval of the pipelined function.
For instance, the example report above is from a pipelined function with an
initiation interval of 1, and we can see that the average cycle per call is
very close to 1 (6,134/6,105).

The next two sections show the timing and resource usage results, parsed from
Libero's report files after running RTL Synthesis and Place & Route.
The target period is what you set in :ref:`smarthls_constraints`. If the `Clock
Period` is not set, SmartHLS uses a default clock period for the target FPGA
family (see the table in :ref:`smarthls_constraints`).
